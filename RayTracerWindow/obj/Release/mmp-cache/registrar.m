#include <xamarin/xamarin.h>
#include "registrar.h"
extern "C" {
static id native_to_managed_trampoline_1 (id self, SEL _cmd, MonoMethod **managed_method_ptr, bool* call_super, uint32_t token_ref)
{
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static id native_to_managed_trampoline_2 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MLModelDescription * p0, NSDictionary <NSString *, NSObject *>* p1, NSError ** p2, bool* call_super, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *mobj2 = NULL;
	void * handle2 = NULL;
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = (int *) &mobj2;

	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

	if (mobj2 != NULL)
	handle2 = xamarin_get_nsobject_handle (mobj2);
	if (p2 != NULL)
		*p2 = (id) handle2;

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static BOOL native_to_managed_trampoline_3 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static id native_to_managed_trampoline_4 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSCoder * p0, bool* call_super, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	uint8_t flags = NSObjectFlagsNativeRef;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	bool has_nsobject = xamarin_has_nsobject (self, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (has_nsobject) {
		*call_super = true;
		goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mthis = mono_object_new (mono_domain_get (), mono_method_get_class (managed_method));
	xamarin_set_nsobject_handle (mthis, self);
	xamarin_set_nsobject_flags (mthis, flags);
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);
	xamarin_create_managed_ref (self, mthis, true);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return self;
}


static void native_to_managed_trampoline_5 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioPlayer * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_6 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioPlayer * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_7 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioRecorder * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_8 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVAudioRecorder * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_9 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_10 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMenuItem * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_11 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_12 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAlert * p0, NSInteger p1, void * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	void * a2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_13 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNotification * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_14 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_15 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTimer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_16 (id self, SEL _cmd, MonoMethod **managed_method_ptr, DOMEvent * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_17 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebFrame * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_18 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebScriptObject * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_19 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, JSContext * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_20 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSError * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_21 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSImage * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_22 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_23 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURL * p1, double p2, NSDate * p3, WebFrame * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_24 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebScriptObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSWindow * native_to_managed_trampoline_25 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebDownload * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSWindow * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_26 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLAuthenticationChallenge * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_27 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSError * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_28 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_29 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURLRequest * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_30 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSError * p1, WebDataSource * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_31 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSInteger p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_32 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLResponse * p2, WebDataSource * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSURLRequest * native_to_managed_trampoline_33 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, NSURLRequest * p2, NSURLResponse * p3, WebDataSource * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSURLRequest * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_34 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_35 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static WebView * native_to_managed_trampoline_36 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSURLRequest * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	WebView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_37 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, CGPoint p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_38 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_39 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_40 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_41 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, id<NSDraggingInfo> p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSResponder * native_to_managed_trampoline_42 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSResponder * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static float native_to_managed_trampoline_43 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_44 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_45 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSResponder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_46 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_47 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, WebFrameView * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_48 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, WebFrame * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_49 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_50 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_51 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_52 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSString * p2, WebFrame * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_53 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "WebKit.WebOpenPanelResultListenerWrapper, Xamarin.Mac", "WebKit.IWebOpenPanelResultListener, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_54 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_55 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, SEL p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? xamarin_get_selector (p1, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_56 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSObject * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_57 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, unsigned long long p1, id<NSDraggingInfo> p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_58 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, unsigned long long p1, CGPoint p2, NSPasteboard * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_59 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSString * p1, NSURLRequest * p2, WebFrame * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_60 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSURLRequest * p2, WebFrame * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_61 (id self, SEL _cmd, MonoMethod **managed_method_ptr, WebView * p0, NSDictionary * p1, NSURLRequest * p2, NSString * p3, NSObject * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj4 = NULL;
	MonoObject *mobj4 = NULL;
	int32_t created4 = false;
	MonoType *paramtype4 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = p3 ? mono_string_new (mono_domain_get (), [p3 UTF8String]) : NULL;
	nsobj4 = (NSObject *) p4;
	if (nsobj4) {
		paramtype4 = xamarin_get_parameter_type (managed_method, 4);
		mobj4 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj4, false, paramtype4, &created4, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [4] = mobj4;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_62 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKRequest * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_63 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKRequest * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_64 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKProductsRequest * p0, SKProductsResponse * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_65 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SKPhysicsContact * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_66 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, NSError * p1, uint32_t token_ref)
{
	void * a0 = p0;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_67 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SCNPhysicsWorld * p0, SCNPhysicsContact * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static Class native_to_managed_trampoline_68 (id self, SEL _cmd, MonoMethod **managed_method_ptr, Class p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? xamarin_get_class (p0, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_69 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFSelection * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static Class native_to_managed_trampoline_70 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? mono_string_new (mono_domain_get (), [p0 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_71 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, PDFActionRemoteGoTo * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_72 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSString * native_to_managed_trampoline_73 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGFloat native_to_managed_trampoline_74 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, CGFloat p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_75 (id self, SEL _cmd, MonoMethod **managed_method_ptr, PDFView * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_76 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_77 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSViewController * native_to_managed_trampoline_78 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSViewController * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_79 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_80 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetListViewController * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_81 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_82 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, NSString * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_83 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NCWidgetSearchViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_84 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKAnnotationView * p1, NSUInteger p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	unsigned long long nativeEnum3 = p3;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;
	arg_ptrs [3] = &nativeEnum3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static MKClusterAnnotation * native_to_managed_trampoline_85 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKClusterAnnotation * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				MonoType *type1;
				type1 = xamarin_get_parameter_type (managed_method, 1);
				mobj1 = xamarin_get_inative_object_dynamic (nobj, false, mono_type_get_object (mono_domain_get (), mono_class_get_type (e_class)), &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_86 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_87 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_88 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKAnnotationView * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_89 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_90 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_91 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, MKUserLocation * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static MKAnnotationView * native_to_managed_trampoline_92 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKAnnotationView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "MapKit.MKAnnotationWrapper, Xamarin.Mac", "MapKit.IMKAnnotation, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static MKOverlayRenderer * native_to_managed_trampoline_93 (id self, SEL _cmd, MonoMethod **managed_method_ptr, MKMapView * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	MKOverlayRenderer * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "MapKit.MKOverlayWrapper, Xamarin.Mac", "MapKit.IMKOverlay, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_94 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKCameraDeviceView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_95 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKCameraDeviceView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_96 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKDeviceBrowserView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_97 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSEvent * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_98 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_99 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, NSInteger p1, NSEvent * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_100 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKImageBrowserView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_101 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKSaveOptions * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_102 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_103 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSURL * p1, NSData * p2, NSError * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_104 (id self, SEL _cmd, MonoMethod **managed_method_ptr, IKScannerDeviceView * p0, NSURL * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_105 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKGameCenterViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_106 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKAchievementViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_107 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKChallenge * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_108 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKChallenge * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_109 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKFriendRequestComposeViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_110 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKLeaderboardViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_111 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_112 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_113 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, GKPlayer * p2, GKPlayer * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_114 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSData * p1, GKPlayer * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_115 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_116 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, GKPlayer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_117 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_118 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, NSString * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_119 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatch * p0, GKPlayer * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_120 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_121 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_122 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, GKMatch * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_123 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_124 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, GKPlayer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_125 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_126 (id self, SEL _cmd, MonoMethod **managed_method_ptr, GKMatchmakerViewController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_127 (id self, SEL _cmd, MonoMethod **managed_method_ptr, EAAccessory * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_128 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, unsigned int p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_129 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_130 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSInteger p1, CLRegion * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum1 = p1;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_131 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLRegion * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_132 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_133 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_134 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLRegion * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_135 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_136 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CLLocationManager * p0, CLLocation * p1, CLLocation * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_137 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_138 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_139 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, CBPeripheral * p1, NSDictionary * p2, NSNumber * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_140 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_141 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_142 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBCentralManager * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_143 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBL2CAPChannel * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_144 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBService * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_145 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBCharacteristic * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_146 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_147 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_148 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_149 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, NSNumber * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_150 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheral * p0, CBDescriptor * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_151 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_152 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBCentral * p1, CBCharacteristic * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_153 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBL2CAPChannel * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_154 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, unsigned short p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_155 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBATTRequest * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_156 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_157 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, CBService * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_158 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_159 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CBPeripheralManager * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_160 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CAAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_161 (id self, SEL _cmd, MonoMethod **managed_method_ptr, CAAnimation * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_162 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVCaptureFileOutput * p0, NSURL * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_163 (id self, SEL _cmd, MonoMethod **managed_method_ptr, AVCaptureFileOutput * p0, NSURL * p1, NSArray * p2, NSError * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_164 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAlert * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_165 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_166 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, float p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_167 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static float native_to_managed_trampoline_168 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSAnimation * p0, float p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	float res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(float *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSMenu * native_to_managed_trampoline_169 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSMenu * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_170 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_171 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_172 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_173 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSUserActivity * p1, id p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		arg_ptrs [2] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x12C5316 /* AppKit.ContinueUserActivityRestorationHandler ObjCRuntime.Trampolines/NIDContinueUserActivityRestorationHandler::Create(System.IntPtr) */ , 2, p2, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_174 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSCoder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_175 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSString * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_176 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_177 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_178 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_179 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_180 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_181 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDictionary * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSUInteger native_to_managed_trampoline_182 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSArray * p1, NSDictionary * p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_183 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPasteboard * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_184 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_185 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSArray * p0, NSArray * p1, uint32_t token_ref)
{
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	if (p0) {
		NSArray *arr = (NSArray *) p0;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 0);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [0] = marr;
	} else {
		arg_ptrs [0] = NULL;
	}
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_186 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSData * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_187 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSUserActivity * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_188 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, CKShareMetadata * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSError * native_to_managed_trampoline_189 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSApplication * p0, NSError * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSError * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_190 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPasteboard * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_191 (id self, SEL _cmd, MonoMethod **managed_method_ptr, SEL p0, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = p0 ? xamarin_get_selector (p0, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_192 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSClickGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_193 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_194 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSString * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_195 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSTextView * p1, SEL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? xamarin_get_selector (p2, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_196 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_197 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSTextView * p1, NSArray * p2, NSRange p3, NSInteger* p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}
	arg_ptrs [3] = &p3;
	arg_ptrs [4] = p4;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_198 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSArray * p2, NSRange p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_199 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_200 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextField * p0, NSTextView * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_201 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSControl * p0, NSText * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_202 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDatePickerCell * p0, NSDate ** p1, double p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *mobj1 = NULL;
	NSObject *nsobj1 = NULL;
	MonoType *paramtype1 = NULL;
	void * handle1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = *(NSObject **) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr (nsobj1, false, paramtype1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = (int *) &mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (mobj1 != NULL)
	handle1 = xamarin_get_nsobject_handle (mobj1);
	if (p1 != NULL)
		*p1 = (id) handle1;

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_203 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDocument * p0, BOOL p1, void * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	void * a2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &a2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_204 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDrawer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_205 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSDrawer * p0, CGSize p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_206 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSEvent * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_207 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSGestureRecognizer * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_208 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_209 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, NSTouch * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_210 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_211 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_212 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_213 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImage * p0, NSImageRep * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSImage * native_to_managed_trampoline_214 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSImage * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_215 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMagnificationGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_216 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_217 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_218 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_219 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSViewController * native_to_managed_trampoline_220 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSViewController * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_221 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPageController * p0, NSViewController * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_222 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPanGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_223 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPathCell * p0, NSOpenPanel * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_224 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPathCell * p0, NSMenu * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_225 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSPressGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_226 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRotationGestureRecognizer * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_227 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSInteger p1, NSObject * p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	unsigned long long nativeEnum3 = p3;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &nativeEnum3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_228 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_229 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	unsigned long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_230 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRuleEditor * p0, NSObject * p1, NSObject * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_231 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, NSString * p2, BOOL p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_232 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_233 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_234 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_235 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_236 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_237 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_238 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, NSURL * p1, NSError ** p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *mobj2 = NULL;
	void * handle2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = (int *) &mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (mobj2 != NULL)
	handle2 = xamarin_get_nsobject_handle (mobj2);
	if (p2 != NULL)
		*p2 = (id) handle2;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_239 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSavePanel * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_240 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSearchField * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSView * native_to_managed_trampoline_241 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, CGRect* p1, NSUInteger* p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1;
	arg_ptrs [2] = p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_242 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_243 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_244 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, id p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "AppKit.NSPasteboardWritingWrapper, Xamarin.Mac", "AppKit.INSPasteboardWriting, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSWindow * native_to_managed_trampoline_245 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, NSArray * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSWindow * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSImage * native_to_managed_trampoline_246 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingService * p0, id p1, CGRect p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSImage * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = xamarin_get_inative_object_static (p1, false, "AppKit.NSPasteboardWritingWrapper, Xamarin.Mac", "AppKit.INSPasteboardWriting, Xamarin.Mac", &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static id native_to_managed_trampoline_247 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSSharingService * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	id res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_handle_for_inativeobject ((MonoObject *) retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_248 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSSharingService * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_249 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSharingServicePicker * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_250 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSSound * p0, BOOL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSTableRowView * native_to_managed_trampoline_251 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTableRowView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_252 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableRowView * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_253 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSCell * native_to_managed_trampoline_254 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSCell * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_255 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, NSString * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = p3 ? mono_string_new (mono_domain_get (), [p3 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGFloat native_to_managed_trampoline_256 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGFloat res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGFloat *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_257 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSIndexSet * native_to_managed_trampoline_258 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSIndexSet * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSIndexSet * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_259 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSCell * p1, CGRect* p2, NSTableColumn * p3, NSInteger p4, CGPoint p5, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [6];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = &p4;
	arg_ptrs [5] = &p5;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSView * native_to_managed_trampoline_260 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_261 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_262 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	long long nativeEnum2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &nativeEnum2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_263 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_264 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_265 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSInteger p1, NSInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_266 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSTableColumn * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_267 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSCell * p1, NSTableColumn * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_268 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSEvent * p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_269 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTableView * p0, NSObject * p1, NSTableColumn * p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_270 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, NSTabViewItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_271 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_272 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTabView * p0, NSTabViewItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_273 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSText * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_274 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextStorage * p0, NSUInteger p1, NSRange p2, NSInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_275 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, CGRect p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = &p3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_276 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, unsigned long long p2, NSDictionary * p3, NSArray * p4, NSOrthography * p5, NSInteger p6, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	NSObject *nsobj5 = NULL;
	MonoObject *mobj5 = NULL;
	int32_t created5 = false;
	MonoType *paramtype5 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [7];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	if (p4) {
		NSArray *arr = (NSArray *) p4;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 4);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj4 = NULL;
			if (nobj) {
				mobj4 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj4);
		}
		arg_ptrs [4] = marr;
	} else {
		arg_ptrs [4] = NULL;
	}
	nsobj5 = (NSObject *) p5;
	if (nsobj5) {
		paramtype5 = xamarin_get_parameter_type (managed_method, 5);
		mobj5 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj5, false, paramtype5, &created5, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [5] = mobj5;
	arg_ptrs [6] = &p6;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_277 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, SEL p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? xamarin_get_selector (p1, &exception_gchandle) : NULL;
	if (exception_gchandle != 0) goto exception_handling;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_278 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, CGRect p2, NSEvent * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSArray * native_to_managed_trampoline_279 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_280 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSRange p2, NSInteger* p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	arg_ptrs [2] = &p2;
	arg_ptrs [3] = p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_281 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUndoManager * native_to_managed_trampoline_282 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUndoManager * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_283 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_284 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSObject * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSMenu * native_to_managed_trampoline_285 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSMenu * p1, NSEvent * p2, NSUInteger p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSMenu * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_286 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSString * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = p2 ? mono_string_new (mono_domain_get (), [p2 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_287 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_288 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSDictionary * p1, NSDictionary * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_289 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_290 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSInteger p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_291 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSRange native_to_managed_trampoline_292 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSRange p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSRange res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSRange *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_293 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSArray * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	if (p1) {
		NSArray *arr = (NSArray *) p1;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 1);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj1 = NULL;
			if (nobj) {
				mobj1 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj1);
		}
		arg_ptrs [1] = marr;
	} else {
		arg_ptrs [1] = NULL;
	}
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSObject *nobj = [arr objectAtIndex: j];
			MonoObject *mobj2 = NULL;
			if (nobj) {
				mobj2 = xamarin_get_managed_object_for_ptr_fast (nobj, &exception_gchandle);
				if (exception_gchandle != 0) goto exception_handling;
			}
			mono_array_set (marr, MonoObject *, j, mobj2);
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSDictionary * native_to_managed_trampoline_294 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSRange p1, NSDictionary * p2, unsigned long long p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSDictionary * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &p3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSString * native_to_managed_trampoline_295 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSString * p1, NSUInteger p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSString * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		char *str = mono_string_to_utf8 ((MonoString *) retval);
		NSString *nsstr = [[NSString alloc] initWithUTF8String:str];
		[nsstr autorelease];
		mono_free (str);
		res = nsstr;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_296 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTextView * p0, NSTextAttachmentCell * p1, NSUInteger p2, NSPasteboard * p3, NSString * p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	arg_ptrs [4] = p4 ? mono_string_new (mono_domain_get (), [p4 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_297 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSToolbar * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			char *str = mono_string_to_utf8 ((MonoString *) value);
			NSString *sv = [[NSString alloc] initWithUTF8String:str];
			[sv autorelease];
			mono_free (str);
			buf [i] = sv;
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSToolbarItem * native_to_managed_trampoline_298 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSToolbar * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSToolbarItem * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSTouchBarItem * native_to_managed_trampoline_299 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSTouchBar * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSTouchBarItem * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSArray * native_to_managed_trampoline_300 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSArray * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (retval) {
		int length = mono_array_length ((MonoArray *) retval);
		int i;
		id *buf = (id *) malloc (sizeof (void *) * length);
		for (i = 0; i < length; i++) {
			MonoObject *value = mono_array_get ((MonoArray *) retval, MonoObject *, i);
			buf [i] = xamarin_get_nsobject_handle ((MonoObject *) value);
		}
		NSArray *arr = [[NSArray alloc] initWithObjects: buf count: length];
		free (buf);
		[arr autorelease];
		res = arr;
	} else {
		res = NULL;
	}
	xamarin_framework_peer_lock ();
	mt_dummy_use (retval);
	xamarin_framework_peer_unlock ();

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_301 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSCoder * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_302 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_303 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSEvent * p1, CGPoint p2, NSPasteboard * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_304 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSMenu * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_305 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_306 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, double p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static CGRect native_to_managed_trampoline_307 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSWindow * p1, CGRect p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_308 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGSize p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGSize native_to_managed_trampoline_309 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGSize p1, CGSize p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGSize res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;
	arg_ptrs [2] = &p2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGSize *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_310 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUndoManager * native_to_managed_trampoline_311 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUndoManager * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_312 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static CGRect native_to_managed_trampoline_313 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSWindow * p0, CGRect p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	CGRect res = {{0}};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(CGRect *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_314 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSUInteger native_to_managed_trampoline_315 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSUInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSUInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSInteger native_to_managed_trampoline_316 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void * p0, NSUInteger p1, uint32_t token_ref)
{
	void * a0 = p0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSInteger res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = &p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(NSInteger *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_317 (id self, SEL _cmd, MonoMethod **managed_method_ptr, void ** p0, NSUInteger* p1, uint32_t token_ref)
{
	void ** a0 = 0;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &a0;
	arg_ptrs [1] = p1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	*p0 = a0;

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_318 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_319 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static BOOL native_to_managed_trampoline_320 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUInteger p0, void * p1, void * p2, uint32_t token_ref)
{
	unsigned long long nativeEnum0 = p0;
	void * a1 = p1;
	void * a2 = p2;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	arg_ptrs [0] = &nativeEnum0;
	arg_ptrs [1] = &a1;
	arg_ptrs [2] = &a2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_321 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSRunLoop * p0, NSString * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_322 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSCache * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_323 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_324 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_325 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_326 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedArchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static Class native_to_managed_trampoline_327 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSString * p1, NSArray * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	Class res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	if (p2) {
		NSArray *arr = (NSArray *) p2;
		MonoClass *e_class;
		MonoArray *marr;
		MonoType *p;
		int j;
		p = xamarin_get_parameter_type (managed_method, 2);
		e_class = mono_class_get_element_class (mono_class_from_mono_type (p));
		marr = mono_array_new (mono_domain_get (), e_class, [arr count]);
		for (j = 0; j < [arr count]; j++) {
			NSString *sv = (NSString *) [arr objectAtIndex: j];
			mono_array_set (marr, MonoString *, j, mono_string_new (mono_domain_get (), [sv UTF8String]));
		}
		arg_ptrs [2] = marr;
	} else {
		arg_ptrs [2] = NULL;
	}

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		res = (Class) xamarin_get_handle_for_inativeobject (retval, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_328 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSObject * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_329 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_330 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSKeyedUnarchiver * p0, NSObject * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_331 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMetadataQuery * p0, NSMetadataItem * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static NSObject * native_to_managed_trampoline_332 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSMetadataQuery * p0, NSString * p1, NSObject * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_333 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_334 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSInputStream * p1, NSOutputStream * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_335 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_336 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetService * p0, NSData * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_337 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSString * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = p1 ? mono_string_new (mono_domain_get (), [p1 UTF8String]) : NULL;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_338 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSNetService * p1, BOOL p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	arg_ptrs [2] = &p2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_339 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, NSDictionary * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_340 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSNetServiceBrowser * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_341 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSObject * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, NULL, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_342 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSString * p0, NSObject * p1, NSDictionary * p2, void * p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	void * a3 = p3;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	arg_ptrs [3] = &a3;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_343 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSStream * p0, NSUInteger p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	unsigned long long nativeEnum1 = p1;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	arg_ptrs [1] = &nativeEnum1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_344 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUserNotificationCenter * p0, NSUserNotification * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static BOOL native_to_managed_trampoline_345 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSUserNotificationCenter * p0, NSUserNotification * p1, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	BOOL res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [2];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;

	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	res = *(BOOL *) mono_object_unbox ((MonoObject *) retval);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_346 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSURLResponse * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x1350916 /* System.Action`1<Foundation.NSUrlSessionResponseDisposition> ObjCRuntime.Trampolines/NIDActionArity1V35::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_347 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSData * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_348 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSError * p2, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [3];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_349 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionDataTask * p1, NSCachedURLResponse * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x1346916 /* System.Action`1<Foundation.NSCachedUrlResponse> ObjCRuntime.Trampolines/NIDActionArity1V32::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_350 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSHTTPURLResponse * p2, NSURLRequest * p3, id p4, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	NSObject *nsobj3 = NULL;
	MonoObject *mobj3 = NULL;
	int32_t created3 = false;
	MonoType *paramtype3 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [5];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	nsobj3 = (NSObject *) p3;
	if (nsobj3) {
		paramtype3 = xamarin_get_parameter_type (managed_method, 3);
		mobj3 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj3, false, paramtype3, &created3, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [3] = mobj3;
	if (p4) {
		arg_ptrs [4] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x134FF16 /* System.Action`1<Foundation.NSUrlRequest> ObjCRuntime.Trampolines/NIDActionArity1V37::Create(System.IntPtr) */ , 4, p4, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [4] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static void native_to_managed_trampoline_351 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSURLSession * p0, NSURLSessionTask * p1, NSURLAuthenticationChallenge * p2, id p3, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	NSObject *nsobj1 = NULL;
	MonoObject *mobj1 = NULL;
	int32_t created1 = false;
	MonoType *paramtype1 = NULL;
	NSObject *nsobj2 = NULL;
	MonoObject *mobj2 = NULL;
	int32_t created2 = false;
	MonoType *paramtype2 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [4];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;
	nsobj1 = (NSObject *) p1;
	if (nsobj1) {
		paramtype1 = xamarin_get_parameter_type (managed_method, 1);
		mobj1 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj1, false, paramtype1, &created1, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [1] = mobj1;
	nsobj2 = (NSObject *) p2;
	if (nsobj2) {
		paramtype2 = xamarin_get_parameter_type (managed_method, 2);
		mobj2 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj2, false, paramtype2, &created2, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [2] = mobj2;
	if (p3) {
		arg_ptrs [3] = (void *) xamarin_get_delegate_for_block_parameter (managed_method, 0x1388316 /* System.Action`2<Foundation.NSUrlSessionAuthChallengeDisposition,Foundation.NSUrlCredential> ObjCRuntime.Trampolines/NIDActionArity2V37::Create(System.IntPtr) */ , 3, p3, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	} else {
		arg_ptrs [3] = NULL;
	}

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSImageView * native_to_managed_trampoline_352 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSImageView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_353 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSImageView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSView * native_to_managed_trampoline_354 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSView * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}


static void native_to_managed_trampoline_355 (id self, SEL _cmd, MonoMethod **managed_method_ptr, NSView * p0, uint32_t token_ref)
{
	NSObject *nsobj0 = NULL;
	MonoObject *mobj0 = NULL;
	int32_t created0 = false;
	MonoType *paramtype0 = NULL;
	guint32 exception_gchandle = 0;
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [1];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	nsobj0 = (NSObject *) p0;
	if (nsobj0) {
		paramtype0 = xamarin_get_parameter_type (managed_method, 0);
		mobj0 = xamarin_get_nsobject_with_type_for_ptr_created (nsobj0, false, paramtype0, &created0, _cmd, managed_method, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	arg_ptrs [0] = mobj0;

	mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return;
}


static NSObject * native_to_managed_trampoline_356 (id self, SEL _cmd, MonoMethod **managed_method_ptr, uint32_t token_ref)
{
	MonoObject *retval = NULL;
	guint32 exception_gchandle = 0;
	NSObject * res = {0};
	MonoMethod *managed_method = *managed_method_ptr;
	void *arg_ptrs [0];
	MONO_ASSERT_GC_SAFE;
	MONO_THREAD_ATTACH;

	MonoObject *mthis = NULL;
	if (self) {
		mthis = xamarin_get_managed_object_for_ptr_fast (self, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
	}
	if (!managed_method) {
		MonoReflectionMethod *reflection_method = xamarin_get_method_from_token (token_ref, &exception_gchandle);
		if (exception_gchandle != 0) goto exception_handling;
		managed_method = xamarin_get_reflection_method_method (reflection_method);
		*managed_method_ptr = managed_method;
	}
	xamarin_check_for_gced_object (mthis, _cmd, self, managed_method, &exception_gchandle);
	if (exception_gchandle != 0) goto exception_handling;
	retval = mono_runtime_invoke (managed_method, mthis, arg_ptrs, NULL);

	if (!retval) {
		res = NULL;
	} else {
		id retobj;
		retobj = xamarin_get_nsobject_handle (retval);
		xamarin_framework_peer_lock ();
		[retobj retain];
		xamarin_framework_peer_unlock ();
		[retobj autorelease];
		mt_dummy_use (retval);
		res = retobj;
	}

exception_handling:;
	MONO_THREAD_DETACH;
	if (exception_gchandle != 0)
		xamarin_process_managed_exception_gchandle (exception_gchandle);
	return res;
}




#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation VSAccountManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCF016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation UNUserNotificationCenterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE4616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation DOMEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFF816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation DOMEventTarget {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x100416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__WebKit_DomNodeFilter {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x141716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebDocumentRepresentation {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14EA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x14FB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebFrameLoadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x152A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__WebKit_WebOpenPanelResultListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x157116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__WebKit_WebPolicyDecisionListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x157B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebPolicyDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x158616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebResourceLoadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x15EC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WebUIDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x163116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKNavigationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x18A016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKScriptMessageHandler {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x18E316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation WKUIDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x18FF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKPaymentTransactionObserver {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1C7F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKRequestDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1CEF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKProductsRequestDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1CBA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKPhysicsContactDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1F9516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKSceneDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x207D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x229216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SBApplicationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x27C916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNActionable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x283B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNAnimatable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x285E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNAvoidOccluderConstraintDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x28FF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNBoundingVolume {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x291416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNCameraControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x29F316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNNodeRendererDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2D2916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNPhysicsContactDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2E6516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNProgramDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x2F7B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneExportDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x304116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneRenderer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x30AA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNSceneRendererDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x30E516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNShadable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x312916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation SCNTechniqueSupport {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x319E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewItem {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x345216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewPanelDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x348016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation QLPreviewPanelDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x348916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHLivePhotoViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x385916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHProjectTypeDescriptionDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x38F416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PHPhotoLibraryChangeObserver {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x3A2E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PDFDocumentDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4E7516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation PDFViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4F9316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetListViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4FE616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetProviding {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x4FF616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NCWidgetSearchViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x502716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NWTCPConnectionAuthenticationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x52AF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCAdvertiserAssistantDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x555B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCBrowserViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x557C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCNearbyServiceAdvertiserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x559616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCNearbyServiceBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x55B016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MCSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x55E916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MDLLightProbeIrradianceDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x576C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MPSCNNConvolutionDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x5C3C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MTKViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x635216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__Metal_MTLCaptureScope {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x643A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MTLDrawable {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x655B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKAnnotation {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6ACF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKLocalSearchCompleterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6B9216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKMapViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6CC416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation MKOverlay {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6CEB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__JavaScriptCore_JSExport {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x6E6816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKCameraDeviceViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x726016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKDeviceBrowserViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x728516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKFilterCustomUIProvider {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x72AA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageBrowserDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x72E016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x72F516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageBrowserItem {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x730716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKImageEditPanelDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x739B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKSaveOptionsDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x741916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKScannerDeviceViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x745B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation IKSlideshowDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x748916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GLKNamedEffect {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x78B616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKAgentDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x797316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKAchievementViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7CD616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengeEventHandlerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D1716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengeListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D2616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKChallengesViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D3A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKFriendRequestComposeViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D6A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKGameCenterControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7D7116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKInviteEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7DCF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKLeaderboardViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E2316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKLocalPlayerListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7E5916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKMatchDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7EC616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKMatchmakerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F3216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKSavedGameListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7F8016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7FD216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedEventHandlerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7FEA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedEventListener {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x7FFA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation GKTurnBasedMatchmakerViewControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x807816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation EAAccessoryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x821016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CWEventDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x837716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CSSearchableIndexDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x899F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation Xamarin_Mac__CoreML_MLCustomModel {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x8C2B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithModelDescription:(MLModelDescription *)p0 parameterDictionary:(NSDictionary <NSString *, NSObject *>*)p1 error:(NSError **)p2
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_2 (self, _cmd, &managed_method, p0, p1, p2, &call_super, 0x8C2E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, MLModelDescription *, NSDictionary <NSString *, NSObject *>*, NSError **)) objc_msgSendSuper) (&super, @selector (initWithModelDescription:parameterDictionary:error:), p0, p1, p2);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CLLocationManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x91E116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation CoreImage_CIAccordionFoldTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x922716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x922A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICompositingFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x941E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAdditionCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x923516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x923816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x923F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineClamp {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x923916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x923C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x924116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x924416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAffineTransform {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x924516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x924816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAffineFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaAverage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x924916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x924C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaHistogram {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x924F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x925216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIReductionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A5816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x925916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x925C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMaximumAlpha {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x925E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x926116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x926216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x926516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinimumAlpha {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x926616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x926916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinMax {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x926A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x926D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAreaMinMaxRed {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x926E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x927116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIAreaMaximum class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIImageGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x97B216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAttributedTextImageGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x927416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x927716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x936816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIAztecCodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x928616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x928916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarcodeGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x929816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x929B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITransitionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BCF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBarsSwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x929E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92A116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBicubicScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92A816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92AB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92B616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92F116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92F416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithAlphaMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92E916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92EC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithBlueMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92ED16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92F016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBlendWithRedMask {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92F816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92FB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendWithMask class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x92FC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x92FF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x985416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBokehBlur {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x930416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x930716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBoxBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x930E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x931116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDistortionFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x953116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x931416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x931716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIBumpDistortionLinear {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x931A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x931D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICameraCalibrationLensCorrection {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x932216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x932516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICheckerboardGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x932A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x932D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircleSplashDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x933816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x933B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9ABE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x933C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x933F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICircularWrap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x934016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x934316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x934A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x934D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICmykHalftone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x935016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x935316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICode128BarcodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x936016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x936316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x939216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x939516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x939616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x939916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorClamp {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x939A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x939D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorControls {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93A216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93A516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCrossPolynomial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93AC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93AF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCube {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93B716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93BA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubesMixedWithMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93C016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93C316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCubeWithColorSpace {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93CE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93D116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCube class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorCurves {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93D416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93D716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93DE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93E116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorInvert {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93E216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93E516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMap {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93EC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93EF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMatrix {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x93F216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x93F516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorMonochrome {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x940016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x940316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPolynomial {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x940816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x940B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIColorCrossPolynomial class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColorPosterize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x940E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x941116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIColumnAverage {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x941416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x941716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIReductionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIComicEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x941816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x941B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConstantColorGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x942216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x942516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolutionCore {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x948116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution3X3 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x946B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x946E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution5X5 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x946F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x947216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution7X7 {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x947316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x947616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Horizontal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x947716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x947A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIConvolution9Vertical {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x947B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x947E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIConvolutionCore class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICopyMachineTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x948716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x948A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICoreMLModelFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x949516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x949816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x949B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x949E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICrystallize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94A116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94A416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDarkenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94A916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94AC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthBlurEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94B916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94BC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthDisparityConverter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94D316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthOfField {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94D516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94D816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDepthToDisparity {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x94E516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x94E816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDifferenceBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x950916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x950C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDiscBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x950D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x951016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisintegrateWithMaskTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x951316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x951616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisparityToDepth {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x951F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x952216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDepthDisparityConverter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDisplacementDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x952316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x952616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDissolveTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x952B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x952E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDither {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x953716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x953A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDivideBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x953D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x954016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDotScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x954116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x954416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIDroste {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x954716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x954A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgePreserveUpsampleFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x955716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x955A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdges {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x956116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x956416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEdgeWork {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x956716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x956A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITileFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BAB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIEightfoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x956D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x957016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExclusionBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x957116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x957416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIExposureAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x957516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x957816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFaceBalance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x957D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFalseColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x959216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x959516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFlashTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x966316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x966616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x967516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x967816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldRotatedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x967B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x967E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIFourfoldTranslatedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x967F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x968216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGammaAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x968516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x968816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x968B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x968E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGaussianGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x969116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x969416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x969D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96A016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlassLozenge {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96A716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96AA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGlideReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96B316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96B616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGloom {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96B716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96BA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIGuidedFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96BF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96C216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHardLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96C916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96CC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHatchedScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96CD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96D016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHeightFieldFromMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96D316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96D616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHexagonalPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96D916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96DC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHighlightShadowAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96E116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96E416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHistogramDisplayFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96EB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96EE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHoleDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96F516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96F816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96F916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x96FC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x96FF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x970216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIHueSaturationValueGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x970316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x970616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end


@implementation CoreImage_CIKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x980D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x981016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILabDeltaE {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x982216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x982516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILanczosScaleTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x982816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x982B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILenticularHaloGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x983016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x983316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x984416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x984716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILightTunnel {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x984816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x984B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearBurnBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x985816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x985B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearDodgeBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x985C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x985F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x986016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x986316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILinearToSRGBToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x986D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x987016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineOverlay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x987116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x987416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILineScreen {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x987F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x988216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIScreenFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CILuminosityBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x988516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x988816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskedVariableBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x988916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x988C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaskToAlpha {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x988F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x989216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x989316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x989616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMaximumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x989716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x989A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMedianFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x989B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x989E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMeshGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x989F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98A216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumComponent {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98A916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98AC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMinimumCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98AD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98B016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMix {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98B116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98B416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIModTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98B916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98BC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphology {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98C716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyGradient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98CB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98CE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMaximum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98CF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98D216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMorphologyMinimum {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98D316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98D616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIMorphology class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMotionBlur {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98D716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98DA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearBlur class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98DD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98E016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIMultiplyCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98E116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98E416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartStretched {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98E516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98E816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINinePartTiled {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98EF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98F216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CINoiseReduction {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x98FB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x98FE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOpTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x990316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x990616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIOverlayBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x990916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x990C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x990D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x991016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPageCurlWithShadowTransition {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x991B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x991E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIParallelogramTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x993116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x993416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPdf417BarcodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x993716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x993A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransform {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x996D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x997016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveCorrection {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x995D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x996016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTile {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x996116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x996416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPerspectiveTransformWithExtent {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x997A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x997D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPerspectiveTransform class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x998216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectChrome {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x998416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x998716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectFade {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x998816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x998B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectInstant {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x998C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x998F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectMono {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x999016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x999316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectNoir {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x999416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x999716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectProcess {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x999816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x999B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTonal {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x999C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x999F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPhotoEffectTransfer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99A016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99A316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIPhotoEffect class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinchDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99A416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99A716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPinLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99AA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99AD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPixellate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99AE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99B116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIPointillize {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99BE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99C116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIQRCodeGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99E116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99E416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICodeGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRadialGradient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99E716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99EA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRandomGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x99F516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x99F816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRippleTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9A8216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A8516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIRowAverage {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9A9016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A9316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISaliencyMapFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9A9616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A9916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISampleNearest {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9A9A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9A9D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISaturationBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AB416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AB716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIScreenBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AB816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9ABB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISepiaTone {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AC616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AC916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIShadedMaterial {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9ACC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9ACF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISharpenLuminance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AD416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AD716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9ADA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9ADD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISixfoldRotatedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9ADE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AE116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISmoothLinearGradient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AE216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AE516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CILinearGradient class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISoftLightBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AEE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AF116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceAtopCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AF216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AF516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceInCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AF616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AF916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOutCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AFA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9AFD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISourceOverCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9AFE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B0116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICompositingFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotColor {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B0216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B0516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISpotLight {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B1E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B2116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISRGBToneCurveToLinear {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B2C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B2F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStarShineGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B3016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B3316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStraightenFilter {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B4416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B4716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStretchCrop {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B4A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B4D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIStripesGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B5416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B5716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISubtractBlendMode {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B6216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B6516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIBlendFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISunbeamsGenerator {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B6616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B6916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CISwipeTransition {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B7A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B7D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITransitionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITemperatureAndTint {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B8816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B8B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITextImageGenerator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9B9B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9B9E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIImageGenerator class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIThermal {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BA516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BA816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIToneCurve {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BB316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BB616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITorusLensDistortion {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BC116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BC416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleKaleidoscope {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BD516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BD816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITriangleTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BE116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BE416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwelvefoldReflectedTile {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BE516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BE816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CITileFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CITwirlDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BE916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BEC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIUnsharpMask {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9BF316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9BF616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVibrance {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C1F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C2216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignette {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C2516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C2816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVignetteEffect {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C2D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C3016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIVortexDistortion {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C3916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C3C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CIDistortionFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIWhitePointAdjust {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C4516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C4816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIXRay {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C4B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C4E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CIZoomBlur {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C4F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x9C5216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CIFilter class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end

@implementation CoreImage_CICMYKHalftone {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x9C8516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [CoreImage_CICmykHalftone class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBCentralManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xA9E416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBPeripheralDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAAAC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CBPeripheralManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAB2016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CAAnimationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAC0E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CALayerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAE1716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CAMediaTiming {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAE4216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CNContactPickerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xAFE916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation CKRecordValue {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB4D816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB5EA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAssetResourceLoaderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB72216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAsynchronousKeyValueLoading {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB83716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudio3DMixing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xB86316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioPlayerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBA3C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioRecorderDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBAA016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVAudioStereoMixing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBADD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureAudioDataOutputSampleBufferDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBBFE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureFileOutputDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBCB216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureFileOutputRecordingDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBCBE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVCaptureVideoDataOutputSampleBufferDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBD5D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVContentKeySessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xBDFA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC35616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemLegibleOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC31616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemMetadataCollectorPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC32B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemMetadataOutputPushDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC33E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVPlayerItemOutputPullDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC34F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation AVVideoCompositing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC4E316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@implementation AVFoundation_AVCaptureDataOutputSynchronizer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@implementation AVFoundation_AVCaptureDataOutputSynchronizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC58116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AVFoundation_InternalAVAudioPlayerDelegate : NSObject<AVAudioPlayerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1;
	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioPlayerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) audioPlayerDidFinishPlaying:(AVAudioPlayer *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_5 (self, _cmd, &managed_method, p0, p1, 0xC58C16);
	}

	-(void) audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_6 (self, _cmd, &managed_method, p0, p1, 0xC58D16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC58B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AVFoundation_InternalAVAudioRecorderDelegate : NSObject<AVAudioRecorderDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1;
	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AVFoundation_InternalAVAudioRecorderDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) audioRecorderDidFinishRecording:(AVAudioRecorder *)p0 successfully:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_7 (self, _cmd, &managed_method, p0, p1, 0xC58F16);
	}

	-(void) audioRecorderEncodeErrorDidOccur:(AVAudioRecorder *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_8 (self, _cmd, &managed_method, p0, p1, 0xC59016);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xC58E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAccessibilityCustomRotorItemSearchDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCBAF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAlertDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCE2F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAlignmentFeedbackToken {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCE4016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAnimationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCE9516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSAppearanceCustomization {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xCEB816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSApplicationDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD12516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD30516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCandidateListTouchBarItemDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD3DD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSharingServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF25316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCloudSharingServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD60216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD68116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD6A616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewDelegateFlowLayout {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD6CD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCollectionViewElement {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD6F916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSComboBoxCellDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD98A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSComboBoxDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD99616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFB8016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSComboBoxDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xD9A216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSControlTextEditingDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDA1F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDatePickerCellDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDADC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDockTilePlugIn {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDB1116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDraggingDestination {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDBFF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDraggingSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDC6C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSDrawerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xDDE616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSGestureRecognizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE01716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSHapticFeedbackPerformer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE0FB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSImageDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE19F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSLayoutManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE35E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMatrixDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE43D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMenuDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE5D816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSOpenSavePanelDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE8C416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSOutlineViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE93216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSOutlineViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE96A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPageControllerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xE9CF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPasteboardItemDataProvider {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEA9E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPasteboardReading {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEAA616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPasteboardWriting {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEAB416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPathCellDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEAF216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPathControlDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEB3016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPopoverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xECAD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPrintPanelAccessorizing {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEE0D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSRuleEditorDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xEEF416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSScrubberDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF0A516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSScrubberDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF0B116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSScrubberFlowLayoutDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF0C716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSearchFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF16A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSeguePerforming {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF1FD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSharingServicePickerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF29216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSharingServicePickerTouchBarItemDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF2AA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSoundDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF4B116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSpeechRecognizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF4CB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSpeechSynthesizerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF4F916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSplitViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF5A616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSSpringLoadingDestination {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF5E116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSStackViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF61B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTableViewDataSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF8D916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTableViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF90616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTableViewSource {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF93416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTabViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xF9C316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextAttachmentContainer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFA8016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFAE716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextFinderBarContainer {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFBB016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextFinderClient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFBDC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextInputClient {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFC1916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextStorageDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFC9716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTextViewDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFE4816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTokenFieldCellDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFEB016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTokenFieldDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFEC816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSToolbarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFF1D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop


#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSTouchBarDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0xFF8E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSViewControllerPresentationAnimator {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x103A616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSWindowDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1072616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSWindowRestoration {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1075A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface __monomac_internal_ActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) __monomac_internal_ActionDispatcher_activated:(NSObject *)p0;
	-(void) __monomac_internal_ActionDispatcher_doubleActivated:(NSObject *)p0;
	-(BOOL) validateMenuItem:(NSMenuItem *)p0;
	-(BOOL) worksWhenModal;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation __monomac_internal_ActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) __monomac_internal_ActionDispatcher_activated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x10A3616);
	}

	-(void) __monomac_internal_ActionDispatcher_doubleActivated:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x10A3716);
	}

	-(BOOL) validateMenuItem:(NSMenuItem *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_10 (self, _cmd, &managed_method, p0, 0x10A3E16);
	}

	-(BOOL) worksWhenModal
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_11 (self, _cmd, &managed_method, 0x10A3F16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10A3916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSAlertDidEndDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) alertDidEnd:(NSAlert *)p0 returnCode:(NSInteger)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __MonoMac_NSAlertDidEndDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) alertDidEnd:(NSAlert *)p0 returnCode:(NSInteger)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_12 (self, _cmd, &managed_method, p0, p1, p2, 0x10A4916);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCacheDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10E2A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCoding {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10F0C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}

	-(id) initWithCoder:(NSCoder *)p0
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_4 (self, _cmd, &managed_method, p0, &call_super, 0x10F0F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL, NSCoder *)) objc_msgSendSuper) (&super, @selector (initWithCoder:), p0);
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSConnectionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10F8216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSCopying {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x10F8E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSExtensionRequestHandling {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1121F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFileManagerDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x112EC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSFilePresenter {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1131116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSKeyedArchiverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x114DB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSKeyedUnarchiverDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1151116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSPortDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x11C6116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMachPortDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1160D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMetadataQueryDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x117F316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSMutableCopying {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1185316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSNetServiceBrowserDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x119B616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSNetServiceDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x119CA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSStreamDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x11E4416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLAuthenticationChallengeSender {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1225B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x122E516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDataDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x122D416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLConnectionDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x122F316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUrlDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1234116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1247416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionTaskDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x124D216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDataDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1246316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionDownloadDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1247F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSURLSessionStreamDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1249116);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUserActivityDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1254516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wprotocol"
#pragma clang diagnostic ignored "-Wobjc-protocol-property-synthesis"
#pragma clang diagnostic ignored "-Wobjc-property-implementation"
@implementation NSUserNotificationCenterDelegate {
}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x125DC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end
#pragma clang diagnostic pop

@interface Foundation_InternalNSNotificationHandler : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) post:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_InternalNSNotificationHandler {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) post:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x127EB16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@implementation Foundation_NSUrlProtocolClient {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@interface Foundation_NSDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinApplySelector;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x1289C16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1289B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSActionDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSActionDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x1289F16);
	}
@end

@interface __MonoMac_NSSynchronizationContextDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSSynchronizationContextDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x128A116);
	}
@end

@interface __Xamarin_NSTimerActionDispatcher : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarinFireSelector:(NSTimer *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __Xamarin_NSTimerActionDispatcher {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarinFireSelector:(NSTimer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_15 (self, _cmd, &managed_method, p0, 0x128A316);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@interface Foundation_NSAsyncDispatcher : Foundation_NSDispatcher {
}
	-(void) xamarinApplySelector;
	-(id) init;
@end

@implementation Foundation_NSAsyncDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x128A616);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x128A516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [Foundation_NSDispatcher class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __MonoMac_NSAsyncActionDispatcher : Foundation_NSAsyncDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSAsyncActionDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x128A816);
	}
@end

@interface __MonoMac_NSAsyncSynchronizationContextDispatcher : Foundation_NSAsyncDispatcher {
}
	-(void) xamarinApplySelector;
@end

@implementation __MonoMac_NSAsyncSynchronizationContextDispatcher {
}

	-(void) xamarinApplySelector
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x128AA16);
	}
@end

@interface WebKit_DomNode_DomNodeEventProxy : NSObject<DOMEventListener> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) handleEvent:(DOMEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation WebKit_DomNode_DomNodeEventProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) handleEvent:(DOMEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, 0x12A5116);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@interface WebKit_DomNode_DomNodeEventProxy2 : NSObject<DOMEventListener> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) handleEvent:(DOMEvent *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation WebKit_DomNode_DomNodeEventProxy2 {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) handleEvent:(DOMEvent *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_16 (self, _cmd, &managed_method, p0, 0x12A5316);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@interface WebKit_WebView__WebFrameLoadDelegate : NSObject<WebFrameLoadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 didCancelClientRedirectForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didChangeLocationWithinPageForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didClearWindowObject:(WebScriptObject *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didCommitLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didCreateJavaScriptContext:(JSContext *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFailProvisionalLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didReceiveIcon:(NSImage *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didReceiveServerRedirectForProvisionalLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 didReceiveTitle:(NSString *)p1 forFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 didStartProvisionalLoadForFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 willCloseFrame:(WebFrame *)p1;
	-(void) webView:(WebView *)p0 willPerformClientRedirectToURL:(NSURL *)p1 delay:(double)p2 fireDate:(NSDate *)p3 forFrame:(WebFrame *)p4;
	-(void) webView:(WebView *)p0 windowScriptObjectAvailable:(WebScriptObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebFrameLoadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 didCancelClientRedirectForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A5716);
	}

	-(void) webView:(WebView *)p0 didChangeLocationWithinPageForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A5816);
	}

	-(void) webView:(WebView *)p0 didClearWindowObject:(WebScriptObject *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_18 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5916);
	}

	-(void) webView:(WebView *)p0 didCommitLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A5A16);
	}

	-(void) webView:(WebView *)p0 didCreateJavaScriptContext:(JSContext *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_19 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5B16);
	}

	-(void) webView:(WebView *)p0 didFailLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5C16);
	}

	-(void) webView:(WebView *)p0 didFailProvisionalLoadWithError:(NSError *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5D16);
	}

	-(void) webView:(WebView *)p0 didFinishLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A5E16);
	}

	-(void) webView:(WebView *)p0 didReceiveIcon:(NSImage *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_21 (self, _cmd, &managed_method, p0, p1, p2, 0x12A5F16);
	}

	-(void) webView:(WebView *)p0 didReceiveServerRedirectForProvisionalLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A6016);
	}

	-(void) webView:(WebView *)p0 didReceiveTitle:(NSString *)p1 forFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, p2, 0x12A6116);
	}

	-(void) webView:(WebView *)p0 didStartProvisionalLoadForFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A6216);
	}

	-(void) webView:(WebView *)p0 willCloseFrame:(WebFrame *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_17 (self, _cmd, &managed_method, p0, p1, 0x12A6316);
	}

	-(void) webView:(WebView *)p0 willPerformClientRedirectToURL:(NSURL *)p1 delay:(double)p2 fireDate:(NSDate *)p3 forFrame:(WebFrame *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_23 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12A6416);
	}

	-(void) webView:(WebView *)p0 windowScriptObjectAvailable:(WebScriptObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_24 (self, _cmd, &managed_method, p0, p1, 0x12A6516);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A5616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebDownloadDelegate : NSObject<WebDownloadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSWindow *) downloadWindowForAuthenticationSheet:(WebDownload *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebDownloadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSWindow *) downloadWindowForAuthenticationSheet:(WebDownload *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_25 (self, _cmd, &managed_method, p0, 0x12A6716);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A6616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebResourceLoadDelegate : NSObject<WebResourceLoadDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFailLoadingWithError:(NSError *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFinishLoadingFromDataSource:(WebDataSource *)p2;
	-(NSObject *) webView:(WebView *)p0 identifierForInitialRequest:(NSURLRequest *)p1 fromDataSource:(WebDataSource *)p2;
	-(void) webView:(WebView *)p0 plugInFailedWithError:(NSError *)p1 dataSource:(WebDataSource *)p2;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveContentLength:(NSInteger)p2 fromDataSource:(WebDataSource *)p3;
	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveResponse:(NSURLResponse *)p2 fromDataSource:(WebDataSource *)p3;
	-(NSURLRequest *) webView:(WebView *)p0 resource:(NSObject *)p1 willSendRequest:(NSURLRequest *)p2 redirectResponse:(NSURLResponse *)p3 fromDataSource:(WebDataSource *)p4;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebResourceLoadDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_26 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A6916);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFailLoadingWithError:(NSError *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_27 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A6A16);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didFinishLoadingFromDataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_28 (self, _cmd, &managed_method, p0, p1, p2, 0x12A6B16);
	}

	-(NSObject *) webView:(WebView *)p0 identifierForInitialRequest:(NSURLRequest *)p1 fromDataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_29 (self, _cmd, &managed_method, p0, p1, p2, 0x12A6C16);
	}

	-(void) webView:(WebView *)p0 plugInFailedWithError:(NSError *)p1 dataSource:(WebDataSource *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_30 (self, _cmd, &managed_method, p0, p1, p2, 0x12A6D16);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_26 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A6E16);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveContentLength:(NSInteger)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_31 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A6F16);
	}

	-(void) webView:(WebView *)p0 resource:(NSObject *)p1 didReceiveResponse:(NSURLResponse *)p2 fromDataSource:(WebDataSource *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_32 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A7016);
	}

	-(NSURLRequest *) webView:(WebView *)p0 resource:(NSObject *)p1 willSendRequest:(NSURLRequest *)p2 redirectResponse:(NSURLResponse *)p3 fromDataSource:(WebDataSource *)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_33 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12A7116);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A6816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebUIDelegate : NSObject<WebUIDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) webViewAreToolbarsVisible:(WebView *)p0;
	-(void) webViewClose:(WebView *)p0;
	-(WebView *) webView:(WebView *)p0 createWebViewModalDialogWithRequest:(NSURLRequest *)p1;
	-(WebView *) webView:(WebView *)p0 createWebViewWithRequest:(NSURLRequest *)p1;
	-(NSUInteger) webView:(WebView *)p0 dragSourceActionMaskForPoint:(CGPoint)p1;
	-(void) webView:(WebView *)p0 drawFooterInRect:(CGRect)p1;
	-(void) webView:(WebView *)p0 drawHeaderInRect:(CGRect)p1;
	-(void) webViewFocus:(WebView *)p0;
	-(CGRect) webViewContentRect:(WebView *)p0;
	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2;
	-(NSUInteger) webView:(WebView *)p0 dragDestinationActionMaskForDraggingInfo:(id<NSDraggingInfo>)p1;
	-(NSResponder *) webViewFirstResponder:(WebView *)p0;
	-(float) webViewFooterHeight:(WebView *)p0;
	-(CGRect) webViewFrame:(WebView *)p0;
	-(float) webViewHeaderHeight:(WebView *)p0;
	-(NSString *) webViewStatusText:(WebView *)p0;
	-(BOOL) webViewIsResizable:(WebView *)p0;
	-(BOOL) webViewIsStatusBarVisible:(WebView *)p0;
	-(void) webView:(WebView *)p0 makeFirstResponder:(NSResponder *)p1;
	-(void) webView:(WebView *)p0 mouseDidMoveOverElement:(NSDictionary *)p1 modifierFlags:(NSUInteger)p2;
	-(void) webView:(WebView *)p0 printFrameView:(WebFrameView *)p1;
	-(BOOL) webView:(WebView *)p0 runBeforeUnloadConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1;
	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1;
	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2;
	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2;
	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WebFrame *)p3;
	-(void) webViewRunModal:(WebView *)p0;
	-(void) webView:(WebView *)p0 runOpenPanelForFileButtonWithResultListener:(id)p1;
	-(void) webView:(WebView *)p0 setContentRect:(CGRect)p1;
	-(void) webView:(WebView *)p0 setFrame:(CGRect)p1;
	-(void) webView:(WebView *)p0 setResizable:(BOOL)p1;
	-(void) webView:(WebView *)p0 setStatusBarVisible:(BOOL)p1;
	-(void) webView:(WebView *)p0 setStatusText:(NSString *)p1;
	-(void) webView:(WebView *)p0 setToolbarsVisible:(BOOL)p1;
	-(BOOL) webView:(WebView *)p0 shouldPerformAction:(SEL)p1 fromSender:(NSObject *)p2;
	-(void) webViewShow:(WebView *)p0;
	-(void) webViewUnfocus:(WebView *)p0;
	-(BOOL) webView:(WebView *)p0 validateUserInterfaceItem:(NSObject *)p1 defaultValidation:(BOOL)p2;
	-(void) webView:(WebView *)p0 willPerformDragDestinationAction:(unsigned long long)p1 forDraggingInfo:(id<NSDraggingInfo>)p2;
	-(void) webView:(WebView *)p0 willPerformDragSourceAction:(unsigned long long)p1 fromPoint:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebUIDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) webViewAreToolbarsVisible:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x12A7316);
	}

	-(void) webViewClose:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A7416);
	}

	-(WebView *) webView:(WebView *)p0 createWebViewModalDialogWithRequest:(NSURLRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_36 (self, _cmd, &managed_method, p0, p1, 0x12A7516);
	}

	-(WebView *) webView:(WebView *)p0 createWebViewWithRequest:(NSURLRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_36 (self, _cmd, &managed_method, p0, p1, 0x12A7616);
	}

	-(NSUInteger) webView:(WebView *)p0 dragSourceActionMaskForPoint:(CGPoint)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_37 (self, _cmd, &managed_method, p0, p1, 0x12A7716);
	}

	-(void) webView:(WebView *)p0 drawFooterInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, p1, 0x12A7816);
	}

	-(void) webView:(WebView *)p0 drawHeaderInRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, p1, 0x12A7916);
	}

	-(void) webViewFocus:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A7A16);
	}

	-(CGRect) webViewContentRect:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_39 (self, _cmd, &managed_method, p0, 0x12A7B16);
	}

	-(NSArray *) webView:(WebView *)p0 contextMenuItemsForElement:(NSDictionary *)p1 defaultMenuItems:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_40 (self, _cmd, &managed_method, p0, p1, p2, 0x12A7C16);
	}

	-(NSUInteger) webView:(WebView *)p0 dragDestinationActionMaskForDraggingInfo:(id<NSDraggingInfo>)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_41 (self, _cmd, &managed_method, p0, p1, 0x12A7D16);
	}

	-(NSResponder *) webViewFirstResponder:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_42 (self, _cmd, &managed_method, p0, 0x12A7E16);
	}

	-(float) webViewFooterHeight:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_43 (self, _cmd, &managed_method, p0, 0x12A7F16);
	}

	-(CGRect) webViewFrame:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_39 (self, _cmd, &managed_method, p0, 0x12A8016);
	}

	-(float) webViewHeaderHeight:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_43 (self, _cmd, &managed_method, p0, 0x12A8116);
	}

	-(NSString *) webViewStatusText:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_44 (self, _cmd, &managed_method, p0, 0x12A8216);
	}

	-(BOOL) webViewIsResizable:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x12A8316);
	}

	-(BOOL) webViewIsStatusBarVisible:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_34 (self, _cmd, &managed_method, p0, 0x12A8416);
	}

	-(void) webView:(WebView *)p0 makeFirstResponder:(NSResponder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_45 (self, _cmd, &managed_method, p0, p1, 0x12A8516);
	}

	-(void) webView:(WebView *)p0 mouseDidMoveOverElement:(NSDictionary *)p1 modifierFlags:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_46 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8616);
	}

	-(void) webView:(WebView *)p0 printFrameView:(WebFrameView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_47 (self, _cmd, &managed_method, p0, p1, 0x12A8716);
	}

	-(BOOL) webView:(WebView *)p0 runBeforeUnloadConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_48 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8816);
	}

	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_49 (self, _cmd, &managed_method, p0, p1, 0x12A8916);
	}

	-(void) webView:(WebView *)p0 runJavaScriptAlertPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_22 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8A16);
	}

	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_50 (self, _cmd, &managed_method, p0, p1, 0x12A8B16);
	}

	-(BOOL) webView:(WebView *)p0 runJavaScriptConfirmPanelWithMessage:(NSString *)p1 initiatedByFrame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_48 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8C16);
	}

	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_51 (self, _cmd, &managed_method, p0, p1, p2, 0x12A8D16);
	}

	-(NSString *) webView:(WebView *)p0 runJavaScriptTextInputPanelWithPrompt:(NSString *)p1 defaultText:(NSString *)p2 initiatedByFrame:(WebFrame *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_52 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A8E16);
	}

	-(void) webViewRunModal:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A8F16);
	}

	-(void) webView:(WebView *)p0 runOpenPanelForFileButtonWithResultListener:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_53 (self, _cmd, &managed_method, p0, p1, 0x12A9016);
	}

	-(void) webView:(WebView *)p0 setContentRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, p1, 0x12A9116);
	}

	-(void) webView:(WebView *)p0 setFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_38 (self, _cmd, &managed_method, p0, p1, 0x12A9216);
	}

	-(void) webView:(WebView *)p0 setResizable:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, p1, 0x12A9316);
	}

	-(void) webView:(WebView *)p0 setStatusBarVisible:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, p1, 0x12A9416);
	}

	-(void) webView:(WebView *)p0 setStatusText:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_49 (self, _cmd, &managed_method, p0, p1, 0x12A9516);
	}

	-(void) webView:(WebView *)p0 setToolbarsVisible:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_54 (self, _cmd, &managed_method, p0, p1, 0x12A9616);
	}

	-(BOOL) webView:(WebView *)p0 shouldPerformAction:(SEL)p1 fromSender:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_55 (self, _cmd, &managed_method, p0, p1, p2, 0x12A9716);
	}

	-(void) webViewShow:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A9816);
	}

	-(void) webViewUnfocus:(WebView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_35 (self, _cmd, &managed_method, p0, 0x12A9916);
	}

	-(BOOL) webView:(WebView *)p0 validateUserInterfaceItem:(NSObject *)p1 defaultValidation:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_56 (self, _cmd, &managed_method, p0, p1, p2, 0x12A9A16);
	}

	-(void) webView:(WebView *)p0 willPerformDragDestinationAction:(unsigned long long)p1 forDraggingInfo:(id<NSDraggingInfo>)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_57 (self, _cmd, &managed_method, p0, p1, p2, 0x12A9B16);
	}

	-(void) webView:(WebView *)p0 willPerformDragSourceAction:(unsigned long long)p1 fromPoint:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_58 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x12A9C16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A7216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface WebKit_WebView__WebPolicyDelegate : NSObject<WebPolicyDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) webView:(WebView *)p0 decidePolicyForMIMEType:(NSString *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 decidePolicyForNavigationAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 decidePolicyForNewWindowAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 newFrameName:(NSString *)p3 decisionListener:(NSObject *)p4;
	-(void) webView:(WebView *)p0 unableToImplementPolicyWithError:(NSError *)p1 frame:(WebFrame *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation WebKit_WebView__WebPolicyDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) webView:(WebView *)p0 decidePolicyForMIMEType:(NSString *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_59 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12A9E16);
	}

	-(void) webView:(WebView *)p0 decidePolicyForNavigationAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 frame:(WebFrame *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_60 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12A9F16);
	}

	-(void) webView:(WebView *)p0 decidePolicyForNewWindowAction:(NSDictionary *)p1 request:(NSURLRequest *)p2 newFrameName:(NSString *)p3 decisionListener:(NSObject *)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_61 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x12AA016);
	}

	-(void) webView:(WebView *)p0 unableToImplementPolicyWithError:(NSError *)p1 frame:(WebFrame *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_20 (self, _cmd, &managed_method, p0, p1, p2, 0x12AA116);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12A9D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKRequest__SKRequestDelegate : NSObject<SKRequestDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1;
	-(void) requestDidFinish:(SKRequest *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation StoreKit_SKRequest__SKRequestDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) request:(SKRequest *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_62 (self, _cmd, &managed_method, p0, p1, 0x12ABF16);
	}

	-(void) requestDidFinish:(SKRequest *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_63 (self, _cmd, &managed_method, p0, 0x12AC016);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12ABE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface StoreKit_SKProductsRequest__SKProductsRequestDelegate : StoreKit_SKRequest__SKRequestDelegate<SKProductsRequestDelegate, SKRequestDelegate> {
}
	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1;
	-(id) init;
@end

@implementation StoreKit_SKProductsRequest__SKProductsRequestDelegate {
}

	-(void) productsRequest:(SKProductsRequest *)p0 didReceiveResponse:(SKProductsResponse *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_64 (self, _cmd, &managed_method, p0, p1, 0x12ABD16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12ABC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [StoreKit_SKRequest__SKRequestDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate : NSObject<SKPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) didBeginContact:(SKPhysicsContact *)p0;
	-(void) didEndContact:(SKPhysicsContact *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) didBeginContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_65 (self, _cmd, &managed_method, p0, 0x12ACA16);
	}

	-(void) didEndContact:(SKPhysicsContact *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_65 (self, _cmd, &managed_method, p0, 0x12ACB16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12AC916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ScriptingBridge_SBApplication__SBApplicationDelegate : NSObject<SBApplicationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) eventDidFail:(void *)p0 withError:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ScriptingBridge_SBApplication__SBApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) eventDidFail:(void *)p0 withError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_66 (self, _cmd, &managed_method, p0, p1, 0x12AEE16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12AED16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate : NSObject<SCNPhysicsContactDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1;
	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didBeginContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, p1, 0x12AFE16);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didEndContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, p1, 0x12AFF16);
	}

	-(void) physicsWorld:(SCNPhysicsWorld *)p0 didUpdateContact:(SCNPhysicsContact *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_67 (self, _cmd, &managed_method, p0, p1, 0x12B0016);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x12AFD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface PdfKit_PdfDocument__PdfDocumentDelegate : NSObject<PDFDocumentDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(Class) classForAnnotationClass:(Class)p0;
	-(void) documentDidBeginDocumentFind:(NSNotification *)p0;
	-(void) didMatchString:(PDFSelection *)p0;
	-(void) documentDidUnlock:(NSNotification *)p0;
	-(void) documentDidEndDocumentFind:(NSNotification *)p0;
	-(Class) classForAnnotationType:(NSString *)p0;
	-(void) documentDidFindMatch:(NSNotification *)p0;
	-(void) documentDidEndPageFind:(NSNotification *)p0;
	-(void) documentDidBeginPageFind:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfDocument__PdfDocumentDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(Class) classForAnnotationClass:(Class)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_68 (self, _cmd, &managed_method, p0, 0x13B6616);
	}

	-(void) documentDidBeginDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6716);
	}

	-(void) didMatchString:(PDFSelection *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_69 (self, _cmd, &managed_method, p0, 0x13B6816);
	}

	-(void) documentDidUnlock:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6916);
	}

	-(void) documentDidEndDocumentFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6A16);
	}

	-(Class) classForAnnotationType:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_70 (self, _cmd, &managed_method, p0, 0x13B6B16);
	}

	-(void) documentDidFindMatch:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6C16);
	}

	-(void) documentDidEndPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6D16);
	}

	-(void) documentDidBeginPageFind:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x13B6E16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13B6516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface PdfKit_PdfView__PdfViewDelegate : NSObject<PDFViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1;
	-(void) PDFViewPerformFind:(PDFView *)p0;
	-(void) PDFViewPerformGoToPage:(PDFView *)p0;
	-(void) PDFViewPerformPrint:(PDFView *)p0;
	-(NSString *) PDFViewPrintJobTitle:(PDFView *)p0;
	-(CGFloat) PDFViewWillChangeScaleFactor:(PDFView *)p0 toScale:(CGFloat)p1;
	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation PdfKit_PdfView__PdfViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) PDFViewOpenPDF:(PDFView *)p0 forRemoteGoToAction:(PDFActionRemoteGoTo *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_71 (self, _cmd, &managed_method, p0, p1, 0x13B8916);
	}

	-(void) PDFViewPerformFind:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, 0x13B8A16);
	}

	-(void) PDFViewPerformGoToPage:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, 0x13B8B16);
	}

	-(void) PDFViewPerformPrint:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_72 (self, _cmd, &managed_method, p0, 0x13B8C16);
	}

	-(NSString *) PDFViewPrintJobTitle:(PDFView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_73 (self, _cmd, &managed_method, p0, 0x13B8D16);
	}

	-(CGFloat) PDFViewWillChangeScaleFactor:(PDFView *)p0 toScale:(CGFloat)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_74 (self, _cmd, &managed_method, p0, p1, 0x13B8E16);
	}

	-(void) PDFViewWillClickOnLink:(PDFView *)p0 withURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_75 (self, _cmd, &managed_method, p0, p1, 0x13B8F16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13B8816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate : NSObject<NCWidgetListViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) widgetList:(NCWidgetListViewController *)p0 didRemoveRow:(NSUInteger)p1;
	-(void) widgetList:(NCWidgetListViewController *)p0 didReorderRow:(NSUInteger)p1 toRow:(NSUInteger)p2;
	-(NSViewController *) widgetList:(NCWidgetListViewController *)p0 viewControllerForRow:(NSUInteger)p1;
	-(void) widgetListPerformAddAction:(NCWidgetListViewController *)p0;
	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldRemoveRow:(NSUInteger)p1;
	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldReorderRow:(NSUInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) widgetList:(NCWidgetListViewController *)p0 didRemoveRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_76 (self, _cmd, &managed_method, p0, p1, 0x13BA916);
	}

	-(void) widgetList:(NCWidgetListViewController *)p0 didReorderRow:(NSUInteger)p1 toRow:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_77 (self, _cmd, &managed_method, p0, p1, p2, 0x13BAA16);
	}

	-(NSViewController *) widgetList:(NCWidgetListViewController *)p0 viewControllerForRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_78 (self, _cmd, &managed_method, p0, p1, 0x13BAB16);
	}

	-(void) widgetListPerformAddAction:(NCWidgetListViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_79 (self, _cmd, &managed_method, p0, 0x13BAC16);
	}

	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldRemoveRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, p1, 0x13BAD16);
	}

	-(BOOL) widgetList:(NCWidgetListViewController *)p0 shouldReorderRow:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_80 (self, _cmd, &managed_method, p0, p1, 0x13BAE16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13BA816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate : NSObject<NCWidgetSearchViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 resultSelected:(NSObject *)p1;
	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 searchForTerm:(NSString *)p1 maxResults:(NSUInteger)p2;
	-(void) widgetSearchTermCleared:(NCWidgetSearchViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 resultSelected:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_81 (self, _cmd, &managed_method, p0, p1, 0x13BB016);
	}

	-(void) widgetSearch:(NCWidgetSearchViewController *)p0 searchForTerm:(NSString *)p1 maxResults:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_82 (self, _cmd, &managed_method, p0, p1, p2, 0x13BB116);
	}

	-(void) widgetSearchTermCleared:(NCWidgetSearchViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_83 (self, _cmd, &managed_method, p0, 0x13BB216);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13BAF16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface MapKit_MKMapView__MKMapViewDelegate : NSObject<MKMapViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3;
	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1;
	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1;
	-(void) mapViewDidChangeVisibleRegion:(MKMapView *)p0;
	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1;
	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1;
	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0;
	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1;
	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1;
	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1;
	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0;
	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1;
	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1;
	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1;
	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0;
	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0;
	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation MapKit_MKMapView__MKMapViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) mapView:(MKMapView *)p0 annotationView:(MKAnnotationView *)p1 didChangeDragState:(NSUInteger)p2 fromOldState:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_84 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13C8416);
	}

	-(MKClusterAnnotation *) mapView:(MKMapView *)p0 clusterAnnotationForMemberAnnotations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_85 (self, _cmd, &managed_method, p0, p1, 0x13C8516);
	}

	-(void) mapView:(MKMapView *)p0 didAddAnnotationViews:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_86 (self, _cmd, &managed_method, p0, p1, 0x13C8616);
	}

	-(void) mapView:(MKMapView *)p0 didAddOverlayRenderers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_86 (self, _cmd, &managed_method, p0, p1, 0x13C8716);
	}

	-(void) mapViewDidChangeVisibleRegion:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C8816);
	}

	-(void) mapView:(MKMapView *)p0 didDeselectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_88 (self, _cmd, &managed_method, p0, p1, 0x13C8916);
	}

	-(void) mapView:(MKMapView *)p0 didFailToLocateUserWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_89 (self, _cmd, &managed_method, p0, p1, 0x13C8A16);
	}

	-(void) mapViewDidFinishRenderingMap:(MKMapView *)p0 fullyRendered:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_90 (self, _cmd, &managed_method, p0, p1, 0x13C8B16);
	}

	-(void) mapView:(MKMapView *)p0 didSelectAnnotationView:(MKAnnotationView *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_88 (self, _cmd, &managed_method, p0, p1, 0x13C8C16);
	}

	-(void) mapViewDidStopLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C8D16);
	}

	-(void) mapView:(MKMapView *)p0 didUpdateUserLocation:(MKUserLocation *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_91 (self, _cmd, &managed_method, p0, p1, 0x13C8E16);
	}

	-(MKAnnotationView *) mapView:(MKMapView *)p0 viewForAnnotation:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_92 (self, _cmd, &managed_method, p0, p1, 0x13C8F16);
	}

	-(void) mapViewDidFailLoadingMap:(MKMapView *)p0 withError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_89 (self, _cmd, &managed_method, p0, p1, 0x13C9016);
	}

	-(void) mapViewDidFinishLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C9116);
	}

	-(MKOverlayRenderer *) mapView:(MKMapView *)p0 rendererForOverlay:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_93 (self, _cmd, &managed_method, p0, p1, 0x13C9216);
	}

	-(void) mapView:(MKMapView *)p0 regionDidChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_90 (self, _cmd, &managed_method, p0, p1, 0x13C9316);
	}

	-(void) mapView:(MKMapView *)p0 regionWillChangeAnimated:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_90 (self, _cmd, &managed_method, p0, p1, 0x13C9416);
	}

	-(void) mapViewWillStartLoadingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C9516);
	}

	-(void) mapViewWillStartLocatingUser:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C9616);
	}

	-(void) mapViewWillStartRenderingMap:(MKMapView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_87 (self, _cmd, &managed_method, p0, 0x13C9716);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13C8316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate : NSObject<IKCameraDeviceViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didEncounterError:(NSError *)p1;
	-(void) cameraDeviceViewSelectionDidChange:(IKCameraDeviceView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) cameraDeviceView:(IKCameraDeviceView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_94 (self, _cmd, &managed_method, p0, p1, 0x13CA316);
	}

	-(void) cameraDeviceViewSelectionDidChange:(IKCameraDeviceView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_95 (self, _cmd, &managed_method, p0, 0x13CA416);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CA216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate : NSObject<IKDeviceBrowserViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 didEncounterError:(NSError *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) deviceBrowserView:(IKDeviceBrowserView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_96 (self, _cmd, &managed_method, p0, p1, 0x13CA616);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CA516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKImageBrowserView__IKImageBrowserDelegate : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) imageBrowser:(IKImageBrowserView *)p0 backgroundWasRightClickedWithEvent:(NSEvent *)p1;
	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasDoubleClickedAtIndex:(NSInteger)p1;
	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasRightClickedAtIndex:(NSInteger)p1 withEvent:(NSEvent *)p2;
	-(void) imageBrowserSelectionDidChange:(IKImageBrowserView *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKImageBrowserView__IKImageBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) imageBrowser:(IKImageBrowserView *)p0 backgroundWasRightClickedWithEvent:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_97 (self, _cmd, &managed_method, p0, p1, 0x13CAE16);
	}

	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasDoubleClickedAtIndex:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_98 (self, _cmd, &managed_method, p0, p1, 0x13CAF16);
	}

	-(void) imageBrowser:(IKImageBrowserView *)p0 cellWasRightClickedAtIndex:(NSInteger)p1 withEvent:(NSEvent *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_99 (self, _cmd, &managed_method, p0, p1, p2, 0x13CB016);
	}

	-(void) imageBrowserSelectionDidChange:(IKImageBrowserView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_100 (self, _cmd, &managed_method, p0, 0x13CB116);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CAD16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKSaveOptions__IKSaveOptionsDelegate : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) saveOptions:(IKSaveOptions *)p0 shouldShowUTType:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKSaveOptions__IKSaveOptionsDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) saveOptions:(IKSaveOptions *)p0 shouldShowUTType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_101 (self, _cmd, &managed_method, p0, p1, 0x13CB316);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CB216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate : NSObject<IKScannerDeviceViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didEncounterError:(NSError *)p1;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 fileData:(NSData *)p2 error:(NSError *)p3;
	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didEncounterError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_102 (self, _cmd, &managed_method, p0, p1, 0x13CB516);
	}

	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 fileData:(NSData *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_103 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13CB616);
	}

	-(void) scannerDeviceView:(IKScannerDeviceView *)p0 didScanToURL:(NSURL *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_104 (self, _cmd, &managed_method, p0, p1, p2, 0x13CB716);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CB416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate : NSObject<GKGameCenterControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) gameCenterViewControllerDidFinish:(GKGameCenterViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_105 (self, _cmd, &managed_method, p0, 0x13CED16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CEC16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKAchievementViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate {
}

	-(void) achievementViewControllerDidFinish:(GKAchievementViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_106 (self, _cmd, &managed_method, p0, 0x13CDF16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CDE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate : NSObject<GKChallengeEventHandlerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) localPlayerDidCompleteChallenge:(GKChallenge *)p0;
	-(void) localPlayerDidReceiveChallenge:(GKChallenge *)p0;
	-(void) localPlayerDidSelectChallenge:(GKChallenge *)p0;
	-(void) remotePlayerDidCompleteChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForLocallyCompletedChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForLocallyReceivedChallenge:(GKChallenge *)p0;
	-(BOOL) shouldShowBannerForRemotelyCompletedChallenge:(GKChallenge *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) localPlayerDidCompleteChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, 0x13CE316);
	}

	-(void) localPlayerDidReceiveChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, 0x13CE416);
	}

	-(void) localPlayerDidSelectChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, 0x13CE516);
	}

	-(void) remotePlayerDidCompleteChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_107 (self, _cmd, &managed_method, p0, 0x13CE616);
	}

	-(BOOL) shouldShowBannerForLocallyCompletedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, 0x13CE716);
	}

	-(BOOL) shouldShowBannerForLocallyReceivedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, 0x13CE816);
	}

	-(BOOL) shouldShowBannerForRemotelyCompletedChallenge:(GKChallenge *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_108 (self, _cmd, &managed_method, p0, 0x13CE916);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CE216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate : NSObject<GKFriendRequestComposeViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) friendRequestComposeViewControllerDidFinish:(GKFriendRequestComposeViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_109 (self, _cmd, &managed_method, p0, 0x13CEB16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13CEA16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate : GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate<GKLeaderboardViewControllerDelegate, GKGameCenterControllerDelegate> {
}
	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0;
	-(id) init;
@end

@implementation GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate {
}

	-(void) leaderboardViewControllerDidFinish:(GKLeaderboardViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_110 (self, _cmd, &managed_method, p0, 0x13D1316);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13D1216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKMatch__GKMatchDelegate : NSObject<GKMatchDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) xamarin:(GKMatch *)p0 selector:(NSString *)p1 removed:(NSError *)p2;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3;
	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2;
	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1;
	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1;
	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2;
	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatch__GKMatchDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) xamarin:(GKMatch *)p0 selector:(NSString *)p1 removed:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_111 (self, _cmd, &managed_method, p0, p1, p2, 0x13D2916);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromPlayer:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_112 (self, _cmd, &managed_method, p0, p1, p2, 0x13D2A16);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 forRecipient:(GKPlayer *)p2 fromRemotePlayer:(GKPlayer *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_113 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13D2B16);
	}

	-(void) match:(GKMatch *)p0 didReceiveData:(NSData *)p1 fromRemotePlayer:(GKPlayer *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_114 (self, _cmd, &managed_method, p0, p1, p2, 0x13D2C16);
	}

	-(void) match:(GKMatch *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_115 (self, _cmd, &managed_method, p0, p1, 0x13D2D16);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinviteDisconnectedPlayer:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_116 (self, _cmd, &managed_method, p0, p1, 0x13D2E16);
	}

	-(BOOL) match:(GKMatch *)p0 shouldReinvitePlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_117 (self, _cmd, &managed_method, p0, p1, 0x13D2F16);
	}

	-(void) match:(GKMatch *)p0 player:(NSString *)p1 didChangeState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_118 (self, _cmd, &managed_method, p0, p1, p2, 0x13D3016);
	}

	-(void) match:(GKMatch *)p0 player:(GKPlayer *)p1 didChangeConnectionState:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_119 (self, _cmd, &managed_method, p0, p1, p2, 0x13D3116);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13D2816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate : NSObject<GKMatchmakerViewControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1;
	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1;
	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_120 (self, _cmd, &managed_method, p0, p1, 0x13D4716);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindHostedPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_121 (self, _cmd, &managed_method, p0, p1, 0x13D4816);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindMatch:(GKMatch *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_122 (self, _cmd, &managed_method, p0, p1, 0x13D4916);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didFindPlayers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_123 (self, _cmd, &managed_method, p0, p1, 0x13D4A16);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 hostedPlayerDidAccept:(GKPlayer *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_124 (self, _cmd, &managed_method, p0, p1, 0x13D4B16);
	}

	-(void) matchmakerViewController:(GKMatchmakerViewController *)p0 didReceiveAcceptFromHostedPlayer:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_125 (self, _cmd, &managed_method, p0, p1, 0x13D4C16);
	}

	-(void) matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_126 (self, _cmd, &managed_method, p0, 0x13D4D16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13D4616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface ExternalAccessory_EAAccessory__EAAccessoryDelegate : NSObject<EAAccessoryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) accessoryDidDisconnect:(EAAccessory *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation ExternalAccessory_EAAccessory__EAAccessoryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) accessoryDidDisconnect:(EAAccessory *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_127 (self, _cmd, &managed_method, p0, 0x13D9D16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13D9C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreLocation_CLLocationManager__CLLocationManagerDelegate : NSObject<CLLocationManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1;
	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1;
	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2;
	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1;
	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1;
	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0;
	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreLocation_CLLocationManager__CLLocationManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) locationManager:(CLLocationManager *)p0 didChangeAuthorizationStatus:(unsigned int)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_128 (self, _cmd, &managed_method, p0, p1, 0x13E2E16);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFinishDeferredUpdatesWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, p1, 0x13E2F16);
	}

	-(void) locationManager:(CLLocationManager *)p0 didDetermineState:(NSInteger)p1 forRegion:(CLRegion *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_130 (self, _cmd, &managed_method, p0, p1, p2, 0x13E3016);
	}

	-(void) locationManager:(CLLocationManager *)p0 didStartMonitoringForRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, 0x13E3116);
	}

	-(void) locationManager:(CLLocationManager *)p0 didFailWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_129 (self, _cmd, &managed_method, p0, p1, 0x13E3216);
	}

	-(void) locationManagerDidPauseLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, 0x13E3316);
	}

	-(void) locationManagerDidResumeLocationUpdates:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_132 (self, _cmd, &managed_method, p0, 0x13E3416);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateLocations:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_133 (self, _cmd, &managed_method, p0, p1, 0x13E3516);
	}

	-(void) locationManager:(CLLocationManager *)p0 monitoringDidFailForRegion:(CLRegion *)p1 withError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_134 (self, _cmd, &managed_method, p0, p1, p2, 0x13E3616);
	}

	-(void) locationManager:(CLLocationManager *)p0 didEnterRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, 0x13E3716);
	}

	-(void) locationManager:(CLLocationManager *)p0 didExitRegion:(CLRegion *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_131 (self, _cmd, &managed_method, p0, p1, 0x13E3816);
	}

	-(BOOL) locationManagerShouldDisplayHeadingCalibration:(CLLocationManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_135 (self, _cmd, &managed_method, p0, 0x13E3916);
	}

	-(void) locationManager:(CLLocationManager *)p0 didUpdateToLocation:(CLLocation *)p1 fromLocation:(CLLocation *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_136 (self, _cmd, &managed_method, p0, p1, p2, 0x13E3A16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13E2D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBCentralManager__CBCentralManagerDelegate : NSObject<CBCentralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3;
	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2;
	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1;
	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1;
	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0;
	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBCentralManager__CBCentralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) centralManager:(CBCentralManager *)p0 didConnectPeripheral:(CBPeripheral *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_137 (self, _cmd, &managed_method, p0, p1, 0x13F3716);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDisconnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_138 (self, _cmd, &managed_method, p0, p1, p2, 0x13F3816);
	}

	-(void) centralManager:(CBCentralManager *)p0 didDiscoverPeripheral:(CBPeripheral *)p1 advertisementData:(NSDictionary *)p2 RSSI:(NSNumber *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_139 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13F3916);
	}

	-(void) centralManager:(CBCentralManager *)p0 didFailToConnectPeripheral:(CBPeripheral *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_138 (self, _cmd, &managed_method, p0, p1, p2, 0x13F3A16);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrieveConnectedPeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_140 (self, _cmd, &managed_method, p0, p1, 0x13F3B16);
	}

	-(void) centralManager:(CBCentralManager *)p0 didRetrievePeripherals:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_140 (self, _cmd, &managed_method, p0, p1, 0x13F3C16);
	}

	-(void) centralManagerDidUpdateState:(CBCentralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_141 (self, _cmd, &managed_method, p0, 0x13F3D16);
	}

	-(void) centralManager:(CBCentralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_142 (self, _cmd, &managed_method, p0, p1, 0x13F3E16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13F3616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheral__CBPeripheralDelegate : NSObject<CBPeripheralDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1;
	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0;
	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheralDidUpdateName:(CBPeripheral *)p0;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2;
	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheral__CBPeripheralDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) peripheral:(CBPeripheral *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_143 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4016);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverCharacteristicsForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4116);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4216);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverIncludedServicesForService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_144 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4316);
	}

	-(void) peripheral:(CBPeripheral *)p0 didDiscoverServices:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_146 (self, _cmd, &managed_method, p0, p1, 0x13F4416);
	}

	-(void) peripheralDidInvalidateServices:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x13F4516);
	}

	-(void) peripheralIsReadyToSendWriteWithoutResponse:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x13F4616);
	}

	-(void) peripheral:(CBPeripheral *)p0 didModifyServices:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_148 (self, _cmd, &managed_method, p0, p1, 0x13F4716);
	}

	-(void) peripheral:(CBPeripheral *)p0 didReadRSSI:(NSNumber *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_149 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4816);
	}

	-(void) peripheralDidUpdateRSSI:(CBPeripheral *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_146 (self, _cmd, &managed_method, p0, p1, 0x13F4916);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4A16);
	}

	-(void) peripheralDidUpdateName:(CBPeripheral *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_147 (self, _cmd, &managed_method, p0, 0x13F4B16);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateNotificationStateForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4C16);
	}

	-(void) peripheral:(CBPeripheral *)p0 didUpdateValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4D16);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForCharacteristic:(CBCharacteristic *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_145 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4E16);
	}

	-(void) peripheral:(CBPeripheral *)p0 didWriteValueForDescriptor:(CBDescriptor *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_150 (self, _cmd, &managed_method, p0, p1, p2, 0x13F4F16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13F3F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate : NSObject<CBPeripheralManagerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1;
	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2;
	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0;
	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1;
	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) peripheralManagerDidStartAdvertising:(CBPeripheralManager *)p0 error:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_151 (self, _cmd, &managed_method, p0, p1, 0x13F5116);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didSubscribeToCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5216);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 central:(CBCentral *)p1 didUnsubscribeFromCharacteristic:(CBCharacteristic *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_152 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5316);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didOpenL2CAPChannel:(CBL2CAPChannel *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_153 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5416);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didPublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5516);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didUnpublishL2CAPChannel:(unsigned short)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_154 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5616);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveReadRequest:(CBATTRequest *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_155 (self, _cmd, &managed_method, p0, p1, 0x13F5716);
	}

	-(void) peripheralManagerIsReadyToUpdateSubscribers:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_156 (self, _cmd, &managed_method, p0, 0x13F5816);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didAddService:(CBService *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_157 (self, _cmd, &managed_method, p0, p1, p2, 0x13F5916);
	}

	-(void) peripheralManagerDidUpdateState:(CBPeripheralManager *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_156 (self, _cmd, &managed_method, p0, 0x13F5A16);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 willRestoreState:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_158 (self, _cmd, &managed_method, p0, p1, 0x13F5B16);
	}

	-(void) peripheralManager:(CBPeripheralManager *)p0 didReceiveWriteRequests:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_159 (self, _cmd, &managed_method, p0, p1, 0x13F5C16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13F5016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface CoreAnimation_CAAnimation__CAAnimationDelegate : NSObject<CAAnimationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) animationDidStart:(CAAnimation *)p0;
	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation CoreAnimation_CAAnimation__CAAnimationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) animationDidStart:(CAAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_160 (self, _cmd, &managed_method, p0, 0x13F5E16);
	}

	-(void) animationDidStop:(CAAnimation *)p0 finished:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_161 (self, _cmd, &managed_method, p0, p1, 0x13F5F16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x13F5D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AVFoundation_AVCaptureFileOutput_recordingProxy : NSObject<AVCaptureFileOutputRecordingDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2;
	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation AVFoundation_AVCaptureFileOutput_recordingProxy {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) captureOutput:(AVCaptureFileOutput *)p0 didStartRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_162 (self, _cmd, &managed_method, p0, p1, p2, 0x13FE216);
	}

	-(void) captureOutput:(AVCaptureFileOutput *)p0 didFinishRecordingToOutputFileAtURL:(NSURL *)p1 fromConnections:(NSArray *)p2 error:(NSError *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_163 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x13FE316);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@interface AppKit_NSAlert__NSAlertDelegate : NSObject<NSAlertDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) alertShowHelp:(NSAlert *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSAlert__NSAlertDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) alertShowHelp:(NSAlert *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_164 (self, _cmd, &managed_method, p0, 0x1418D16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1418C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSAnimation__NSAnimationDelegate : NSObject<NSAnimationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) animationDidEnd:(NSAnimation *)p0;
	-(void) animation:(NSAnimation *)p0 didReachProgressMark:(float)p1;
	-(void) animationDidStop:(NSAnimation *)p0;
	-(BOOL) animationShouldStart:(NSAnimation *)p0;
	-(float) animation:(NSAnimation *)p0 valueForProgress:(float)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSAnimation__NSAnimationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) animationDidEnd:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_165 (self, _cmd, &managed_method, p0, 0x1419516);
	}

	-(void) animation:(NSAnimation *)p0 didReachProgressMark:(float)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_166 (self, _cmd, &managed_method, p0, p1, 0x1419616);
	}

	-(void) animationDidStop:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_165 (self, _cmd, &managed_method, p0, 0x1419716);
	}

	-(BOOL) animationShouldStart:(NSAnimation *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_167 (self, _cmd, &managed_method, p0, 0x1419816);
	}

	-(float) animation:(NSAnimation *)p0 valueForProgress:(float)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_168 (self, _cmd, &managed_method, p0, p1, 0x1419916);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1419416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSApplication__NSApplicationDelegate : NSObject<NSApplicationDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSMenu *) applicationDockMenu:(NSApplication *)p0;
	-(BOOL) applicationOpenUntitledFile:(NSApplication *)p0;
	-(BOOL) applicationShouldHandleReopen:(NSApplication *)p0 hasVisibleWindows:(BOOL)p1;
	-(BOOL) applicationShouldOpenUntitledFile:(NSApplication *)p0;
	-(NSUInteger) applicationShouldTerminate:(NSApplication *)p0;
	-(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)p0;
	-(BOOL) application:(NSApplication *)p0 continueUserActivity:(NSUserActivity *)p1 restorationHandler:(id)p2;
	-(void) application:(NSApplication *)p0 didDecodeRestorableState:(NSCoder *)p1;
	-(void) applicationDidBecomeActive:(NSNotification *)p0;
	-(void) applicationDidFinishLaunching:(NSNotification *)p0;
	-(void) applicationDidHide:(NSNotification *)p0;
	-(void) applicationDidResignActive:(NSNotification *)p0;
	-(void) applicationDidUnhide:(NSNotification *)p0;
	-(void) applicationDidUpdate:(NSNotification *)p0;
	-(void) application:(NSApplication *)p0 didFailToContinueUserActivityWithType:(NSString *)p1 error:(NSError *)p2;
	-(void) application:(NSApplication *)p0 didFailToRegisterForRemoteNotificationsWithError:(NSError *)p1;
	-(BOOL) application:(NSApplication *)p0 delegateHandlesKey:(NSString *)p1;
	-(BOOL) application:(NSApplication *)p0 openFile:(NSString *)p1;
	-(BOOL) application:(NSObject *)p0 openFileWithoutUI:(NSString *)p1;
	-(void) application:(NSApplication *)p0 openFiles:(NSArray *)p1;
	-(BOOL) application:(NSApplication *)p0 openTempFile:(NSString *)p1;
	-(void) application:(NSApplication *)p0 openURLs:(NSArray *)p1;
	-(void) orderFrontStandardAboutPanel:(NSObject *)p0;
	-(void) orderFrontStandardAboutPanelWithOptions:(NSDictionary *)p0;
	-(BOOL) application:(NSApplication *)p0 printFile:(NSString *)p1;
	-(NSUInteger) application:(NSApplication *)p0 printFiles:(NSArray *)p1 withSettings:(NSDictionary *)p2 showPrintPanels:(BOOL)p3;
	-(BOOL) readSelectionFromPasteboard:(NSPasteboard *)p0;
	-(void) application:(NSApplication *)p0 didReceiveRemoteNotification:(NSDictionary *)p1;
	-(void) registerServicesMenuSendTypes:(NSArray *)p0 returnTypes:(NSArray *)p1;
	-(void) application:(NSApplication *)p0 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)p1;
	-(void) applicationDidChangeScreenParameters:(NSNotification *)p0;
	-(void) application:(NSApplication *)p0 didUpdateUserActivity:(NSUserActivity *)p1;
	-(void) application:(NSApplication *)p0 userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)p1;
	-(void) applicationWillBecomeActive:(NSNotification *)p0;
	-(BOOL) application:(NSApplication *)p0 willContinueUserActivityWithType:(NSString *)p1;
	-(void) application:(NSApplication *)p0 willEncodeRestorableState:(NSCoder *)p1;
	-(void) applicationWillFinishLaunching:(NSNotification *)p0;
	-(void) applicationWillHide:(NSNotification *)p0;
	-(NSError *) application:(NSApplication *)p0 willPresentError:(NSError *)p1;
	-(void) applicationWillResignActive:(NSNotification *)p0;
	-(void) applicationWillTerminate:(NSNotification *)p0;
	-(void) applicationWillUnhide:(NSNotification *)p0;
	-(void) applicationWillUpdate:(NSNotification *)p0;
	-(BOOL) writeSelectionToPasteboard:(NSPasteboard *)p0 types:(NSArray *)p1;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSApplication__NSApplicationDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSMenu *) applicationDockMenu:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_169 (self, _cmd, &managed_method, p0, 0x1419D16);
	}

	-(BOOL) applicationOpenUntitledFile:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x1419E16);
	}

	-(BOOL) applicationShouldHandleReopen:(NSApplication *)p0 hasVisibleWindows:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_171 (self, _cmd, &managed_method, p0, p1, 0x1419F16);
	}

	-(BOOL) applicationShouldOpenUntitledFile:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x141A016);
	}

	-(NSUInteger) applicationShouldTerminate:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_172 (self, _cmd, &managed_method, p0, 0x141A116);
	}

	-(BOOL) applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_170 (self, _cmd, &managed_method, p0, 0x141A216);
	}

	-(BOOL) application:(NSApplication *)p0 continueUserActivity:(NSUserActivity *)p1 restorationHandler:(id)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_173 (self, _cmd, &managed_method, p0, p1, p2, 0x141A316);
	}

	-(void) application:(NSApplication *)p0 didDecodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_174 (self, _cmd, &managed_method, p0, p1, 0x141A416);
	}

	-(void) applicationDidBecomeActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A516);
	}

	-(void) applicationDidFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A616);
	}

	-(void) applicationDidHide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A716);
	}

	-(void) applicationDidResignActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A816);
	}

	-(void) applicationDidUnhide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141A916);
	}

	-(void) applicationDidUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141AA16);
	}

	-(void) application:(NSApplication *)p0 didFailToContinueUserActivityWithType:(NSString *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_175 (self, _cmd, &managed_method, p0, p1, p2, 0x141AB16);
	}

	-(void) application:(NSApplication *)p0 didFailToRegisterForRemoteNotificationsWithError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_176 (self, _cmd, &managed_method, p0, p1, 0x141AC16);
	}

	-(BOOL) application:(NSApplication *)p0 delegateHandlesKey:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141AD16);
	}

	-(BOOL) application:(NSApplication *)p0 openFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141AE16);
	}

	-(BOOL) application:(NSObject *)p0 openFileWithoutUI:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_178 (self, _cmd, &managed_method, p0, p1, 0x141AF16);
	}

	-(void) application:(NSApplication *)p0 openFiles:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_179 (self, _cmd, &managed_method, p0, p1, 0x141B016);
	}

	-(BOOL) application:(NSApplication *)p0 openTempFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141B116);
	}

	-(void) application:(NSApplication *)p0 openURLs:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_180 (self, _cmd, &managed_method, p0, p1, 0x141B216);
	}

	-(void) orderFrontStandardAboutPanel:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x141B316);
	}

	-(void) orderFrontStandardAboutPanelWithOptions:(NSDictionary *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_181 (self, _cmd, &managed_method, p0, 0x141B416);
	}

	-(BOOL) application:(NSApplication *)p0 printFile:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141B516);
	}

	-(NSUInteger) application:(NSApplication *)p0 printFiles:(NSArray *)p1 withSettings:(NSDictionary *)p2 showPrintPanels:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_182 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x141B616);
	}

	-(BOOL) readSelectionFromPasteboard:(NSPasteboard *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_183 (self, _cmd, &managed_method, p0, 0x141B716);
	}

	-(void) application:(NSApplication *)p0 didReceiveRemoteNotification:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_184 (self, _cmd, &managed_method, p0, p1, 0x141B816);
	}

	-(void) registerServicesMenuSendTypes:(NSArray *)p0 returnTypes:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_185 (self, _cmd, &managed_method, p0, p1, 0x141B916);
	}

	-(void) application:(NSApplication *)p0 didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_186 (self, _cmd, &managed_method, p0, p1, 0x141BA16);
	}

	-(void) applicationDidChangeScreenParameters:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141BB16);
	}

	-(void) application:(NSApplication *)p0 didUpdateUserActivity:(NSUserActivity *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_187 (self, _cmd, &managed_method, p0, p1, 0x141BC16);
	}

	-(void) application:(NSApplication *)p0 userDidAcceptCloudKitShareWithMetadata:(CKShareMetadata *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_188 (self, _cmd, &managed_method, p0, p1, 0x141BD16);
	}

	-(void) applicationWillBecomeActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141BE16);
	}

	-(BOOL) application:(NSApplication *)p0 willContinueUserActivityWithType:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_177 (self, _cmd, &managed_method, p0, p1, 0x141BF16);
	}

	-(void) application:(NSApplication *)p0 willEncodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_174 (self, _cmd, &managed_method, p0, p1, 0x141C016);
	}

	-(void) applicationWillFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C116);
	}

	-(void) applicationWillHide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C216);
	}

	-(NSError *) application:(NSApplication *)p0 willPresentError:(NSError *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_189 (self, _cmd, &managed_method, p0, p1, 0x141C316);
	}

	-(void) applicationWillResignActive:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C416);
	}

	-(void) applicationWillTerminate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C516);
	}

	-(void) applicationWillUnhide:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C616);
	}

	-(void) applicationWillUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x141C716);
	}

	-(BOOL) writeSelectionToPasteboard:(NSPasteboard *)p0 types:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_190 (self, _cmd, &managed_method, p0, p1, 0x141C816);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, 0x141C916);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1419C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation __NSGestureRecognizerToken {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1433E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSClickGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSClickGestureRecognizer *)p0;
@end

@implementation __NSClickGestureRecognizer {
}

	-(void) target:(NSClickGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_192 (self, _cmd, &managed_method, p0, 0x1427216);
	}
@end

@interface AppKit_NSTextField__NSTextFieldDelegate : NSObject<NSTextFieldDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) controlTextDidChange:(NSNotification *)p0;
	-(BOOL) control:(NSControl *)p0 didFailToFormatString:(NSString *)p1 errorDescription:(NSString *)p2;
	-(void) control:(NSControl *)p0 didFailToValidatePartialString:(NSString *)p1 errorDescription:(NSString *)p2;
	-(BOOL) control:(NSControl *)p0 textView:(NSTextView *)p1 doCommandBySelector:(SEL)p2;
	-(void) controlTextDidBeginEditing:(NSNotification *)p0;
	-(void) controlTextDidEndEditing:(NSNotification *)p0;
	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidatesForSelectedRange:(NSRange)p2;
	-(NSArray *) control:(NSControl *)p0 textView:(NSTextView *)p1 completions:(NSArray *)p2 forPartialWordRange:(NSRange)p3 indexOfSelectedItem:(NSInteger*)p4;
	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidates:(NSArray *)p2 forSelectedRange:(NSRange)p3;
	-(BOOL) control:(NSControl *)p0 isValidObject:(NSObject *)p1;
	-(BOOL) textField:(NSTextField *)p0 textView:(NSTextView *)p1 shouldSelectCandidateAtIndex:(NSUInteger)p2;
	-(BOOL) control:(NSControl *)p0 textShouldBeginEditing:(NSText *)p1;
	-(BOOL) control:(NSControl *)p0 textShouldEndEditing:(NSText *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTextField__NSTextFieldDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) controlTextDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1452616);
	}

	-(BOOL) control:(NSControl *)p0 didFailToFormatString:(NSString *)p1 errorDescription:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_193 (self, _cmd, &managed_method, p0, p1, p2, 0x1452716);
	}

	-(void) control:(NSControl *)p0 didFailToValidatePartialString:(NSString *)p1 errorDescription:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_194 (self, _cmd, &managed_method, p0, p1, p2, 0x1452816);
	}

	-(BOOL) control:(NSControl *)p0 textView:(NSTextView *)p1 doCommandBySelector:(SEL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_195 (self, _cmd, &managed_method, p0, p1, p2, 0x1452916);
	}

	-(void) controlTextDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1452A16);
	}

	-(void) controlTextDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1452B16);
	}

	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidatesForSelectedRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_196 (self, _cmd, &managed_method, p0, p1, p2, 0x1452C16);
	}

	-(NSArray *) control:(NSControl *)p0 textView:(NSTextView *)p1 completions:(NSArray *)p2 forPartialWordRange:(NSRange)p3 indexOfSelectedItem:(NSInteger*)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_197 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x1452D16);
	}

	-(NSArray *) textField:(NSTextField *)p0 textView:(NSTextView *)p1 candidates:(NSArray *)p2 forSelectedRange:(NSRange)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_198 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1452E16);
	}

	-(BOOL) control:(NSControl *)p0 isValidObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_199 (self, _cmd, &managed_method, p0, p1, 0x1452F16);
	}

	-(BOOL) textField:(NSTextField *)p0 textView:(NSTextView *)p1 shouldSelectCandidateAtIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_200 (self, _cmd, &managed_method, p0, p1, p2, 0x1453016);
	}

	-(BOOL) control:(NSControl *)p0 textShouldBeginEditing:(NSText *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, 0x1453116);
	}

	-(BOOL) control:(NSControl *)p0 textShouldEndEditing:(NSText *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_201 (self, _cmd, &managed_method, p0, p1, 0x1453216);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1452516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSComboBox__NSComboBoxDelegate : AppKit_NSTextField__NSTextFieldDelegate<NSComboBoxDelegate, NSTextFieldDelegate> {
}
	-(void) comboBoxSelectionDidChange:(NSNotification *)p0;
	-(void) comboBoxSelectionIsChanging:(NSNotification *)p0;
	-(void) comboBoxWillDismiss:(NSNotification *)p0;
	-(void) comboBoxWillPopUp:(NSNotification *)p0;
	-(id) init;
@end

@implementation AppKit_NSComboBox__NSComboBoxDelegate {
}

	-(void) comboBoxSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1427816);
	}

	-(void) comboBoxSelectionIsChanging:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1427916);
	}

	-(void) comboBoxWillDismiss:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1427A16);
	}

	-(void) comboBoxWillPopUp:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1427B16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1427716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSTextField__NSTextFieldDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSDatePicker__NSDatePickerCellDelegate : NSObject<NSDatePickerCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDatePicker__NSDatePickerCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0x1428B16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1428A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSDatePickerCell__NSDatePickerCellDelegate : NSObject<NSDatePickerCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDatePickerCell__NSDatePickerCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) datePickerCell:(NSDatePickerCell *)p0 validateProposedDateValue:(NSDate **)p1 timeInterval:(double)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_202 (self, _cmd, &managed_method, p0, p1, p2, 0x1428D16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1428C16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSDocumentDuplicateCallback : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) document:(NSDocument *)p0 didDuplicate:(BOOL)p1 contextInfo:(void *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __NSDocumentDuplicateCallback {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) document:(NSDocument *)p0 didDuplicate:(BOOL)p1 contextInfo:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_203 (self, _cmd, &managed_method, p0, p1, p2, 0x1429316);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@interface AppKit_NSDrawer__NSDrawerDelegate : NSObject<NSDrawerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) drawerDidClose:(NSNotification *)p0;
	-(void) drawerDidOpen:(NSNotification *)p0;
	-(BOOL) drawerShouldClose:(NSDrawer *)p0;
	-(BOOL) drawerShouldOpen:(NSDrawer *)p0;
	-(void) drawerWillClose:(NSNotification *)p0;
	-(void) drawerWillOpen:(NSNotification *)p0;
	-(CGSize) drawerWillResizeContents:(NSDrawer *)p0 toSize:(CGSize)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSDrawer__NSDrawerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) drawerDidClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1429916);
	}

	-(void) drawerDidOpen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1429A16);
	}

	-(BOOL) drawerShouldClose:(NSDrawer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_204 (self, _cmd, &managed_method, p0, 0x1429B16);
	}

	-(BOOL) drawerShouldOpen:(NSDrawer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_204 (self, _cmd, &managed_method, p0, 0x1429C16);
	}

	-(void) drawerWillClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1429D16);
	}

	-(void) drawerWillOpen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1429E16);
	}

	-(CGSize) drawerWillResizeContents:(NSDrawer *)p0 toSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_205 (self, _cmd, &managed_method, p0, p1, 0x1429F16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1429816);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate : NSObject<NSGestureRecognizerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldAttemptToRecognizeWithEvent:(NSEvent *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) gestureRecognizerShouldBegin:(NSGestureRecognizer *)p0;
	-(BOOL) xamarinselector:(NSGestureRecognizer *)p0 removed:(NSEvent *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldReceiveTouch:(NSTouch *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldAttemptToRecognizeWithEvent:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x1433716);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldBeRequiredToFailByGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, 0x1433816);
	}

	-(BOOL) gestureRecognizerShouldBegin:(NSGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_208 (self, _cmd, &managed_method, p0, 0x1433916);
	}

	-(BOOL) xamarinselector:(NSGestureRecognizer *)p0 removed:(NSEvent *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_206 (self, _cmd, &managed_method, p0, p1, 0x1433A16);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldReceiveTouch:(NSTouch *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_209 (self, _cmd, &managed_method, p0, p1, 0x1433B16);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRecognizeSimultaneouslyWithGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, 0x1433C16);
	}

	-(BOOL) gestureRecognizer:(NSGestureRecognizer *)p0 shouldRequireFailureOfGestureRecognizer:(NSGestureRecognizer *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_207 (self, _cmd, &managed_method, p0, p1, 0x1433D16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1433616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation __NSGestureRecognizerParameterlessToken {
}

	-(void) target
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x1434016);
	}
@end

@implementation __NSGestureRecognizerParametrizedToken {
}

	-(void) target:(NSGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_210 (self, _cmd, &managed_method, p0, 0x1434216);
	}
@end

@interface AppKit_NSImage__NSImageDelegate : NSObject<NSImageDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) image:(NSImage *)p0 didLoadPartOfRepresentation:(NSImageRep *)p1 withValidRows:(NSInteger)p2;
	-(void) image:(NSImage *)p0 didLoadRepresentation:(NSImageRep *)p1 withStatus:(NSUInteger)p2;
	-(void) image:(NSImage *)p0 didLoadRepresentationHeader:(NSImageRep *)p1;
	-(NSImage *) imageDidNotDraw:(NSObject *)p0 inRect:(CGRect)p1;
	-(void) image:(NSImage *)p0 willLoadRepresentation:(NSImageRep *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSImage__NSImageDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) image:(NSImage *)p0 didLoadPartOfRepresentation:(NSImageRep *)p1 withValidRows:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_211 (self, _cmd, &managed_method, p0, p1, p2, 0x1434B16);
	}

	-(void) image:(NSImage *)p0 didLoadRepresentation:(NSImageRep *)p1 withStatus:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_212 (self, _cmd, &managed_method, p0, p1, p2, 0x1434C16);
	}

	-(void) image:(NSImage *)p0 didLoadRepresentationHeader:(NSImageRep *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_213 (self, _cmd, &managed_method, p0, p1, 0x1434D16);
	}

	-(NSImage *) imageDidNotDraw:(NSObject *)p0 inRect:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_214 (self, _cmd, &managed_method, p0, p1, 0x1434E16);
	}

	-(void) image:(NSImage *)p0 willLoadRepresentation:(NSImageRep *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_213 (self, _cmd, &managed_method, p0, p1, 0x1434F16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1434A16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSMagnificationGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSMagnificationGestureRecognizer *)p0;
@end

@implementation __NSMagnificationGestureRecognizer {
}

	-(void) target:(NSMagnificationGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_215 (self, _cmd, &managed_method, p0, 0x1435316);
	}
@end

@interface AppKit_NSMatrix__NSMatrixDelegate : NSObject<NSMatrixDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSMatrix__NSMatrixDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1435416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSPageController__NSPageControllerDelegate : NSObject<NSPageControllerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) pageControllerDidEndLiveTransition:(NSPageController *)p0;
	-(void) pageController:(NSPageController *)p0 didTransitionToObject:(NSObject *)p1;
	-(CGRect) pageController:(NSPageController *)p0 frameForObject:(NSObject *)p1;
	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1;
	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1;
	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2;
	-(void) pageControllerWillStartLiveTransition:(NSPageController *)p0;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSPageController__NSPageControllerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) pageControllerDidEndLiveTransition:(NSPageController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_216 (self, _cmd, &managed_method, p0, 0x143F816);
	}

	-(void) pageController:(NSPageController *)p0 didTransitionToObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_217 (self, _cmd, &managed_method, p0, p1, 0x143F916);
	}

	-(CGRect) pageController:(NSPageController *)p0 frameForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_218 (self, _cmd, &managed_method, p0, p1, 0x143FA16);
	}

	-(NSString *) pageController:(NSPageController *)p0 identifierForObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_219 (self, _cmd, &managed_method, p0, p1, 0x143FB16);
	}

	-(NSViewController *) pageController:(NSPageController *)p0 viewControllerForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_220 (self, _cmd, &managed_method, p0, p1, 0x143FC16);
	}

	-(void) pageController:(NSPageController *)p0 prepareViewController:(NSViewController *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_221 (self, _cmd, &managed_method, p0, p1, p2, 0x143FD16);
	}

	-(void) pageControllerWillStartLiveTransition:(NSPageController *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_216 (self, _cmd, &managed_method, p0, 0x143FE16);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, 0x143FF16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x143F716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSPanGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSPanGestureRecognizer *)p0;
@end

@implementation __NSPanGestureRecognizer {
}

	-(void) target:(NSPanGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_222 (self, _cmd, &managed_method, p0, 0x1440216);
	}
@end

@interface AppKit_NSPathCell__NSPathCellDelegate : NSObject<NSPathCellDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) pathCell:(NSPathCell *)p0 willDisplayOpenPanel:(NSOpenPanel *)p1;
	-(void) pathCell:(NSPathCell *)p0 willPopUpMenu:(NSMenu *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSPathCell__NSPathCellDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) pathCell:(NSPathCell *)p0 willDisplayOpenPanel:(NSOpenPanel *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_223 (self, _cmd, &managed_method, p0, p1, 0x1440416);
	}

	-(void) pathCell:(NSPathCell *)p0 willPopUpMenu:(NSMenu *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_224 (self, _cmd, &managed_method, p0, p1, 0x1440516);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1440316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSPressGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSPressGestureRecognizer *)p0;
@end

@implementation __NSPressGestureRecognizer {
}

	-(void) target:(NSPressGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_225 (self, _cmd, &managed_method, p0, 0x1445D16);
	}
@end

@interface __NSRotationGestureRecognizer : __NSGestureRecognizerToken {
}
	-(void) target:(NSRotationGestureRecognizer *)p0;
@end

@implementation __NSRotationGestureRecognizer {
}

	-(void) target:(NSRotationGestureRecognizer *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_226 (self, _cmd, &managed_method, p0, 0x1445F16);
	}
@end

@interface AppKit_NSRuleEditor__NSRuleEditorDelegate : NSObject<NSRuleEditorDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) controlTextDidChange:(NSNotification *)p0;
	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 child:(NSInteger)p1 forCriterion:(NSObject *)p2 withRowType:(NSUInteger)p3;
	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 displayValueForCriterion:(NSObject *)p1 inRow:(NSInteger)p2;
	-(void) controlTextDidBeginEditing:(NSNotification *)p0;
	-(void) controlTextDidEndEditing:(NSNotification *)p0;
	-(NSInteger) ruleEditor:(NSRuleEditor *)p0 numberOfChildrenForCriterion:(NSObject *)p1 withRowType:(NSUInteger)p2;
	-(NSDictionary *) ruleEditor:(NSRuleEditor *)p0 predicatePartsForCriterion:(NSObject *)p1 withDisplayValue:(NSObject *)p2 inRow:(NSInteger)p3;
	-(void) ruleEditorRowsDidChange:(NSNotification *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSRuleEditor__NSRuleEditorDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) controlTextDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1446116);
	}

	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 child:(NSInteger)p1 forCriterion:(NSObject *)p2 withRowType:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_227 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1446216);
	}

	-(NSObject *) ruleEditor:(NSRuleEditor *)p0 displayValueForCriterion:(NSObject *)p1 inRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_228 (self, _cmd, &managed_method, p0, p1, p2, 0x1446316);
	}

	-(void) controlTextDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1446416);
	}

	-(void) controlTextDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1446516);
	}

	-(NSInteger) ruleEditor:(NSRuleEditor *)p0 numberOfChildrenForCriterion:(NSObject *)p1 withRowType:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_229 (self, _cmd, &managed_method, p0, p1, p2, 0x1446616);
	}

	-(NSDictionary *) ruleEditor:(NSRuleEditor *)p0 predicatePartsForCriterion:(NSObject *)p1 withDisplayValue:(NSObject *)p2 inRow:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_230 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1446716);
	}

	-(void) ruleEditorRowsDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1446816);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1446016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSavePanel__NSOpenSavePanelDelegate : NSObject<NSOpenSavePanelDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSInteger) panel:(NSSavePanel *)p0 compareFilename:(NSString *)p1 with:(NSString *)p2 caseSensitive:(BOOL)p3;
	-(void) panel:(NSSavePanel *)p0 didChangeToDirectoryURL:(NSURL *)p1;
	-(void) panel:(NSSavePanel *)p0 directoryDidChange:(NSString *)p1;
	-(BOOL) panel:(NSSavePanel *)p0 isValidFilename:(NSString *)p1;
	-(void) panelSelectionDidChange:(NSSavePanel *)p0;
	-(BOOL) panel:(NSSavePanel *)p0 shouldEnableURL:(NSURL *)p1;
	-(BOOL) panel:(NSSavePanel *)p0 shouldShowFilename:(NSString *)p1;
	-(NSString *) panel:(NSSavePanel *)p0 userEnteredFilename:(NSString *)p1 confirmed:(BOOL)p2;
	-(BOOL) panel:(NSSavePanel *)p0 validateURL:(NSURL *)p1 error:(NSError **)p2;
	-(void) panel:(NSSavePanel *)p0 willExpand:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSavePanel__NSOpenSavePanelDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSInteger) panel:(NSSavePanel *)p0 compareFilename:(NSString *)p1 with:(NSString *)p2 caseSensitive:(BOOL)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_231 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1446C16);
	}

	-(void) panel:(NSSavePanel *)p0 didChangeToDirectoryURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_232 (self, _cmd, &managed_method, p0, p1, 0x1446D16);
	}

	-(void) panel:(NSSavePanel *)p0 directoryDidChange:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_233 (self, _cmd, &managed_method, p0, p1, 0x1446E16);
	}

	-(BOOL) panel:(NSSavePanel *)p0 isValidFilename:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_234 (self, _cmd, &managed_method, p0, p1, 0x1446F16);
	}

	-(void) panelSelectionDidChange:(NSSavePanel *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_235 (self, _cmd, &managed_method, p0, 0x1447016);
	}

	-(BOOL) panel:(NSSavePanel *)p0 shouldEnableURL:(NSURL *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_236 (self, _cmd, &managed_method, p0, p1, 0x1447116);
	}

	-(BOOL) panel:(NSSavePanel *)p0 shouldShowFilename:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_234 (self, _cmd, &managed_method, p0, p1, 0x1447216);
	}

	-(NSString *) panel:(NSSavePanel *)p0 userEnteredFilename:(NSString *)p1 confirmed:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_237 (self, _cmd, &managed_method, p0, p1, p2, 0x1447316);
	}

	-(BOOL) panel:(NSSavePanel *)p0 validateURL:(NSURL *)p1 error:(NSError **)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_238 (self, _cmd, &managed_method, p0, p1, p2, 0x1447416);
	}

	-(void) panel:(NSSavePanel *)p0 willExpand:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_239 (self, _cmd, &managed_method, p0, p1, 0x1447516);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1446B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSearchField__NSSearchFieldDelegate : AppKit_NSTextField__NSTextFieldDelegate<NSSearchFieldDelegate, NSTextFieldDelegate> {
}
	-(void) searchFieldDidEndSearching:(NSSearchField *)p0;
	-(void) searchFieldDidStartSearching:(NSSearchField *)p0;
	-(id) init;
@end

@implementation AppKit_NSSearchField__NSSearchFieldDelegate {
}

	-(void) searchFieldDidEndSearching:(NSSearchField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_240 (self, _cmd, &managed_method, p0, 0x1448316);
	}

	-(void) searchFieldDidStartSearching:(NSSearchField *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_240 (self, _cmd, &managed_method, p0, 0x1448416);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1448216);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSTextField__NSTextFieldDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSharingService__NSSharingServiceDelegate : NSObject<NSSharingServiceDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSView *) anchoringViewForSharingService:(NSSharingService *)p0 showRelativeToRect:(CGRect*)p1 preferredEdge:(NSUInteger*)p2;
	-(void) sharingService:(NSSharingService *)p0 didFailToShareItems:(NSArray *)p1 error:(NSError *)p2;
	-(void) sharingService:(NSSharingService *)p0 didShareItems:(NSArray *)p1;
	-(CGRect) sharingService:(NSSharingService *)p0 sourceFrameOnScreenForShareItem:(id)p1;
	-(NSWindow *) sharingService:(NSSharingService *)p0 sourceWindowForShareItems:(NSArray *)p1 sharingContentScope:(NSInteger)p2;
	-(NSImage *) sharingService:(NSSharingService *)p0 transitionImageForShareItem:(id)p1 contentRect:(CGRect)p2;
	-(void) sharingService:(NSSharingService *)p0 willShareItems:(NSArray *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSharingService__NSSharingServiceDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSView *) anchoringViewForSharingService:(NSSharingService *)p0 showRelativeToRect:(CGRect*)p1 preferredEdge:(NSUInteger*)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_241 (self, _cmd, &managed_method, p0, p1, p2, 0x1448616);
	}

	-(void) sharingService:(NSSharingService *)p0 didFailToShareItems:(NSArray *)p1 error:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_242 (self, _cmd, &managed_method, p0, p1, p2, 0x1448716);
	}

	-(void) sharingService:(NSSharingService *)p0 didShareItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_243 (self, _cmd, &managed_method, p0, p1, 0x1448816);
	}

	-(CGRect) sharingService:(NSSharingService *)p0 sourceFrameOnScreenForShareItem:(id)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_244 (self, _cmd, &managed_method, p0, p1, 0x1448916);
	}

	-(NSWindow *) sharingService:(NSSharingService *)p0 sourceWindowForShareItems:(NSArray *)p1 sharingContentScope:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_245 (self, _cmd, &managed_method, p0, p1, p2, 0x1448A16);
	}

	-(NSImage *) sharingService:(NSSharingService *)p0 transitionImageForShareItem:(id)p1 contentRect:(CGRect)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_246 (self, _cmd, &managed_method, p0, p1, p2, 0x1448B16);
	}

	-(void) sharingService:(NSSharingService *)p0 willShareItems:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_243 (self, _cmd, &managed_method, p0, p1, 0x1448C16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1448516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate : NSObject<NSSharingServicePickerDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(id) sharingServicePicker:(NSSharingServicePicker *)p0 delegateForSharingService:(NSSharingService *)p1;
	-(void) sharingServicePicker:(NSSharingServicePicker *)p0 didChooseSharingService:(NSSharingService *)p1;
	-(NSArray *) sharingServicePicker:(NSSharingServicePicker *)p0 sharingServicesForItems:(NSArray *)p1 proposedSharingServices:(NSArray *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(id) sharingServicePicker:(NSSharingServicePicker *)p0 delegateForSharingService:(NSSharingService *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_247 (self, _cmd, &managed_method, p0, p1, 0x1448E16);
	}

	-(void) sharingServicePicker:(NSSharingServicePicker *)p0 didChooseSharingService:(NSSharingService *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_248 (self, _cmd, &managed_method, p0, p1, 0x1448F16);
	}

	-(NSArray *) sharingServicePicker:(NSSharingServicePicker *)p0 sharingServicesForItems:(NSArray *)p1 proposedSharingServices:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_249 (self, _cmd, &managed_method, p0, p1, p2, 0x1449016);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1448D16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSSound__NSSoundDelegate : NSObject<NSSoundDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) sound:(NSSound *)p0 didFinishPlaying:(BOOL)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSSound__NSSoundDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) sound:(NSSound *)p0 didFinishPlaying:(BOOL)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_250 (self, _cmd, &managed_method, p0, p1, 0x144D416);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x144D316);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTableView__NSTableViewDelegate : NSObject<NSTableViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tableViewColumnDidMove:(NSNotification *)p0;
	-(void) tableViewColumnDidResize:(NSNotification *)p0;
	-(NSTableRowView *) tableView:(NSTableView *)p0 rowViewForRow:(NSInteger)p1;
	-(void) tableView:(NSTableView *)p0 didAddRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2;
	-(void) tableView:(NSTableView *)p0 didClickTableColumn:(NSTableColumn *)p1;
	-(void) tableView:(NSTableView *)p0 didDragTableColumn:(NSTableColumn *)p1;
	-(void) tableView:(NSTableView *)p0 didRemoveRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2;
	-(NSCell *) tableView:(NSTableView *)p0 dataCellForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(NSInteger) tableView:(NSTableView *)p0 nextTypeSelectMatchFromRow:(NSInteger)p1 toRow:(NSInteger)p2 forString:(NSString *)p3;
	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1;
	-(NSString *) tableView:(NSTableView *)p0 typeSelectStringForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(NSIndexSet *) tableView:(NSTableView *)p0 selectionIndexesForProposedSelection:(NSIndexSet *)p1;
	-(CGFloat) tableView:(NSTableView *)p0 sizeToFitWidthOfColumn:(NSInteger)p1;
	-(NSString *) tableView:(NSTableView *)p0 toolTipForCell:(NSCell *)p1 rect:(CGRect*)p2 tableColumn:(NSTableColumn *)p3 row:(NSInteger)p4 mouseLocation:(CGPoint)p5;
	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1;
	-(void) tableView:(NSTableView *)p0 mouseDownInHeaderOfTableColumn:(NSTableColumn *)p1;
	-(NSArray *) tableView:(NSTableView *)p0 rowActionsForRow:(NSInteger)p1 edge:(NSInteger)p2;
	-(void) tableViewSelectionDidChange:(NSNotification *)p0;
	-(void) tableViewSelectionIsChanging:(NSNotification *)p0;
	-(BOOL) selectionShouldChangeInTableView:(NSTableView *)p0;
	-(BOOL) tableView:(NSTableView *)p0 shouldEditTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldReorderColumn:(NSInteger)p1 toColumn:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1;
	-(BOOL) tableView:(NSTableView *)p0 shouldSelectTableColumn:(NSTableColumn *)p1;
	-(BOOL) tableView:(NSTableView *)p0 shouldShowCellExpansionForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2;
	-(BOOL) tableView:(NSTableView *)p0 shouldTrackCell:(NSCell *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3;
	-(BOOL) tableView:(NSTableView *)p0 shouldTypeSelectForEvent:(NSEvent *)p1 withCurrentSearchString:(NSString *)p2;
	-(void) tableView:(NSTableView *)p0 willDisplayCell:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTableView__NSTableViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tableViewColumnDidMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x144E816);
	}

	-(void) tableViewColumnDidResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x144E916);
	}

	-(NSTableRowView *) tableView:(NSTableView *)p0 rowViewForRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_251 (self, _cmd, &managed_method, p0, p1, 0x144EA16);
	}

	-(void) tableView:(NSTableView *)p0 didAddRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_252 (self, _cmd, &managed_method, p0, p1, p2, 0x144EB16);
	}

	-(void) tableView:(NSTableView *)p0 didClickTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_253 (self, _cmd, &managed_method, p0, p1, 0x144EC16);
	}

	-(void) tableView:(NSTableView *)p0 didDragTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_253 (self, _cmd, &managed_method, p0, p1, 0x144ED16);
	}

	-(void) tableView:(NSTableView *)p0 didRemoveRowView:(NSTableRowView *)p1 forRow:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_252 (self, _cmd, &managed_method, p0, p1, p2, 0x144EE16);
	}

	-(NSCell *) tableView:(NSTableView *)p0 dataCellForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_254 (self, _cmd, &managed_method, p0, p1, p2, 0x144EF16);
	}

	-(NSInteger) tableView:(NSTableView *)p0 nextTypeSelectMatchFromRow:(NSInteger)p1 toRow:(NSInteger)p2 forString:(NSString *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_255 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x144F016);
	}

	-(CGFloat) tableView:(NSTableView *)p0 heightOfRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_256 (self, _cmd, &managed_method, p0, p1, 0x144F116);
	}

	-(NSString *) tableView:(NSTableView *)p0 typeSelectStringForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_257 (self, _cmd, &managed_method, p0, p1, p2, 0x144F216);
	}

	-(NSIndexSet *) tableView:(NSTableView *)p0 selectionIndexesForProposedSelection:(NSIndexSet *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_258 (self, _cmd, &managed_method, p0, p1, 0x144F316);
	}

	-(CGFloat) tableView:(NSTableView *)p0 sizeToFitWidthOfColumn:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_256 (self, _cmd, &managed_method, p0, p1, 0x144F416);
	}

	-(NSString *) tableView:(NSTableView *)p0 toolTipForCell:(NSCell *)p1 rect:(CGRect*)p2 tableColumn:(NSTableColumn *)p3 row:(NSInteger)p4 mouseLocation:(CGPoint)p5
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_259 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, 0x144F516);
	}

	-(NSView *) tableView:(NSTableView *)p0 viewForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_260 (self, _cmd, &managed_method, p0, p1, p2, 0x144F616);
	}

	-(BOOL) tableView:(NSTableView *)p0 isGroupRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_261 (self, _cmd, &managed_method, p0, p1, 0x144F716);
	}

	-(void) tableView:(NSTableView *)p0 mouseDownInHeaderOfTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_253 (self, _cmd, &managed_method, p0, p1, 0x144F816);
	}

	-(NSArray *) tableView:(NSTableView *)p0 rowActionsForRow:(NSInteger)p1 edge:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_262 (self, _cmd, &managed_method, p0, p1, p2, 0x144F916);
	}

	-(void) tableViewSelectionDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x144FA16);
	}

	-(void) tableViewSelectionIsChanging:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x144FB16);
	}

	-(BOOL) selectionShouldChangeInTableView:(NSTableView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_263 (self, _cmd, &managed_method, p0, 0x144FC16);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldEditTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_264 (self, _cmd, &managed_method, p0, p1, p2, 0x144FD16);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldReorderColumn:(NSInteger)p1 toColumn:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_265 (self, _cmd, &managed_method, p0, p1, p2, 0x144FE16);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectRow:(NSInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_261 (self, _cmd, &managed_method, p0, p1, 0x144FF16);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldSelectTableColumn:(NSTableColumn *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_266 (self, _cmd, &managed_method, p0, p1, 0x1450016);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldShowCellExpansionForTableColumn:(NSTableColumn *)p1 row:(NSInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_264 (self, _cmd, &managed_method, p0, p1, p2, 0x1450116);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldTrackCell:(NSCell *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_267 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1450216);
	}

	-(BOOL) tableView:(NSTableView *)p0 shouldTypeSelectForEvent:(NSEvent *)p1 withCurrentSearchString:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_268 (self, _cmd, &managed_method, p0, p1, p2, 0x1450316);
	}

	-(void) tableView:(NSTableView *)p0 willDisplayCell:(NSObject *)p1 forTableColumn:(NSTableColumn *)p2 row:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_269 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1450416);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, 0x1450516);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x144E716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTabView__NSTabViewDelegate : NSObject<NSTabViewDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) tabView:(NSTabView *)p0 didSelectTabViewItem:(NSTabViewItem *)p1;
	-(void) tabViewDidChangeNumberOfTabViewItems:(NSTabView *)p0;
	-(BOOL) tabView:(NSTabView *)p0 shouldSelectTabViewItem:(NSTabViewItem *)p1;
	-(void) tabView:(NSTabView *)p0 willSelectTabViewItem:(NSTabViewItem *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTabView__NSTabViewDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) tabView:(NSTabView *)p0 didSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_270 (self, _cmd, &managed_method, p0, p1, 0x1451016);
	}

	-(void) tabViewDidChangeNumberOfTabViewItems:(NSTabView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_271 (self, _cmd, &managed_method, p0, 0x1451116);
	}

	-(BOOL) tabView:(NSTabView *)p0 shouldSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_272 (self, _cmd, &managed_method, p0, p1, 0x1451216);
	}

	-(void) tabView:(NSTabView *)p0 willSelectTabViewItem:(NSTabViewItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_270 (self, _cmd, &managed_method, p0, p1, 0x1451316);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1450F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSText__NSTextDelegate : NSObject<NSTextDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textDidBeginEditing:(NSNotification *)p0;
	-(void) textDidChange:(NSNotification *)p0;
	-(void) textDidEndEditing:(NSNotification *)p0;
	-(BOOL) textShouldBeginEditing:(NSText *)p0;
	-(BOOL) textShouldEndEditing:(NSText *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSText__NSTextDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textDidBeginEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1451516);
	}

	-(void) textDidChange:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1451616);
	}

	-(void) textDidEndEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1451716);
	}

	-(BOOL) textShouldBeginEditing:(NSText *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_273 (self, _cmd, &managed_method, p0, 0x1451816);
	}

	-(BOOL) textShouldEndEditing:(NSText *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_273 (self, _cmd, &managed_method, p0, 0x1451916);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1451416);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTextStorage__NSTextStorageDelegate : NSObject<NSTextStorageDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(void) textStorageDidProcessEditing:(NSNotification *)p0;
	-(void) textStorageWillProcessEditing:(NSNotification *)p0;
	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTextStorage__NSTextStorageDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) textStorage:(NSTextStorage *)p0 didProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_274 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1453616);
	}

	-(void) textStorageDidProcessEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1453716);
	}

	-(void) textStorageWillProcessEditing:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1453816);
	}

	-(void) textStorage:(NSTextStorage *)p0 willProcessEditing:(NSUInteger)p1 range:(NSRange)p2 changeInLength:(NSInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_274 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1453916);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1453516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTextView__NSTextViewDelegate : AppKit_NSText__NSTextDelegate<NSTextViewDelegate, NSTextDelegate> {
}
	-(void) textView:(NSTextView *)p0 clickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3;
	-(void) textView:(NSTextView *)p0 doubleClickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3;
	-(void) textViewDidChangeSelection:(NSNotification *)p0;
	-(void) textViewDidChangeTypingAttributes:(NSNotification *)p0;
	-(NSArray *) textView:(NSTextView *)p0 didCheckTextInRange:(NSRange)p1 types:(unsigned long long)p2 options:(NSDictionary *)p3 results:(NSArray *)p4 orthography:(NSOrthography *)p5 wordCount:(NSInteger)p6;
	-(BOOL) textView:(NSTextView *)p0 doCommandBySelector:(SEL)p1;
	-(void) textView:(NSTextView *)p0 draggedCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 event:(NSEvent *)p3;
	-(NSArray *) textView:(NSTextView *)p0 candidatesForSelectedRange:(NSRange)p1;
	-(NSArray *) textView:(NSTextView *)p0 completions:(NSArray *)p1 forPartialWordRange:(NSRange)p2 indexOfSelectedItem:(NSInteger*)p3;
	-(NSArray *) textView:(NSTextView *)p0 candidates:(NSArray *)p1 forSelectedRange:(NSRange)p2;
	-(NSUndoManager *) undoManagerForTextView:(NSTextView *)p0;
	-(NSArray *) textView:(NSTextView *)p0 writablePasteboardTypesForCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2;
	-(BOOL) textView:(NSTextView *)p0 clickedOnLink:(NSObject *)p1 atIndex:(NSUInteger)p2;
	-(NSMenu *) textView:(NSTextView *)p0 menu:(NSMenu *)p1 forEvent:(NSEvent *)p2 atIndex:(NSUInteger)p3;
	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementString:(NSString *)p2;
	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRanges:(NSArray *)p1 replacementStrings:(NSArray *)p2;
	-(NSDictionary *) textView:(NSTextView *)p0 shouldChangeTypingAttributes:(NSDictionary *)p1 toAttributes:(NSDictionary *)p2;
	-(BOOL) textView:(NSTextView *)p0 shouldSelectCandidateAtIndex:(NSUInteger)p1;
	-(NSInteger) textView:(NSTextView *)p0 shouldSetSpellingState:(NSInteger)p1 range:(NSRange)p2;
	-(NSArray *) textView:(NSTextView *)p0 shouldUpdateTouchBarItemIdentifiers:(NSArray *)p1;
	-(NSRange) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRange:(NSRange)p1 toCharacterRange:(NSRange)p2;
	-(NSArray *) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRanges:(NSArray *)p1 toCharacterRanges:(NSArray *)p2;
	-(NSDictionary *) textView:(NSTextView *)p0 willCheckTextInRange:(NSRange)p1 options:(NSDictionary *)p2 types:(unsigned long long)p3;
	-(NSString *) textView:(NSTextView *)p0 willDisplayToolTip:(NSString *)p1 forCharacterAtIndex:(NSUInteger)p2;
	-(BOOL) textView:(NSTextView *)p0 writeCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2 toPasteboard:(NSPasteboard *)p3 type:(NSString *)p4;
	-(BOOL) respondsToSelector:(SEL)p0;
	-(id) init;
@end

@implementation AppKit_NSTextView__NSTextViewDelegate {
}

	-(void) textView:(NSTextView *)p0 clickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_275 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1453F16);
	}

	-(void) textView:(NSTextView *)p0 doubleClickedOnCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_275 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1454016);
	}

	-(void) textViewDidChangeSelection:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1454116);
	}

	-(void) textViewDidChangeTypingAttributes:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1454216);
	}

	-(NSArray *) textView:(NSTextView *)p0 didCheckTextInRange:(NSRange)p1 types:(unsigned long long)p2 options:(NSDictionary *)p3 results:(NSArray *)p4 orthography:(NSOrthography *)p5 wordCount:(NSInteger)p6
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_276 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, p5, p6, 0x1454316);
	}

	-(BOOL) textView:(NSTextView *)p0 doCommandBySelector:(SEL)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_277 (self, _cmd, &managed_method, p0, p1, 0x1454416);
	}

	-(void) textView:(NSTextView *)p0 draggedCell:(NSTextAttachmentCell *)p1 inRect:(CGRect)p2 event:(NSEvent *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_278 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1454516);
	}

	-(NSArray *) textView:(NSTextView *)p0 candidatesForSelectedRange:(NSRange)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_279 (self, _cmd, &managed_method, p0, p1, 0x1454616);
	}

	-(NSArray *) textView:(NSTextView *)p0 completions:(NSArray *)p1 forPartialWordRange:(NSRange)p2 indexOfSelectedItem:(NSInteger*)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_280 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1454716);
	}

	-(NSArray *) textView:(NSTextView *)p0 candidates:(NSArray *)p1 forSelectedRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_281 (self, _cmd, &managed_method, p0, p1, p2, 0x1454816);
	}

	-(NSUndoManager *) undoManagerForTextView:(NSTextView *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_282 (self, _cmd, &managed_method, p0, 0x1454916);
	}

	-(NSArray *) textView:(NSTextView *)p0 writablePasteboardTypesForCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_283 (self, _cmd, &managed_method, p0, p1, p2, 0x1454A16);
	}

	-(BOOL) textView:(NSTextView *)p0 clickedOnLink:(NSObject *)p1 atIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_284 (self, _cmd, &managed_method, p0, p1, p2, 0x1454B16);
	}

	-(NSMenu *) textView:(NSTextView *)p0 menu:(NSMenu *)p1 forEvent:(NSEvent *)p2 atIndex:(NSUInteger)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_285 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1454C16);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRange:(NSRange)p1 replacementString:(NSString *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_286 (self, _cmd, &managed_method, p0, p1, p2, 0x1454D16);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldChangeTextInRanges:(NSArray *)p1 replacementStrings:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_287 (self, _cmd, &managed_method, p0, p1, p2, 0x1454E16);
	}

	-(NSDictionary *) textView:(NSTextView *)p0 shouldChangeTypingAttributes:(NSDictionary *)p1 toAttributes:(NSDictionary *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_288 (self, _cmd, &managed_method, p0, p1, p2, 0x1454F16);
	}

	-(BOOL) textView:(NSTextView *)p0 shouldSelectCandidateAtIndex:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_289 (self, _cmd, &managed_method, p0, p1, 0x1455016);
	}

	-(NSInteger) textView:(NSTextView *)p0 shouldSetSpellingState:(NSInteger)p1 range:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_290 (self, _cmd, &managed_method, p0, p1, p2, 0x1455116);
	}

	-(NSArray *) textView:(NSTextView *)p0 shouldUpdateTouchBarItemIdentifiers:(NSArray *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_291 (self, _cmd, &managed_method, p0, p1, 0x1455216);
	}

	-(NSRange) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRange:(NSRange)p1 toCharacterRange:(NSRange)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_292 (self, _cmd, &managed_method, p0, p1, p2, 0x1455316);
	}

	-(NSArray *) textView:(NSTextView *)p0 willChangeSelectionFromCharacterRanges:(NSArray *)p1 toCharacterRanges:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_293 (self, _cmd, &managed_method, p0, p1, p2, 0x1455416);
	}

	-(NSDictionary *) textView:(NSTextView *)p0 willCheckTextInRange:(NSRange)p1 options:(NSDictionary *)p2 types:(unsigned long long)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_294 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x1455516);
	}

	-(NSString *) textView:(NSTextView *)p0 willDisplayToolTip:(NSString *)p1 forCharacterAtIndex:(NSUInteger)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_295 (self, _cmd, &managed_method, p0, p1, p2, 0x1455616);
	}

	-(BOOL) textView:(NSTextView *)p0 writeCell:(NSTextAttachmentCell *)p1 atIndex:(NSUInteger)p2 toPasteboard:(NSPasteboard *)p3 type:(NSString *)p4
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_296 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x1455716);
	}

	-(BOOL) respondsToSelector:(SEL)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_191 (self, _cmd, &managed_method, p0, 0x1455816);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1453E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [AppKit_NSText__NSTextDelegate class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSToolbar__NSToolbarDelegate : NSObject<NSToolbarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0;
	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0;
	-(void) toolbarDidRemoveItem:(NSNotification *)p0;
	-(NSArray *) toolbarSelectableItemIdentifiers:(NSToolbar *)p0;
	-(void) toolbarWillAddItem:(NSNotification *)p0;
	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSToolbar__NSToolbarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) toolbarAllowedItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_297 (self, _cmd, &managed_method, p0, 0x1456116);
	}

	-(NSArray *) toolbarDefaultItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_297 (self, _cmd, &managed_method, p0, 0x1456216);
	}

	-(void) toolbarDidRemoveItem:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1456316);
	}

	-(NSArray *) toolbarSelectableItemIdentifiers:(NSToolbar *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_297 (self, _cmd, &managed_method, p0, 0x1456416);
	}

	-(void) toolbarWillAddItem:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x1456516);
	}

	-(NSToolbarItem *) toolbar:(NSToolbar *)p0 itemForItemIdentifier:(NSString *)p1 willBeInsertedIntoToolbar:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_298 (self, _cmd, &managed_method, p0, p1, p2, 0x1456616);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1456016);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSTouchBar__NSTouchBarDelegate : NSObject<NSTouchBarDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSTouchBarItem *) touchBar:(NSTouchBar *)p0 makeItemForIdentifier:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSTouchBar__NSTouchBarDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSTouchBarItem *) touchBar:(NSTouchBar *)p0 makeItemForIdentifier:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_299 (self, _cmd, &managed_method, p0, p1, 0x1456C16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1456B16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface AppKit_NSWindow__NSWindowDelegate : NSObject<NSWindowDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSArray *) customWindowsToEnterFullScreenForWindow:(NSWindow *)p0;
	-(NSArray *) customWindowsToExitFullScreenForWindow:(NSWindow *)p0;
	-(void) windowDidBecomeKey:(NSNotification *)p0;
	-(void) windowDidBecomeMain:(NSNotification *)p0;
	-(void) windowDidChangeBackingProperties:(NSNotification *)p0;
	-(void) windowDidChangeScreen:(NSNotification *)p0;
	-(void) windowDidChangeScreenProfile:(NSNotification *)p0;
	-(void) window:(NSWindow *)p0 didDecodeRestorableState:(NSCoder *)p1;
	-(void) windowDidDeminiaturize:(NSNotification *)p0;
	-(void) windowDidEndLiveResize:(NSNotification *)p0;
	-(void) windowDidEndSheet:(NSNotification *)p0;
	-(void) windowDidEnterFullScreen:(NSNotification *)p0;
	-(void) windowDidEnterVersionBrowser:(NSNotification *)p0;
	-(void) windowDidExitFullScreen:(NSNotification *)p0;
	-(void) windowDidExitVersionBrowser:(NSNotification *)p0;
	-(void) windowDidExpose:(NSNotification *)p0;
	-(void) windowDidFailToEnterFullScreen:(NSWindow *)p0;
	-(void) windowDidFailToExitFullScreen:(NSWindow *)p0;
	-(void) windowDidMiniaturize:(NSNotification *)p0;
	-(void) windowDidMove:(NSNotification *)p0;
	-(void) windowDidResignKey:(NSNotification *)p0;
	-(void) windowDidResignMain:(NSNotification *)p0;
	-(void) windowDidResize:(NSNotification *)p0;
	-(void) windowDidUpdate:(NSNotification *)p0;
	-(BOOL) window:(NSWindow *)p0 shouldDragDocumentWithEvent:(NSEvent *)p1 from:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3;
	-(BOOL) window:(NSWindow *)p0 shouldPopUpDocumentPathMenu:(NSMenu *)p1;
	-(BOOL) windowShouldZoom:(NSWindow *)p0 toFrame:(CGRect)p1;
	-(void) window:(NSWindow *)p0 startCustomAnimationToEnterFullScreenWithDuration:(double)p1;
	-(void) window:(NSWindow *)p0 startCustomAnimationToExitFullScreenWithDuration:(double)p1;
	-(void) windowWillBeginSheet:(NSNotification *)p0;
	-(void) windowWillClose:(NSNotification *)p0;
	-(void) window:(NSWindow *)p0 willEncodeRestorableState:(NSCoder *)p1;
	-(void) windowWillEnterFullScreen:(NSNotification *)p0;
	-(void) windowWillEnterVersionBrowser:(NSNotification *)p0;
	-(void) windowWillExitFullScreen:(NSNotification *)p0;
	-(void) windowWillExitVersionBrowser:(NSNotification *)p0;
	-(void) windowWillMiniaturize:(NSNotification *)p0;
	-(void) windowWillMove:(NSNotification *)p0;
	-(CGRect) window:(NSWindow *)p0 willPositionSheet:(NSWindow *)p1 usingRect:(CGRect)p2;
	-(CGSize) windowWillResize:(NSWindow *)p0 toSize:(CGSize)p1;
	-(CGSize) window:(NSWindow *)p0 willResizeForVersionBrowserWithMaxPreferredSize:(CGSize)p1 maxAllowedSize:(CGSize)p2;
	-(NSObject *) windowWillReturnFieldEditor:(NSWindow *)p0 toObject:(NSObject *)p1;
	-(NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)p0;
	-(void) windowWillStartLiveResize:(NSNotification *)p0;
	-(CGSize) window:(NSWindow *)p0 willUseFullScreenContentSize:(CGSize)p1;
	-(NSUInteger) window:(NSWindow *)p0 willUseFullScreenPresentationOptions:(NSUInteger)p1;
	-(CGRect) windowWillUseStandardFrame:(NSWindow *)p0 defaultFrame:(CGRect)p1;
	-(BOOL) windowShouldClose:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation AppKit_NSWindow__NSWindowDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSArray *) customWindowsToEnterFullScreenForWindow:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_300 (self, _cmd, &managed_method, p0, 0x145BA16);
	}

	-(NSArray *) customWindowsToExitFullScreenForWindow:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_300 (self, _cmd, &managed_method, p0, 0x145BB16);
	}

	-(void) windowDidBecomeKey:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145BC16);
	}

	-(void) windowDidBecomeMain:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145BD16);
	}

	-(void) windowDidChangeBackingProperties:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145BE16);
	}

	-(void) windowDidChangeScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145BF16);
	}

	-(void) windowDidChangeScreenProfile:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C016);
	}

	-(void) window:(NSWindow *)p0 didDecodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_301 (self, _cmd, &managed_method, p0, p1, 0x145C116);
	}

	-(void) windowDidDeminiaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C216);
	}

	-(void) windowDidEndLiveResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C316);
	}

	-(void) windowDidEndSheet:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C416);
	}

	-(void) windowDidEnterFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C516);
	}

	-(void) windowDidEnterVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C616);
	}

	-(void) windowDidExitFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C716);
	}

	-(void) windowDidExitVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C816);
	}

	-(void) windowDidExpose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145C916);
	}

	-(void) windowDidFailToEnterFullScreen:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_302 (self, _cmd, &managed_method, p0, 0x145CA16);
	}

	-(void) windowDidFailToExitFullScreen:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_302 (self, _cmd, &managed_method, p0, 0x145CB16);
	}

	-(void) windowDidMiniaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145CC16);
	}

	-(void) windowDidMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145CD16);
	}

	-(void) windowDidResignKey:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145CE16);
	}

	-(void) windowDidResignMain:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145CF16);
	}

	-(void) windowDidResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145D016);
	}

	-(void) windowDidUpdate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145D116);
	}

	-(BOOL) window:(NSWindow *)p0 shouldDragDocumentWithEvent:(NSEvent *)p1 from:(CGPoint)p2 withPasteboard:(NSPasteboard *)p3
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_303 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x145D216);
	}

	-(BOOL) window:(NSWindow *)p0 shouldPopUpDocumentPathMenu:(NSMenu *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_304 (self, _cmd, &managed_method, p0, p1, 0x145D316);
	}

	-(BOOL) windowShouldZoom:(NSWindow *)p0 toFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_305 (self, _cmd, &managed_method, p0, p1, 0x145D416);
	}

	-(void) window:(NSWindow *)p0 startCustomAnimationToEnterFullScreenWithDuration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_306 (self, _cmd, &managed_method, p0, p1, 0x145D516);
	}

	-(void) window:(NSWindow *)p0 startCustomAnimationToExitFullScreenWithDuration:(double)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_306 (self, _cmd, &managed_method, p0, p1, 0x145D616);
	}

	-(void) windowWillBeginSheet:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145D716);
	}

	-(void) windowWillClose:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145D816);
	}

	-(void) window:(NSWindow *)p0 willEncodeRestorableState:(NSCoder *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_301 (self, _cmd, &managed_method, p0, p1, 0x145D916);
	}

	-(void) windowWillEnterFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DA16);
	}

	-(void) windowWillEnterVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DB16);
	}

	-(void) windowWillExitFullScreen:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DC16);
	}

	-(void) windowWillExitVersionBrowser:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DD16);
	}

	-(void) windowWillMiniaturize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DE16);
	}

	-(void) windowWillMove:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145DF16);
	}

	-(CGRect) window:(NSWindow *)p0 willPositionSheet:(NSWindow *)p1 usingRect:(CGRect)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_307 (self, _cmd, &managed_method, p0, p1, p2, 0x145E016);
	}

	-(CGSize) windowWillResize:(NSWindow *)p0 toSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_308 (self, _cmd, &managed_method, p0, p1, 0x145E116);
	}

	-(CGSize) window:(NSWindow *)p0 willResizeForVersionBrowserWithMaxPreferredSize:(CGSize)p1 maxAllowedSize:(CGSize)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_309 (self, _cmd, &managed_method, p0, p1, p2, 0x145E216);
	}

	-(NSObject *) windowWillReturnFieldEditor:(NSWindow *)p0 toObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_310 (self, _cmd, &managed_method, p0, p1, 0x145E316);
	}

	-(NSUndoManager *) windowWillReturnUndoManager:(NSWindow *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_311 (self, _cmd, &managed_method, p0, 0x145E416);
	}

	-(void) windowWillStartLiveResize:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x145E516);
	}

	-(CGSize) window:(NSWindow *)p0 willUseFullScreenContentSize:(CGSize)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_308 (self, _cmd, &managed_method, p0, p1, 0x145E616);
	}

	-(NSUInteger) window:(NSWindow *)p0 willUseFullScreenPresentationOptions:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_312 (self, _cmd, &managed_method, p0, p1, 0x145E716);
	}

	-(CGRect) windowWillUseStandardFrame:(NSWindow *)p0 defaultFrame:(CGRect)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_313 (self, _cmd, &managed_method, p0, p1, 0x145E816);
	}

	-(BOOL) windowShouldClose:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_314 (self, _cmd, &managed_method, p0, 0x145E916);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x145B916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSUrlSessionHandler_WrappedNSInputStream : NSInputStream {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSUInteger) streamStatus;
	-(void) open;
	-(void) close;
	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1;
	-(BOOL) hasBytesAvailable;
	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1;
	-(NSObject *) propertyForKey:(NSString *)p0;
	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1;
	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2;
	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSUrlSessionHandler_WrappedNSInputStream {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSUInteger) streamStatus
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_315 (self, _cmd, &managed_method, 0x146EF16);
	}

	-(void) open
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x146F016);
	}

	-(void) close
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x146F116);
	}

	-(NSInteger) read:(void *)p0 maxLength:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_316 (self, _cmd, &managed_method, p0, p1, 0x146F216);
	}

	-(BOOL) hasBytesAvailable
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_11 (self, _cmd, &managed_method, 0x146F316);
	}

	-(BOOL) getBuffer:(void **)p0 length:(NSUInteger*)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_317 (self, _cmd, &managed_method, p0, p1, 0x146F416);
	}

	-(NSObject *) propertyForKey:(NSString *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_318 (self, _cmd, &managed_method, p0, 0x146F516);
	}

	-(BOOL) setProperty:(NSObject *)p0 forKey:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_319 (self, _cmd, &managed_method, p0, p1, 0x146F616);
	}

	-(BOOL) _setCFClientFlags:(NSUInteger)p0 callback:(void *)p1 context:(void *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_320 (self, _cmd, &managed_method, p0, p1, p2, 0x146F716);
	}

	-(void) scheduleInRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_321 (self, _cmd, &managed_method, p0, p1, 0x146F816);
	}

	-(void) removeFromRunLoop:(NSRunLoop *)p0 forMode:(NSString *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_321 (self, _cmd, &managed_method, p0, p1, 0x146F916);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@interface Foundation_NSCache__NSCacheDelegate : NSObject<NSCacheDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSCache__NSCacheDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) cache:(NSCache *)p0 willEvictObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_322 (self, _cmd, &managed_method, p0, p1, 0x1470816);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1470716);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate : NSObject<NSKeyedArchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1;
	-(void) archiverDidFinish:(NSKeyedArchiver *)p0;
	-(void) archiverWillFinish:(NSKeyedArchiver *)p0;
	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) archiver:(NSKeyedArchiver *)p0 didEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_323 (self, _cmd, &managed_method, p0, p1, 0x1477A16);
	}

	-(void) archiverDidFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_324 (self, _cmd, &managed_method, p0, 0x1477B16);
	}

	-(void) archiverWillFinish:(NSKeyedArchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_324 (self, _cmd, &managed_method, p0, 0x1477C16);
	}

	-(void) archiver:(NSKeyedArchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_325 (self, _cmd, &managed_method, p0, p1, p2, 0x1477D16);
	}

	-(NSObject *) archiver:(NSKeyedArchiver *)p0 willEncodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_326 (self, _cmd, &managed_method, p0, p1, 0x1477E16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1477916);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate : NSObject<NSKeyedUnarchiverDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2;
	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1;
	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0;
	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(Class) unarchiver:(NSKeyedUnarchiver *)p0 cannotDecodeObjectOfClassName:(NSString *)p1 originalClasses:(NSArray *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_327 (self, _cmd, &managed_method, p0, p1, p2, 0x1478016);
	}

	-(NSObject *) unarchiver:(NSKeyedUnarchiver *)p0 didDecodeObject:(NSObject *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_328 (self, _cmd, &managed_method, p0, p1, 0x1478116);
	}

	-(void) unarchiverDidFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_329 (self, _cmd, &managed_method, p0, 0x1478216);
	}

	-(void) unarchiverWillFinish:(NSKeyedUnarchiver *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_329 (self, _cmd, &managed_method, p0, 0x1478316);
	}

	-(void) unarchiver:(NSKeyedUnarchiver *)p0 willReplaceObject:(NSObject *)p1 withObject:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_330 (self, _cmd, &managed_method, p0, p1, p2, 0x1478416);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1477F16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSMetadataQuery__NSMetadataQueryDelegate : NSObject<NSMetadataQueryDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1;
	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSMetadataQuery__NSMetadataQueryDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementObjectForResultObject:(NSMetadataItem *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_331 (self, _cmd, &managed_method, p0, p1, 0x1478F16);
	}

	-(NSObject *) metadataQuery:(NSMetadataQuery *)p0 replacementValueForAttribute:(NSString *)p1 value:(NSObject *)p2
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_332 (self, _cmd, &managed_method, p0, p1, p2, 0x1479016);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1478E16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSNetService__NSNetServiceDelegate : NSObject<NSNetServiceDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) netServiceDidResolveAddress:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2;
	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1;
	-(void) netServiceDidPublish:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1;
	-(void) netServiceDidStop:(NSNetService *)p0;
	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1;
	-(void) netServiceWillPublish:(NSNetService *)p0;
	-(void) netServiceWillResolve:(NSNetService *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetService__NSNetServiceDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) netServiceDidResolveAddress:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147AC16);
	}

	-(void) netService:(NSNetService *)p0 didAcceptConnectionWithInputStream:(NSInputStream *)p1 outputStream:(NSOutputStream *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_334 (self, _cmd, &managed_method, p0, p1, p2, 0x147AD16);
	}

	-(void) netService:(NSNetService *)p0 didNotPublish:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_335 (self, _cmd, &managed_method, p0, p1, 0x147AE16);
	}

	-(void) netServiceDidPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147AF16);
	}

	-(void) netService:(NSNetService *)p0 didNotResolve:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_335 (self, _cmd, &managed_method, p0, p1, 0x147B016);
	}

	-(void) netServiceDidStop:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147B116);
	}

	-(void) netService:(NSNetService *)p0 didUpdateTXTRecordData:(NSData *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_336 (self, _cmd, &managed_method, p0, p1, 0x147B216);
	}

	-(void) netServiceWillPublish:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147B316);
	}

	-(void) netServiceWillResolve:(NSNetService *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_333 (self, _cmd, &managed_method, p0, 0x147B416);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x147AB16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate : NSObject<NSNetServiceBrowserDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1;
	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0;
	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_337 (self, _cmd, &managed_method, p0, p1, p2, 0x147B616);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindDomain:(NSString *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_337 (self, _cmd, &managed_method, p0, p1, p2, 0x147B716);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didFindService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_338 (self, _cmd, &managed_method, p0, p1, p2, 0x147B816);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didNotSearch:(NSDictionary *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_339 (self, _cmd, &managed_method, p0, p1, 0x147B916);
	}

	-(void) netServiceBrowserWillSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_340 (self, _cmd, &managed_method, p0, 0x147BA16);
	}

	-(void) netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_340 (self, _cmd, &managed_method, p0, 0x147BB16);
	}

	-(void) netServiceBrowser:(NSNetServiceBrowser *)p0 didRemoveService:(NSNetService *)p1 moreComing:(BOOL)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_338 (self, _cmd, &managed_method, p0, p1, p2, 0x147BC16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x147B516);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __NSObject_Disposer : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	+(void) drain:(NSObject *)p0;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation __NSObject_Disposer {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	+(void) drain:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_341 (self, _cmd, &managed_method, p0, 0x147C016);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x147BE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface __XamarinObjectObserver : NSObject {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation __XamarinObjectObserver {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) observeValueForKeyPath:(NSString *)p0 ofObject:(NSObject *)p1 change:(NSDictionary *)p2 context:(void *)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_342 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x147C316);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@interface Foundation_NSStream__NSStreamDelegate : NSObject<NSStreamDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSStream__NSStreamDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) stream:(NSStream *)p0 handleEvent:(NSUInteger)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_343 (self, _cmd, &managed_method, p0, p1, 0x147DF16);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x147DE16);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSThread_ActionThread : NSThread {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) main;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSThread_ActionThread {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) main
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x147E716);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@interface Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate : NSObject<NSUserNotificationCenterDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didActivateNotification:(NSUserNotification *)p1;
	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didDeliverNotification:(NSUserNotification *)p1;
	-(BOOL) userNotificationCenter:(NSUserNotificationCenter *)p0 shouldPresentNotification:(NSUserNotification *)p1;
	-(BOOL) conformsToProtocol:(void *)p0;
	-(id) init;
@end

@implementation Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didActivateNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_344 (self, _cmd, &managed_method, p0, p1, 0x1483716);
	}

	-(void) userNotificationCenter:(NSUserNotificationCenter *)p0 didDeliverNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_344 (self, _cmd, &managed_method, p0, p1, 0x1483816);
	}

	-(BOOL) userNotificationCenter:(NSUserNotificationCenter *)p0 shouldPresentNotification:(NSUserNotification *)p1
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_345 (self, _cmd, &managed_method, p0, p1, 0x1483916);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x1483616);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@interface Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate : NSObject<NSURLSessionDataDelegate, NSURLSessionTaskDelegate, NSURLSessionDelegate> {
}
	-(void) release;
	-(id) retain;
	-(int) xamarinGetGCHandle;
	-(void) xamarinSetGCHandle: (int) gchandle;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(id)p3;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2;
	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(id)p3;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(id)p4;
	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(id)p3;
	-(BOOL) conformsToProtocol:(void *)p0;
@end

@implementation Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveResponse:(NSURLResponse *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_346 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x146BD16);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 didReceiveData:(NSData *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_347 (self, _cmd, &managed_method, p0, p1, p2, 0x146BE16);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didCompleteWithError:(NSError *)p2
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_348 (self, _cmd, &managed_method, p0, p1, p2, 0x146BF16);
	}

	-(void) URLSession:(NSURLSession *)p0 dataTask:(NSURLSessionDataTask *)p1 willCacheResponse:(NSCachedURLResponse *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_349 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x146C116);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 willPerformHTTPRedirection:(NSHTTPURLResponse *)p2 newRequest:(NSURLRequest *)p3 completionHandler:(id)p4
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_350 (self, _cmd, &managed_method, p0, p1, p2, p3, p4, 0x146C216);
	}

	-(void) URLSession:(NSURLSession *)p0 task:(NSURLSessionTask *)p1 didReceiveChallenge:(NSURLAuthenticationChallenge *)p2 completionHandler:(id)p3
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_351 (self, _cmd, &managed_method, p0, p1, p2, p3, 0x146C316);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

@implementation AppDelegate {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(void) applicationDidFinishLaunching:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x31A);
	}

	-(void) applicationWillTerminate:(NSNotification *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_13 (self, _cmd, &managed_method, p0, 0x41A);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}

	-(id) init
	{
		static MonoMethod *managed_method = NULL;
		bool call_super = false;
		id rv = native_to_managed_trampoline_1 (self, _cmd, &managed_method, &call_super, 0x21A);
		if (call_super && rv) {
			struct objc_super super = {  rv, [NSObject class] };
			rv = ((id (*)(objc_super*, SEL)) objc_msgSendSuper) (&super, @selector (init));
		}
		return rv;
	}
@end

@implementation ViewController {
	XamarinObject __monoObjectGCHandle;
}
	-(void) release
	{
		xamarin_release_trampoline (self, _cmd);
	}

	-(id) retain
	{
		return xamarin_retain_trampoline (self, _cmd);
	}

	-(int) xamarinGetGCHandle
	{
		return __monoObjectGCHandle.gc_handle;
	}

	-(void) xamarinSetGCHandle: (int) gc_handle
	{
		__monoObjectGCHandle.gc_handle = gc_handle;
		__monoObjectGCHandle.native_object = self;
	}


	-(NSImageView *) RayTracerImageView
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_352 (self, _cmd, &managed_method, 0xB1A);
	}

	-(void) setRayTracerImageView:(NSImageView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_353 (self, _cmd, &managed_method, p0, 0xC1A);
	}

	-(NSView *) RayTracerView
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_354 (self, _cmd, &managed_method, 0xD1A);
	}

	-(void) setRayTracerView:(NSView *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_355 (self, _cmd, &managed_method, p0, 0xE1A);
	}

	-(void) viewDidAppear
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_14 (self, _cmd, &managed_method, 0x61A);
	}

	-(NSObject *) representedObject
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_356 (self, _cmd, &managed_method, 0x71A);
	}

	-(void) setRepresentedObject:(NSObject *)p0
	{
		static MonoMethod *managed_method = NULL;
		native_to_managed_trampoline_9 (self, _cmd, &managed_method, p0, 0x81A);
	}

	-(BOOL) conformsToProtocol:(void *)p0
	{
		static MonoMethod *managed_method = NULL;
		return native_to_managed_trampoline_3 (self, _cmd, &managed_method, p0, 0x11B3E16);
	}
@end

	static MTClassMap __xamarin_class_map [] = {
		{ NULL, 0x179216 /* #0 'NSObject' => 'Foundation.NSObject, Xamarin.Mac' */ },
		{ NULL, 0x11E16 /* #1 'VSAccountManager' => 'VideoSubscriberAccount.VSAccountManager, Xamarin.Mac' */ },
		{ NULL, 0x12316 /* #2 'VSAccountManagerDelegate' => 'VideoSubscriberAccount.VSAccountManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12416 /* #3 'VSAccountManagerResult' => 'VideoSubscriberAccount.VSAccountManagerResult, Xamarin.Mac' */ },
		{ NULL, 0x12516 /* #4 'VSAccountMetadata' => 'VideoSubscriberAccount.VSAccountMetadata, Xamarin.Mac' */ },
		{ NULL, 0x12616 /* #5 'VSAccountMetadataRequest' => 'VideoSubscriberAccount.VSAccountMetadataRequest, Xamarin.Mac' */ },
		{ NULL, 0x12916 /* #6 'VSAccountProviderResponse' => 'VideoSubscriberAccount.VSAccountProviderResponse, Xamarin.Mac' */ },
		{ NULL, 0x12F16 /* #7 'VSSubscription' => 'VideoSubscriberAccount.VSSubscription, Xamarin.Mac' */ },
		{ NULL, 0x13116 /* #8 'VSSubscriptionRegistrationCenter' => 'VideoSubscriberAccount.VSSubscriptionRegistrationCenter, Xamarin.Mac' */ },
		{ NULL, 0x14A16 /* #9 'UNNotificationTrigger' => 'UserNotifications.UNNotificationTrigger, Xamarin.Mac' */ },
		{ NULL, 0x13516 /* #10 'UNCalendarNotificationTrigger' => 'UserNotifications.UNCalendarNotificationTrigger, Xamarin.Mac' */ },
		{ NULL, 0x14216 /* #11 'UNNotificationContent' => 'UserNotifications.UNNotificationContent, Xamarin.Mac' */ },
		{ NULL, 0x13816 /* #12 'UNMutableNotificationContent' => 'UserNotifications.UNMutableNotificationContent, Xamarin.Mac' */ },
		{ NULL, 0x13916 /* #13 'UNNotification' => 'UserNotifications.UNNotification, Xamarin.Mac' */ },
		{ NULL, 0x13A16 /* #14 'UNNotificationAction' => 'UserNotifications.UNNotificationAction, Xamarin.Mac' */ },
		{ NULL, 0x13D16 /* #15 'UNNotificationAttachment' => 'UserNotifications.UNNotificationAttachment, Xamarin.Mac' */ },
		{ NULL, 0x14016 /* #16 'UNNotificationCategory' => 'UserNotifications.UNNotificationCategory, Xamarin.Mac' */ },
		{ NULL, 0x14416 /* #17 'UNNotificationRequest' => 'UserNotifications.UNNotificationRequest, Xamarin.Mac' */ },
		{ NULL, 0x14516 /* #18 'UNNotificationResponse' => 'UserNotifications.UNNotificationResponse, Xamarin.Mac' */ },
		{ NULL, 0x14616 /* #19 'UNNotificationServiceExtension' => 'UserNotifications.UNNotificationServiceExtension, Xamarin.Mac' */ },
		{ NULL, 0x14816 /* #20 'UNNotificationSettings' => 'UserNotifications.UNNotificationSettings, Xamarin.Mac' */ },
		{ NULL, 0x14916 /* #21 'UNNotificationSound' => 'UserNotifications.UNNotificationSound, Xamarin.Mac' */ },
		{ NULL, 0x14B16 /* #22 'UNPushNotificationTrigger' => 'UserNotifications.UNPushNotificationTrigger, Xamarin.Mac' */ },
		{ NULL, 0x14D16 /* #23 'UNTextInputNotificationAction' => 'UserNotifications.UNTextInputNotificationAction, Xamarin.Mac' */ },
		{ NULL, 0x14E16 /* #24 'UNTextInputNotificationResponse' => 'UserNotifications.UNTextInputNotificationResponse, Xamarin.Mac' */ },
		{ NULL, 0x14F16 /* #25 'UNTimeIntervalNotificationTrigger' => 'UserNotifications.UNTimeIntervalNotificationTrigger, Xamarin.Mac' */ },
		{ NULL, 0x15416 /* #26 'UNUserNotificationCenterDelegate' => 'UserNotifications.UNUserNotificationCenterDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20216 /* #27 'WebScriptObject' => 'WebKit.WebScriptObject, Xamarin.Mac' */ },
		{ NULL, 0x1D316 /* #28 'DOMObject' => 'WebKit.DomObject, Xamarin.Mac' */ },
		{ NULL, 0x17116 /* #29 'DOMAbstractView' => 'WebKit.DomAbstractView, Xamarin.Mac' */ },
		{ NULL, 0x1CD16 /* #30 'DOMNode' => 'WebKit.DomNode, Xamarin.Mac' */ },
		{ NULL, 0x17216 /* #31 'DOMAttr' => 'WebKit.DomAttr, Xamarin.Mac' */ },
		{ NULL, 0x17316 /* #32 'DOMBlob' => 'WebKit.DomBlob, Xamarin.Mac' */ },
		{ NULL, 0x17516 /* #33 'DOMCharacterData' => 'WebKit.DomCharacterData, Xamarin.Mac' */ },
		{ NULL, 0x1DA16 /* #34 'DOMText' => 'WebKit.DomText, Xamarin.Mac' */ },
		{ NULL, 0x17416 /* #35 'DOMCDATASection' => 'WebKit.DomCDataSection, Xamarin.Mac' */ },
		{ NULL, 0x17616 /* #36 'DOMComment' => 'WebKit.DomComment, Xamarin.Mac' */ },
		{ NULL, 0x17B16 /* #37 'DOMCSSRule' => 'WebKit.DomCssRule, Xamarin.Mac' */ },
		{ NULL, 0x17716 /* #38 'DOMCSSCharsetRule' => 'WebKit.DomCssCharsetRule, Xamarin.Mac' */ },
		{ NULL, 0x17816 /* #39 'DOMCSSFontFaceRule' => 'WebKit.DomCssFontFaceRule, Xamarin.Mac' */ },
		{ NULL, 0x17916 /* #40 'DOMCSSMediaRule' => 'WebKit.DomCssMediaRule, Xamarin.Mac' */ },
		{ NULL, 0x17A16 /* #41 'DOMCSSPageRule' => 'WebKit.DomCssPageRule, Xamarin.Mac' */ },
		{ NULL, 0x17C16 /* #42 'DOMCSSRuleList' => 'WebKit.DomCssRuleList, Xamarin.Mac' */ },
		{ NULL, 0x17D16 /* #43 'DOMCSSStyleDeclaration' => 'WebKit.DomCssStyleDeclaration, Xamarin.Mac' */ },
		{ NULL, 0x17E16 /* #44 'DOMCSSStyleRule' => 'WebKit.DomCssStyleRule, Xamarin.Mac' */ },
		{ NULL, 0x1D816 /* #45 'DOMStyleSheet' => 'WebKit.DomStyleSheet, Xamarin.Mac' */ },
		{ NULL, 0x17F16 /* #46 'DOMCSSStyleSheet' => 'WebKit.DomCssStyleSheet, Xamarin.Mac' */ },
		{ NULL, 0x18016 /* #47 'DOMCSSUnknownRule' => 'WebKit.DomCssUnknownRule, Xamarin.Mac' */ },
		{ NULL, 0x18116 /* #48 'DOMCSSValue' => 'WebKit.DomCssValue, Xamarin.Mac' */ },
		{ NULL, 0x18216 /* #49 'DOMDocument' => 'WebKit.DomDocument, Xamarin.Mac' */ },
		{ NULL, 0x18316 /* #50 'DOMDocumentFragment' => 'WebKit.DomDocumentFragment, Xamarin.Mac' */ },
		{ NULL, 0x18416 /* #51 'DOMDocumentType' => 'WebKit.DomDocumentType, Xamarin.Mac' */ },
		{ NULL, 0x18516 /* #52 'DOMElement' => 'WebKit.DomElement, Xamarin.Mac' */ },
		{ NULL, 0x18616 /* #53 'DOMEntityReference' => 'WebKit.DomEntityReference, Xamarin.Mac' */ },
		{ NULL, 0x18716 /* #54 'DOMEvent' => 'WebKit.DomEvent, Xamarin.Mac' */ },
		{ NULL, 0x18A16 /* #55 'DOMEventListener' => 'WebKit.DomEventListener, Xamarin.Mac' */ },
		{ NULL, 0x18D16 /* #56 'DOMEventTarget' => 'WebKit.DomEventTarget, Xamarin.Mac' */ },
		{ NULL, 0x18E16 /* #57 'DOMFile' => 'WebKit.DomFile, Xamarin.Mac' */ },
		{ NULL, 0x18F16 /* #58 'DOMFileList' => 'WebKit.DomFileList, Xamarin.Mac' */ },
		{ NULL, 0x19D16 /* #59 'DOMHTMLElement' => 'WebKit.DomHtmlElement, Xamarin.Mac' */ },
		{ NULL, 0x19016 /* #60 'DOMHTMLAnchorElement' => 'WebKit.DomHtmlAnchorElement, Xamarin.Mac' */ },
		{ NULL, 0x19116 /* #61 'DOMHTMLAppletElement' => 'WebKit.DomHtmlAppletElement, Xamarin.Mac' */ },
		{ NULL, 0x19216 /* #62 'DOMHTMLAreaElement' => 'WebKit.DomHtmlAreaElement, Xamarin.Mac' */ },
		{ NULL, 0x19316 /* #63 'DOMHTMLBaseElement' => 'WebKit.DomHtmlBaseElement, Xamarin.Mac' */ },
		{ NULL, 0x19416 /* #64 'DOMHTMLBaseFontElement' => 'WebKit.DomHtmlBaseFontElement, Xamarin.Mac' */ },
		{ NULL, 0x19516 /* #65 'DOMHTMLBodyElement' => 'WebKit.DomHtmlBodyElement, Xamarin.Mac' */ },
		{ NULL, 0x19616 /* #66 'DOMHTMLBRElement' => 'WebKit.DomHtmlBRElement, Xamarin.Mac' */ },
		{ NULL, 0x19716 /* #67 'DOMHTMLButtonElement' => 'WebKit.DomHtmlButtonElement, Xamarin.Mac' */ },
		{ NULL, 0x19816 /* #68 'DOMHTMLCollection' => 'WebKit.DomHtmlCollection, Xamarin.Mac' */ },
		{ NULL, 0x19916 /* #69 'DOMHTMLDirectoryElement' => 'WebKit.DomHtmlDirectoryElement, Xamarin.Mac' */ },
		{ NULL, 0x19A16 /* #70 'DOMHTMLDivElement' => 'WebKit.DomHtmlDivElement, Xamarin.Mac' */ },
		{ NULL, 0x19B16 /* #71 'DOMHTMLDListElement' => 'WebKit.DomHtmlDListElement, Xamarin.Mac' */ },
		{ NULL, 0x19C16 /* #72 'DOMHTMLDocument' => 'WebKit.DomHtmlDocument, Xamarin.Mac' */ },
		{ NULL, 0x19E16 /* #73 'DOMHTMLEmbedElement' => 'WebKit.DomHtmlEmbedElement, Xamarin.Mac' */ },
		{ NULL, 0x19F16 /* #74 'DOMHTMLFieldSetElement' => 'WebKit.DomHtmlFieldSetElement, Xamarin.Mac' */ },
		{ NULL, 0x1A016 /* #75 'DOMHTMLFontElement' => 'WebKit.DomHtmlFontElement, Xamarin.Mac' */ },
		{ NULL, 0x1A116 /* #76 'DOMHTMLFormElement' => 'WebKit.DomHtmlFormElement, Xamarin.Mac' */ },
		{ NULL, 0x1A216 /* #77 'DOMHTMLFrameElement' => 'WebKit.DomHtmlFrameElement, Xamarin.Mac' */ },
		{ NULL, 0x1A316 /* #78 'DOMHTMLFrameSetElement' => 'WebKit.DomHtmlFrameSetElement, Xamarin.Mac' */ },
		{ NULL, 0x1A416 /* #79 'DOMHTMLHeadElement' => 'WebKit.DomHtmlHeadElement, Xamarin.Mac' */ },
		{ NULL, 0x1A516 /* #80 'DOMHTMLHeadingElement' => 'WebKit.DomHtmlHeadingElement, Xamarin.Mac' */ },
		{ NULL, 0x1A616 /* #81 'DOMHTMLHRElement' => 'WebKit.DomHtmlHRElement, Xamarin.Mac' */ },
		{ NULL, 0x1A716 /* #82 'DOMHTMLHtmlElement' => 'WebKit.DomHtmlHtmlElement, Xamarin.Mac' */ },
		{ NULL, 0x1A816 /* #83 'DOMHTMLIFrameElement' => 'WebKit.DomHtmlIFrameElement, Xamarin.Mac' */ },
		{ NULL, 0x1A916 /* #84 'DOMHTMLImageElement' => 'WebKit.DomHtmlImageElement, Xamarin.Mac' */ },
		{ NULL, 0x1AA16 /* #85 'DOMHTMLInputElement' => 'WebKit.DomHtmlInputElement, Xamarin.Mac' */ },
		{ NULL, 0x1AB16 /* #86 'DOMHTMLLabelElement' => 'WebKit.DomHtmlLabelElement, Xamarin.Mac' */ },
		{ NULL, 0x1AC16 /* #87 'DOMHTMLLegendElement' => 'WebKit.DomHtmlLegendElement, Xamarin.Mac' */ },
		{ NULL, 0x1AD16 /* #88 'DOMHTMLLIElement' => 'WebKit.DomHtmlLIElement, Xamarin.Mac' */ },
		{ NULL, 0x1AE16 /* #89 'DOMHTMLLinkElement' => 'WebKit.DomHtmlLinkElement, Xamarin.Mac' */ },
		{ NULL, 0x1AF16 /* #90 'DOMHTMLMapElement' => 'WebKit.DomHtmlMapElement, Xamarin.Mac' */ },
		{ NULL, 0x1B016 /* #91 'DOMHTMLMarqueeElement' => 'WebKit.DomHtmlMarqueeElement, Xamarin.Mac' */ },
		{ NULL, 0x1B116 /* #92 'DOMHTMLMenuElement' => 'WebKit.DomHtmlMenuElement, Xamarin.Mac' */ },
		{ NULL, 0x1B216 /* #93 'DOMHTMLMetaElement' => 'WebKit.DomHtmlMetaElement, Xamarin.Mac' */ },
		{ NULL, 0x1B316 /* #94 'DOMHTMLModElement' => 'WebKit.DomHtmlModElement, Xamarin.Mac' */ },
		{ NULL, 0x1B416 /* #95 'DOMHTMLObjectElement' => 'WebKit.DomHtmlObjectElement, Xamarin.Mac' */ },
		{ NULL, 0x1B516 /* #96 'DOMHTMLOListElement' => 'WebKit.DomHtmlOListElement, Xamarin.Mac' */ },
		{ NULL, 0x1B616 /* #97 'DOMHTMLOptGroupElement' => 'WebKit.DomHtmlOptGroupElement, Xamarin.Mac' */ },
		{ NULL, 0x1B716 /* #98 'DOMHTMLOptionElement' => 'WebKit.DomHtmlOptionElement, Xamarin.Mac' */ },
		{ NULL, 0x1B816 /* #99 'DOMHTMLOptionsCollection' => 'WebKit.DomHtmlOptionsCollection, Xamarin.Mac' */ },
		{ NULL, 0x1B916 /* #100 'DOMHTMLParagraphElement' => 'WebKit.DomHtmlParagraphElement, Xamarin.Mac' */ },
		{ NULL, 0x1BA16 /* #101 'DOMHTMLParamElement' => 'WebKit.DomHtmlParamElement, Xamarin.Mac' */ },
		{ NULL, 0x1BB16 /* #102 'DOMHTMLPreElement' => 'WebKit.DomHtmlPreElement, Xamarin.Mac' */ },
		{ NULL, 0x1BC16 /* #103 'DOMHTMLQuoteElement' => 'WebKit.DomHtmlQuoteElement, Xamarin.Mac' */ },
		{ NULL, 0x1BD16 /* #104 'DOMHTMLScriptElement' => 'WebKit.DomHtmlScriptElement, Xamarin.Mac' */ },
		{ NULL, 0x1BE16 /* #105 'DOMHTMLSelectElement' => 'WebKit.DomHtmlSelectElement, Xamarin.Mac' */ },
		{ NULL, 0x1BF16 /* #106 'DOMHTMLStyleElement' => 'WebKit.DomHtmlStyleElement, Xamarin.Mac' */ },
		{ NULL, 0x1C016 /* #107 'DOMHTMLTableCaptionElement' => 'WebKit.DomHtmlTableCaptionElement, Xamarin.Mac' */ },
		{ NULL, 0x1C116 /* #108 'DOMHTMLTableCellElement' => 'WebKit.DomHtmlTableCellElement, Xamarin.Mac' */ },
		{ NULL, 0x1C216 /* #109 'DOMHTMLTableColElement' => 'WebKit.DomHtmlTableColElement, Xamarin.Mac' */ },
		{ NULL, 0x1C316 /* #110 'DOMHTMLTableElement' => 'WebKit.DomHtmlTableElement, Xamarin.Mac' */ },
		{ NULL, 0x1C416 /* #111 'DOMHTMLTableRowElement' => 'WebKit.DomHtmlTableRowElement, Xamarin.Mac' */ },
		{ NULL, 0x1C516 /* #112 'DOMHTMLTableSectionElement' => 'WebKit.DomHtmlTableSectionElement, Xamarin.Mac' */ },
		{ NULL, 0x1C616 /* #113 'DOMHTMLTextAreaElement' => 'WebKit.DomHtmlTextAreaElement, Xamarin.Mac' */ },
		{ NULL, 0x1C716 /* #114 'DOMImplementation' => 'WebKit.DomImplementation, Xamarin.Mac' */ },
		{ NULL, 0x1C816 /* #115 'DOMCSSImportRule' => 'WebKit.DomImportCssRule, Xamarin.Mac' */ },
		{ NULL, 0x1DB16 /* #116 'DOMUIEvent' => 'WebKit.DomUIEvent, Xamarin.Mac' */ },
		{ NULL, 0x1C916 /* #117 'DOMKeyboardEvent' => 'WebKit.DomKeyboardEvent, Xamarin.Mac' */ },
		{ NULL, 0x1CA16 /* #118 'DOMMediaList' => 'WebKit.DomMediaList, Xamarin.Mac' */ },
		{ NULL, 0x1CB16 /* #119 'DOMMouseEvent' => 'WebKit.DomMouseEvent, Xamarin.Mac' */ },
		{ NULL, 0x1CC16 /* #120 'DOMNamedNodeMap' => 'WebKit.DomNamedNodeMap, Xamarin.Mac' */ },
		{ NULL, 0x1D016 /* #121 'Xamarin_Mac__WebKit_DomNodeFilter' => 'WebKit.DomNodeFilter, Xamarin.Mac' */ },
		{ NULL, 0x1D116 /* #122 'DOMNodeIterator' => 'WebKit.DomNodeIterator, Xamarin.Mac' */ },
		{ NULL, 0x1D216 /* #123 'DOMNodeList' => 'WebKit.DomNodeList, Xamarin.Mac' */ },
		{ NULL, 0x1D416 /* #124 'DOMOverflowEvent' => 'WebKit.DomOverflowEvent, Xamarin.Mac' */ },
		{ NULL, 0x1D516 /* #125 'DOMProcessingInstruction' => 'WebKit.DomProcessingInstruction, Xamarin.Mac' */ },
		{ NULL, 0x1D616 /* #126 'DOMProgressEvent' => 'WebKit.DomProgressEvent, Xamarin.Mac' */ },
		{ NULL, 0x1D716 /* #127 'DOMRange' => 'WebKit.DomRange, Xamarin.Mac' */ },
		{ NULL, 0x1D916 /* #128 'DOMStyleSheetList' => 'WebKit.DomStyleSheetList, Xamarin.Mac' */ },
		{ NULL, 0x1DC16 /* #129 'DOMWheelEvent' => 'WebKit.DomWheelEvent, Xamarin.Mac' */ },
		{ NULL, 0x1DD16 /* #130 'WebArchive' => 'WebKit.WebArchive, Xamarin.Mac' */ },
		{ NULL, 0x1DE16 /* #131 'WebBackForwardList' => 'WebKit.WebBackForwardList, Xamarin.Mac' */ },
		{ NULL, 0x1DF16 /* #132 'WebDataSource' => 'WebKit.WebDataSource, Xamarin.Mac' */ },
		{ NULL, 0x1E216 /* #133 'WebDocumentRepresentation' => 'WebKit.WebDocumentRepresentation, Xamarin.Mac' */ },
		{ NULL, 0x180816 /* #134 'NSURLDownload' => 'Foundation.NSUrlDownload, Xamarin.Mac' */ },
		{ NULL, 0x1E316 /* #135 'WebDownload' => 'WebKit.WebDownload, Xamarin.Mac' */ },
		{ NULL, 0x1E716 /* #136 'WebDownloadDelegate' => 'WebKit.WebDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1E816 /* #137 'WebFrame' => 'WebKit.WebFrame, Xamarin.Mac' */ },
		{ NULL, 0x1EC16 /* #138 'WebFrameLoadDelegate' => 'WebKit.WebFrameLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13E916 /* #139 'NSResponder' => 'AppKit.NSResponder, Xamarin.Mac' */ },
		{ NULL, 0x14F816 /* #140 'NSView' => 'AppKit.NSView, Xamarin.Mac' */ },
		{ NULL, 0x1ED16 /* #141 'WebFrameView' => 'WebKit.WebFrameView, Xamarin.Mac' */ },
		{ NULL, 0x1EE16 /* #142 'WebHistory' => 'WebKit.WebHistory, Xamarin.Mac' */ },
		{ NULL, 0x1F316 /* #143 'Xamarin_Mac__WebKit_WebOpenPanelResultListener' => 'WebKit.WebOpenPanelResultListener, Xamarin.Mac' */ },
		{ NULL, 0x1F716 /* #144 'Xamarin_Mac__WebKit_WebPolicyDecisionListener' => 'WebKit.WebPolicyDecisionListener, Xamarin.Mac' */ },
		{ NULL, 0x1FB16 /* #145 'WebPolicyDelegate' => 'WebKit.WebPolicyDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1FC16 /* #146 'WebPreferences' => 'WebKit.WebPreferences, Xamarin.Mac' */ },
		{ NULL, 0x1FD16 /* #147 'WebResource' => 'WebKit.WebResource, Xamarin.Mac' */ },
		{ NULL, 0x20116 /* #148 'WebResourceLoadDelegate' => 'WebKit.WebResourceLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20616 /* #149 'WebUIDelegate' => 'WebKit.WebUIDelegate, Xamarin.Mac' */ },
		{ NULL, 0x22C16 /* #150 'WKBackForwardList' => 'WebKit.WKBackForwardList, Xamarin.Mac' */ },
		{ NULL, 0x22D16 /* #151 'WKBackForwardListItem' => 'WebKit.WKBackForwardListItem, Xamarin.Mac' */ },
		{ NULL, 0x22E16 /* #152 'WKContentRuleList' => 'WebKit.WKContentRuleList, Xamarin.Mac' */ },
		{ NULL, 0x23216 /* #153 'WKFrameInfo' => 'WebKit.WKFrameInfo, Xamarin.Mac' */ },
		{ NULL, 0x23716 /* #154 'WKNavigation' => 'WebKit.WKNavigation, Xamarin.Mac' */ },
		{ NULL, 0x23816 /* #155 'WKNavigationAction' => 'WebKit.WKNavigationAction, Xamarin.Mac' */ },
		{ NULL, 0x23D16 /* #156 'WKNavigationDelegate' => 'WebKit.WKNavigationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x23E16 /* #157 'WKNavigationResponse' => 'WebKit.WKNavigationResponse, Xamarin.Mac' */ },
		{ NULL, 0x24116 /* #158 'WKOpenPanelParameters' => 'WebKit.WKOpenPanelParameters, Xamarin.Mac' */ },
		{ NULL, 0x24216 /* #159 'WKPreferences' => 'WebKit.WKPreferences, Xamarin.Mac' */ },
		{ NULL, 0x24316 /* #160 'WKProcessPool' => 'WebKit.WKProcessPool, Xamarin.Mac' */ },
		{ NULL, 0x24416 /* #161 'WKScriptMessage' => 'WebKit.WKScriptMessage, Xamarin.Mac' */ },
		{ NULL, 0x24716 /* #162 'WKScriptMessageHandler' => 'WebKit.WKScriptMessageHandler, Xamarin.Mac' */ },
		{ NULL, 0x24816 /* #163 'WKSecurityOrigin' => 'WebKit.WKSecurityOrigin, Xamarin.Mac' */ },
		{ NULL, 0x24A16 /* #164 'WKSnapshotConfiguration' => 'WebKit.WKSnapshotConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x24E16 /* #165 'WKUIDelegate' => 'WebKit.WKUIDelegate, Xamarin.Mac' */ },
		{ NULL, 0x25316 /* #166 'WKUserContentController' => 'WebKit.WKUserContentController, Xamarin.Mac' */ },
		{ NULL, 0x25416 /* #167 'WKUserScript' => 'WebKit.WKUserScript, Xamarin.Mac' */ },
		{ NULL, 0x25616 /* #168 'WKWebsiteDataRecord' => 'WebKit.WKWebsiteDataRecord, Xamarin.Mac' */ },
		{ NULL, 0x25A16 /* #169 'WKWebViewConfiguration' => 'WebKit.WKWebViewConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x25B16 /* #170 'WKWindowFeatures' => 'WebKit.WKWindowFeatures, Xamarin.Mac' */ },
		{ NULL, 0x29B16 /* #171 'VNObservation' => 'Vision.VNObservation, Xamarin.Mac' */ },
		{ NULL, 0x27916 /* #172 'VNDetectedObjectObservation' => 'Vision.VNDetectedObjectObservation, Xamarin.Mac' */ },
		{ NULL, 0x29F16 /* #173 'VNRectangleObservation' => 'Vision.VNRectangleObservation, Xamarin.Mac' */ },
		{ NULL, 0x26E16 /* #174 'VNBarcodeObservation' => 'Vision.VNBarcodeObservation, Xamarin.Mac' */ },
		{ NULL, 0x27216 /* #175 'VNClassificationObservation' => 'Vision.VNClassificationObservation, Xamarin.Mac' */ },
		{ NULL, 0x27316 /* #176 'VNCoreMLFeatureValueObservation' => 'Vision.VNCoreMLFeatureValueObservation, Xamarin.Mac' */ },
		{ NULL, 0x27416 /* #177 'VNCoreMLModel' => 'Vision.VNCoreMLModel, Xamarin.Mac' */ },
		{ NULL, 0x2A116 /* #178 'VNRequest' => 'Vision.VNRequest, Xamarin.Mac' */ },
		{ NULL, 0x29316 /* #179 'VNImageBasedRequest' => 'Vision.VNImageBasedRequest, Xamarin.Mac' */ },
		{ NULL, 0x27516 /* #180 'VNCoreMLRequest' => 'Vision.VNCoreMLRequest, Xamarin.Mac' */ },
		{ NULL, 0x27716 /* #181 'VNDetectBarcodesRequest' => 'Vision.VNDetectBarcodesRequest, Xamarin.Mac' */ },
		{ NULL, 0x27B16 /* #182 'VNDetectFaceLandmarksRequest' => 'Vision.VNDetectFaceLandmarksRequest, Xamarin.Mac' */ },
		{ NULL, 0x27D16 /* #183 'VNDetectFaceRectanglesRequest' => 'Vision.VNDetectFaceRectanglesRequest, Xamarin.Mac' */ },
		{ NULL, 0x27F16 /* #184 'VNDetectHorizonRequest' => 'Vision.VNDetectHorizonRequest, Xamarin.Mac' */ },
		{ NULL, 0x28116 /* #185 'VNDetectRectanglesRequest' => 'Vision.VNDetectRectanglesRequest, Xamarin.Mac' */ },
		{ NULL, 0x28316 /* #186 'VNDetectTextRectanglesRequest' => 'Vision.VNDetectTextRectanglesRequest, Xamarin.Mac' */ },
		{ NULL, 0x28716 /* #187 'VNFaceLandmarkRegion' => 'Vision.VNFaceLandmarkRegion, Xamarin.Mac' */ },
		{ NULL, 0x28816 /* #188 'VNFaceLandmarkRegion2D' => 'Vision.VNFaceLandmarkRegion2D, Xamarin.Mac' */ },
		{ NULL, 0x28916 /* #189 'VNFaceLandmarks' => 'Vision.VNFaceLandmarks, Xamarin.Mac' */ },
		{ NULL, 0x28A16 /* #190 'VNFaceLandmarks2D' => 'Vision.VNFaceLandmarks2D, Xamarin.Mac' */ },
		{ NULL, 0x28B16 /* #191 'VNFaceObservation' => 'Vision.VNFaceObservation, Xamarin.Mac' */ },
		{ NULL, 0x2A716 /* #192 'VNTargetedImageRequest' => 'Vision.VNTargetedImageRequest, Xamarin.Mac' */ },
		{ NULL, 0x29816 /* #193 'VNImageRegistrationRequest' => 'Vision.VNImageRegistrationRequest, Xamarin.Mac' */ },
		{ NULL, 0x28F16 /* #194 'VNHomographicImageRegistrationRequest' => 'Vision.VNHomographicImageRegistrationRequest, Xamarin.Mac' */ },
		{ NULL, 0x29116 /* #195 'VNHorizonObservation' => 'Vision.VNHorizonObservation, Xamarin.Mac' */ },
		{ NULL, 0x29216 /* #196 'VNImageAlignmentObservation' => 'Vision.VNImageAlignmentObservation, Xamarin.Mac' */ },
		{ NULL, 0x29516 /* #197 'VNImageHomographicAlignmentObservation' => 'Vision.VNImageHomographicAlignmentObservation, Xamarin.Mac' */ },
		{ NULL, 0x29916 /* #198 'VNImageRequestHandler' => 'Vision.VNImageRequestHandler, Xamarin.Mac' */ },
		{ NULL, 0x29A16 /* #199 'VNImageTranslationAlignmentObservation' => 'Vision.VNImageTranslationAlignmentObservation, Xamarin.Mac' */ },
		{ NULL, 0x29C16 /* #200 'VNPixelBufferObservation' => 'Vision.VNPixelBufferObservation, Xamarin.Mac' */ },
		{ NULL, 0x29D16 /* #201 'VNRecognizedObjectObservation' => 'Vision.VNRecognizedObjectObservation, Xamarin.Mac' */ },
		{ NULL, 0x2A616 /* #202 'VNSequenceRequestHandler' => 'Vision.VNSequenceRequestHandler, Xamarin.Mac' */ },
		{ NULL, 0x2A816 /* #203 'VNTextObservation' => 'Vision.VNTextObservation, Xamarin.Mac' */ },
		{ NULL, 0x2AA16 /* #204 'VNTrackingRequest' => 'Vision.VNTrackingRequest, Xamarin.Mac' */ },
		{ NULL, 0x2AB16 /* #205 'VNTrackObjectRequest' => 'Vision.VNTrackObjectRequest, Xamarin.Mac' */ },
		{ NULL, 0x2AD16 /* #206 'VNTrackRectangleRequest' => 'Vision.VNTrackRectangleRequest, Xamarin.Mac' */ },
		{ NULL, 0x2AF16 /* #207 'VNTranslationalImageRegistrationRequest' => 'Vision.VNTranslationalImageRegistrationRequest, Xamarin.Mac' */ },
		{ NULL, 0x2B516 /* #208 'SKDownload' => 'StoreKit.SKDownload, Xamarin.Mac' */ },
		{ NULL, 0x2BA16 /* #209 'SKPayment' => 'StoreKit.SKPayment, Xamarin.Mac' */ },
		{ NULL, 0x2B916 /* #210 'SKMutablePayment' => 'StoreKit.SKMutablePayment, Xamarin.Mac' */ },
		{ NULL, 0x2BB16 /* #211 'SKPaymentQueue' => 'StoreKit.SKPaymentQueue, Xamarin.Mac' */ },
		{ NULL, 0x2BC16 /* #212 'SKPaymentTransaction' => 'StoreKit.SKPaymentTransaction, Xamarin.Mac' */ },
		{ NULL, 0x2C016 /* #213 'SKPaymentTransactionObserver' => 'StoreKit.SKPaymentTransactionObserver, Xamarin.Mac' */ },
		{ NULL, 0x2C216 /* #214 'SKProduct' => 'StoreKit.SKProduct, Xamarin.Mac' */ },
		{ NULL, 0x2C316 /* #215 'SKProductDiscount' => 'StoreKit.SKProductDiscount, Xamarin.Mac' */ },
		{ NULL, 0x2D316 /* #216 'SKRequestDelegate' => 'StoreKit.SKRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x2CA16 /* #217 'SKProductsRequestDelegate' => 'StoreKit.SKProductsRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x2CB16 /* #218 'SKProductsResponse' => 'StoreKit.SKProductsResponse, Xamarin.Mac' */ },
		{ NULL, 0x2CC16 /* #219 'SKProductSubscriptionPeriod' => 'StoreKit.SKProductSubscriptionPeriod, Xamarin.Mac' */ },
		{ NULL, 0x2CE16 /* #220 'SKRequest' => 'StoreKit.SKRequest, Xamarin.Mac' */ },
		{ NULL, 0x2CD16 /* #221 'SKReceiptRefreshRequest' => 'StoreKit.SKReceiptRefreshRequest, Xamarin.Mac' */ },
		{ NULL, 0x2D416 /* #222 'SKStoreReviewController' => 'StoreKit.SKStoreReviewController, Xamarin.Mac' */ },
		{ NULL, 0x2EB16 /* #223 'SKNode' => 'SpriteKit.SKNode, Xamarin.Mac' */ },
		{ NULL, 0x2D616 /* #224 'SK3DNode' => 'SpriteKit.SK3DNode, Xamarin.Mac' */ },
		{ NULL, 0x2D716 /* #225 'SKAction' => 'SpriteKit.SKAction, Xamarin.Mac' */ },
		{ NULL, 0x2D916 /* #226 'SKAttribute' => 'SpriteKit.SKAttribute, Xamarin.Mac' */ },
		{ NULL, 0x2DB16 /* #227 'SKAttributeValue' => 'SpriteKit.SKAttributeValue, Xamarin.Mac' */ },
		{ NULL, 0x2DC16 /* #228 'SKAudioNode' => 'SpriteKit.SKAudioNode, Xamarin.Mac' */ },
		{ NULL, 0x2DE16 /* #229 'SKCameraNode' => 'SpriteKit.SKCameraNode, Xamarin.Mac' */ },
		{ NULL, 0x2DF16 /* #230 'SKConstraint' => 'SpriteKit.SKConstraint, Xamarin.Mac' */ },
		{ NULL, 0x2E016 /* #231 'SKCropNode' => 'SpriteKit.SKCropNode, Xamarin.Mac' */ },
		{ NULL, 0x2E116 /* #232 'SKEffectNode' => 'SpriteKit.SKEffectNode, Xamarin.Mac' */ },
		{ NULL, 0x2E216 /* #233 'SKEmitterNode' => 'SpriteKit.SKEmitterNode, Xamarin.Mac' */ },
		{ NULL, 0x2E316 /* #234 'SKFieldNode' => 'SpriteKit.SKFieldNode, Xamarin.Mac' */ },
		{ NULL, 0x2E516 /* #235 'SKKeyframeSequence' => 'SpriteKit.SKKeyframeSequence, Xamarin.Mac' */ },
		{ NULL, 0x2E716 /* #236 'SKLabelNode' => 'SpriteKit.SKLabelNode, Xamarin.Mac' */ },
		{ NULL, 0x2E916 /* #237 'SKLightNode' => 'SpriteKit.SKLightNode, Xamarin.Mac' */ },
		{ NULL, 0x30A16 /* #238 'SKTexture' => 'SpriteKit.SKTexture, Xamarin.Mac' */ },
		{ NULL, 0x2EA16 /* #239 'SKMutableTexture' => 'SpriteKit.SKMutableTexture, Xamarin.Mac' */ },
		{ NULL, 0x2EE16 /* #240 'SKPhysicsBody' => 'SpriteKit.SKPhysicsBody, Xamarin.Mac' */ },
		{ NULL, 0x2EF16 /* #241 'SKPhysicsContact' => 'SpriteKit.SKPhysicsContact, Xamarin.Mac' */ },
		{ NULL, 0x2F316 /* #242 'SKPhysicsContactDelegate' => 'SpriteKit.SKPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x2F416 /* #243 'SKPhysicsJoint' => 'SpriteKit.SKPhysicsJoint, Xamarin.Mac' */ },
		{ NULL, 0x2F516 /* #244 'SKPhysicsJointFixed' => 'SpriteKit.SKPhysicsJointFixed, Xamarin.Mac' */ },
		{ NULL, 0x2F616 /* #245 'SKPhysicsJointLimit' => 'SpriteKit.SKPhysicsJointLimit, Xamarin.Mac' */ },
		{ NULL, 0x2F716 /* #246 'SKPhysicsJointPin' => 'SpriteKit.SKPhysicsJointPin, Xamarin.Mac' */ },
		{ NULL, 0x2F816 /* #247 'SKPhysicsJointSliding' => 'SpriteKit.SKPhysicsJointSliding, Xamarin.Mac' */ },
		{ NULL, 0x2F916 /* #248 'SKPhysicsJointSpring' => 'SpriteKit.SKPhysicsJointSpring, Xamarin.Mac' */ },
		{ NULL, 0x2FB16 /* #249 'SKRange' => 'SpriteKit.SKRange, Xamarin.Mac' */ },
		{ NULL, 0x2FC16 /* #250 'SKReachConstraints' => 'SpriteKit.SKReachConstraints, Xamarin.Mac' */ },
		{ NULL, 0x2FD16 /* #251 'SKReferenceNode' => 'SpriteKit.SKReferenceNode, Xamarin.Mac' */ },
		{ NULL, 0x2FE16 /* #252 'SKRegion' => 'SpriteKit.SKRegion, Xamarin.Mac' */ },
		{ NULL, 0x2FF16 /* #253 'SKRenderer' => 'SpriteKit.SKRenderer, Xamarin.Mac' */ },
		{ NULL, 0x30116 /* #254 'SKScene' => 'SpriteKit.SKScene, Xamarin.Mac' */ },
		{ NULL, 0x30516 /* #255 'SKSceneDelegate' => 'SpriteKit.SKSceneDelegate, Xamarin.Mac' */ },
		{ NULL, 0x30716 /* #256 'SKShader' => 'SpriteKit.SKShader, Xamarin.Mac' */ },
		{ NULL, 0x30816 /* #257 'SKShapeNode' => 'SpriteKit.SKShapeNode, Xamarin.Mac' */ },
		{ NULL, 0x30916 /* #258 'SKSpriteNode' => 'SpriteKit.SKSpriteNode, Xamarin.Mac' */ },
		{ NULL, 0x30F16 /* #259 'SKTileDefinition' => 'SpriteKit.SKTileDefinition, Xamarin.Mac' */ },
		{ NULL, 0x31116 /* #260 'SKTileGroup' => 'SpriteKit.SKTileGroup, Xamarin.Mac' */ },
		{ NULL, 0x31216 /* #261 'SKTileGroupRule' => 'SpriteKit.SKTileGroupRule, Xamarin.Mac' */ },
		{ NULL, 0x31316 /* #262 'SKTileMapNode' => 'SpriteKit.SKTileMapNode, Xamarin.Mac' */ },
		{ NULL, 0x31416 /* #263 'SKTileSet' => 'SpriteKit.SKTileSet, Xamarin.Mac' */ },
		{ NULL, 0x31616 /* #264 'SKTransformNode' => 'SpriteKit.SKTransformNode, Xamarin.Mac' */ },
		{ NULL, 0x31716 /* #265 'SKTransition' => 'SpriteKit.SKTransition, Xamarin.Mac' */ },
		{ NULL, 0x31916 /* #266 'SKUniform' => 'SpriteKit.SKUniform, Xamarin.Mac' */ },
		{ NULL, 0x31B16 /* #267 'SKVideoNode' => 'SpriteKit.SKVideoNode, Xamarin.Mac' */ },
		{ NULL, 0x31C16 /* #268 'SKView' => 'SpriteKit.SKView, Xamarin.Mac' */ },
		{ NULL, 0x32016 /* #269 'SKViewDelegate' => 'SpriteKit.SKViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x32316 /* #270 'SKWarpGeometry' => 'SpriteKit.SKWarpGeometry, Xamarin.Mac' */ },
		{ NULL, 0x32416 /* #271 'SKWarpGeometryGrid' => 'SpriteKit.SKWarpGeometryGrid, Xamarin.Mac' */ },
		{ NULL, 0x14FC16 /* #272 'NSViewController' => 'AppKit.NSViewController, Xamarin.Mac' */ },
		{ NULL, 0x32E16 /* #273 'SLComposeServiceViewController' => 'Social.SLComposeServiceViewController, Xamarin.Mac' */ },
		{ NULL, 0x39816 /* #274 'SBApplicationDelegate' => 'ScriptingBridge.SBApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x16E616 /* #275 'NSArray' => 'Foundation.NSArray, Xamarin.Mac' */ },
		{ NULL, 0x177016 /* #276 'NSMutableArray' => 'Foundation.NSMutableArray, Xamarin.Mac' */ },
		{ NULL, 0x39916 /* #277 'SBElementArray' => 'ScriptingBridge.SBElementArray, Xamarin.Mac' */ },
		{ NULL, 0x39A16 /* #278 'SBObject' => 'ScriptingBridge.SBObject, Xamarin.Mac' */ },
		{ NULL, 0x3CF16 /* #279 'SCNConstraint' => 'SceneKit.SCNConstraint, Xamarin.Mac' */ },
		{ NULL, 0x39F16 /* #280 'SCNAccelerationConstraint' => 'SceneKit.SCNAccelerationConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3A016 /* #281 'SCNAction' => 'SceneKit.SCNAction, Xamarin.Mac' */ },
		{ NULL, 0x3A416 /* #282 'SCNActionable' => 'SceneKit.SCNActionable, Xamarin.Mac' */ },
		{ NULL, 0x3A916 /* #283 'SCNAnimatable' => 'SceneKit.SCNAnimatable, Xamarin.Mac' */ },
		{ NULL, 0x3AA16 /* #284 'SCNAnimation' => 'SceneKit.SCNAnimation, Xamarin.Mac' */ },
		{ NULL, 0x3AD16 /* #285 'SCNAnimationPlayer' => 'SceneKit.SCNAnimationPlayer, Xamarin.Mac' */ },
		{ NULL, 0x3B116 /* #286 'SCNAudioPlayer' => 'SceneKit.SCNAudioPlayer, Xamarin.Mac' */ },
		{ NULL, 0x3B216 /* #287 'SCNAudioSource' => 'SceneKit.SCNAudioSource, Xamarin.Mac' */ },
		{ NULL, 0x3B316 /* #288 'SCNAvoidOccluderConstraint' => 'SceneKit.SCNAvoidOccluderConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3B716 /* #289 'SCNAvoidOccluderConstraintDelegate' => 'SceneKit.SCNAvoidOccluderConstraintDelegate, Xamarin.Mac' */ },
		{ NULL, 0x3B916 /* #290 'SCNBillboardConstraint' => 'SceneKit.SCNBillboardConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3BD16 /* #291 'SCNBoundingVolume' => 'SceneKit.SCNBoundingVolume, Xamarin.Mac' */ },
		{ NULL, 0x3D916 /* #292 'SCNGeometry' => 'SceneKit.SCNGeometry, Xamarin.Mac' */ },
		{ NULL, 0x3BE16 /* #293 'SCNBox' => 'SceneKit.SCNBox, Xamarin.Mac' */ },
		{ NULL, 0x3C216 /* #294 'SCNCamera' => 'SceneKit.SCNCamera, Xamarin.Mac' */ },
		{ NULL, 0x3C516 /* #295 'SCNCameraController' => 'SceneKit.SCNCameraController, Xamarin.Mac' */ },
		{ NULL, 0x3C916 /* #296 'SCNCameraControllerDelegate' => 'SceneKit.SCNCameraControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x3CB16 /* #297 'SCNCapsule' => 'SceneKit.SCNCapsule, Xamarin.Mac' */ },
		{ NULL, 0x3CE16 /* #298 'SCNCone' => 'SceneKit.SCNCone, Xamarin.Mac' */ },
		{ NULL, 0x3D116 /* #299 'SCNCylinder' => 'SceneKit.SCNCylinder, Xamarin.Mac' */ },
		{ NULL, 0x3D316 /* #300 'SCNDistanceConstraint' => 'SceneKit.SCNDistanceConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3D816 /* #301 'SCNFloor' => 'SceneKit.SCNFloor, Xamarin.Mac' */ },
		{ NULL, 0x3DA16 /* #302 'SCNGeometryElement' => 'SceneKit.SCNGeometryElement, Xamarin.Mac' */ },
		{ NULL, 0x3DC16 /* #303 'SCNGeometrySource' => 'SceneKit.SCNGeometrySource, Xamarin.Mac' */ },
		{ NULL, 0x3DF16 /* #304 'SCNGeometryTessellator' => 'SceneKit.SCNGeometryTessellator, Xamarin.Mac' */ },
		{ NULL, 0x3E216 /* #305 'SCNHitTestResult' => 'SceneKit.SCNHitTestResult, Xamarin.Mac' */ },
		{ NULL, 0x3E416 /* #306 'SCNIKConstraint' => 'SceneKit.SCNIKConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3E716 /* #307 'SCNLevelOfDetail' => 'SceneKit.SCNLevelOfDetail, Xamarin.Mac' */ },
		{ NULL, 0x3E816 /* #308 'SCNLight' => 'SceneKit.SCNLight, Xamarin.Mac' */ },
		{ NULL, 0x3EC16 /* #309 'SCNLookAtConstraint' => 'SceneKit.SCNLookAtConstraint, Xamarin.Mac' */ },
		{ NULL, 0x3ED16 /* #310 'SCNMaterial' => 'SceneKit.SCNMaterial, Xamarin.Mac' */ },
		{ NULL, 0x3EE16 /* #311 'SCNMaterialProperty' => 'SceneKit.SCNMaterialProperty, Xamarin.Mac' */ },
		{ NULL, 0x3EF16 /* #312 'SCNMorpher' => 'SceneKit.SCNMorpher, Xamarin.Mac' */ },
		{ NULL, 0x3F716 /* #313 'SCNNodeRendererDelegate' => 'SceneKit.SCNNodeRendererDelegate, Xamarin.Mac' */ },
		{ NULL, 0x40116 /* #314 'SCNParticlePropertyController' => 'SceneKit.SCNParticlePropertyController, Xamarin.Mac' */ },
		{ NULL, 0x40316 /* #315 'SCNParticleSystem' => 'SceneKit.SCNParticleSystem, Xamarin.Mac' */ },
		{ NULL, 0x40516 /* #316 'SCNPhysicsBehavior' => 'SceneKit.SCNPhysicsBehavior, Xamarin.Mac' */ },
		{ NULL, 0x40416 /* #317 'SCNPhysicsBallSocketJoint' => 'SceneKit.SCNPhysicsBallSocketJoint, Xamarin.Mac' */ },
		{ NULL, 0x40616 /* #318 'SCNPhysicsBody' => 'SceneKit.SCNPhysicsBody, Xamarin.Mac' */ },
		{ NULL, 0x40916 /* #319 'SCNPhysicsConeTwistJoint' => 'SceneKit.SCNPhysicsConeTwistJoint, Xamarin.Mac' */ },
		{ NULL, 0x40A16 /* #320 'SCNPhysicsContact' => 'SceneKit.SCNPhysicsContact, Xamarin.Mac' */ },
		{ NULL, 0x40E16 /* #321 'SCNPhysicsContactDelegate' => 'SceneKit.SCNPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x40F16 /* #322 'SCNPhysicsField' => 'SceneKit.SCNPhysicsField, Xamarin.Mac' */ },
		{ NULL, 0x41116 /* #323 'SCNPhysicsHingeJoint' => 'SceneKit.SCNPhysicsHingeJoint, Xamarin.Mac' */ },
		{ NULL, 0x41316 /* #324 'SCNPhysicsShape' => 'SceneKit.SCNPhysicsShape, Xamarin.Mac' */ },
		{ NULL, 0x41616 /* #325 'SCNPhysicsSliderJoint' => 'SceneKit.SCNPhysicsSliderJoint, Xamarin.Mac' */ },
		{ NULL, 0x41A16 /* #326 'SCNPhysicsVehicle' => 'SceneKit.SCNPhysicsVehicle, Xamarin.Mac' */ },
		{ NULL, 0x41B16 /* #327 'SCNPhysicsVehicleWheel' => 'SceneKit.SCNPhysicsVehicleWheel, Xamarin.Mac' */ },
		{ NULL, 0x41E16 /* #328 'SCNPlane' => 'SceneKit.SCNPlane, Xamarin.Mac' */ },
		{ NULL, 0x41F16 /* #329 'SCNProgram' => 'SceneKit.SCNProgram, Xamarin.Mac' */ },
		{ NULL, 0x42316 /* #330 'SCNProgramDelegate' => 'SceneKit.SCNProgramDelegate, Xamarin.Mac' */ },
		{ NULL, 0x42516 /* #331 'SCNPyramid' => 'SceneKit.SCNPyramid, Xamarin.Mac' */ },
		{ NULL, 0x3F216 /* #332 'SCNNode' => 'SceneKit.SCNNode, Xamarin.Mac' */ },
		{ NULL, 0x42716 /* #333 'SCNReferenceNode' => 'SceneKit.SCNReferenceNode, Xamarin.Mac' */ },
		{ NULL, 0x42D16 /* #334 'SCNReplicatorConstraint' => 'SceneKit.SCNReplicatorConstraint, Xamarin.Mac' */ },
		{ NULL, 0x42E16 /* #335 'SCNScene' => 'SceneKit.SCNScene, Xamarin.Mac' */ },
		{ NULL, 0x43216 /* #336 'SCNSceneExportDelegate' => 'SceneKit.SCNSceneExportDelegate, Xamarin.Mac' */ },
		{ NULL, 0x43716 /* #337 'SCNSceneRenderer' => 'SceneKit.SCNSceneRenderer, Xamarin.Mac' */ },
		{ NULL, 0x43B16 /* #338 'SCNSceneRendererDelegate' => 'SceneKit.SCNSceneRendererDelegate, Xamarin.Mac' */ },
		{ NULL, 0x43C16 /* #339 'SCNSceneSource' => 'SceneKit.SCNSceneSource, Xamarin.Mac' */ },
		{ NULL, 0x44416 /* #340 'SCNShadable' => 'SceneKit.SCNShadable, Xamarin.Mac' */ },
		{ NULL, 0x44716 /* #341 'SCNShape' => 'SceneKit.SCNShape, Xamarin.Mac' */ },
		{ NULL, 0x44816 /* #342 'SCNSkinner' => 'SceneKit.SCNSkinner, Xamarin.Mac' */ },
		{ NULL, 0x44916 /* #343 'SCNSliderConstraint' => 'SceneKit.SCNSliderConstraint, Xamarin.Mac' */ },
		{ NULL, 0x44A16 /* #344 'SCNSphere' => 'SceneKit.SCNSphere, Xamarin.Mac' */ },
		{ NULL, 0x44B16 /* #345 'SCNTechnique' => 'SceneKit.SCNTechnique, Xamarin.Mac' */ },
		{ NULL, 0x44E16 /* #346 'SCNTechniqueSupport' => 'SceneKit.SCNTechniqueSupport, Xamarin.Mac' */ },
		{ NULL, 0x45016 /* #347 'SCNText' => 'SceneKit.SCNText, Xamarin.Mac' */ },
		{ NULL, 0x45116 /* #348 'SCNTimingFunction' => 'SceneKit.SCNTimingFunction, Xamarin.Mac' */ },
		{ NULL, 0x45216 /* #349 'SCNTorus' => 'SceneKit.SCNTorus, Xamarin.Mac' */ },
		{ NULL, 0x45316 /* #350 'SCNTransaction' => 'SceneKit.SCNTransaction, Xamarin.Mac' */ },
		{ NULL, 0x45416 /* #351 'SCNTransformConstraint' => 'SceneKit.SCNTransformConstraint, Xamarin.Mac' */ },
		{ NULL, 0x45616 /* #352 'SCNTube' => 'SceneKit.SCNTube, Xamarin.Mac' */ },
		{ NULL, 0x47216 /* #353 'SFContentBlockerState' => 'SafariServices.SFContentBlockerState, Xamarin.Mac' */ },
		{ NULL, 0x47C16 /* #354 'SFSafariExtensionViewController' => 'SafariServices.SFSafariExtensionViewController, Xamarin.Mac' */ },
		{ NULL, 0x47E16 /* #355 'SFSafariPageProperties' => 'SafariServices.SFSafariPageProperties, Xamarin.Mac' */ },
		{ NULL, 0x48116 /* #356 'SFSafariToolbarItem' => 'SafariServices.SFSafariToolbarItem, Xamarin.Mac' */ },
		{ NULL, 0x48916 /* #357 'QLPreviewItem' => 'QuickLookUI.QLPreviewItem, Xamarin.Mac' */ },
		{ NULL, 0x150316 /* #358 'NSWindow' => 'AppKit.NSWindow, Xamarin.Mac' */ },
		{ NULL, 0x13B016 /* #359 'NSPanel' => 'AppKit.NSPanel, Xamarin.Mac' */ },
		{ NULL, 0x48A16 /* #360 'QLPreviewPanel' => 'QuickLookUI.QLPreviewPanel, Xamarin.Mac' */ },
		{ NULL, 0x48E16 /* #361 'QLPreviewPanelDataSource' => 'QuickLookUI.QLPreviewPanelDataSource, Xamarin.Mac' */ },
		{ NULL, 0x49216 /* #362 'QLPreviewPanelDelegate' => 'QuickLookUI.QLPreviewPanelDelegate, Xamarin.Mac' */ },
		{ NULL, 0x49316 /* #363 'QLPreviewView' => 'QuickLookUI.QLPreviewView, Xamarin.Mac' */ },
		{ NULL, 0x49616 /* #364 'QCComposition' => 'QuartzComposer.QCComposition, Xamarin.Mac' */ },
		{ NULL, 0xF5F16 /* #365 'CALayer' => 'CoreAnimation.CALayer, Xamarin.Mac' */ },
		{ NULL, 0xF6B16 /* #366 'CAOpenGLLayer' => 'CoreAnimation.CAOpenGLLayer, Xamarin.Mac' */ },
		{ NULL, 0x49716 /* #367 'QCCompositionLayer' => 'QuartzComposer.QCCompositionLayer, Xamarin.Mac' */ },
		{ NULL, 0x49816 /* #368 'QCCompositionRepository' => 'QuartzComposer.QCCompositionRepository, Xamarin.Mac' */ },
		{ NULL, 0x4D616 /* #369 'PHLivePhotoView' => 'PhotosUI.PHLivePhotoView, Xamarin.Mac' */ },
		{ NULL, 0x4DB16 /* #370 'PHLivePhotoViewDelegate' => 'PhotosUI.PHLivePhotoViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x4E016 /* #371 'PHProjectElement' => 'PhotosUI.PHProjectElement, Xamarin.Mac' */ },
		{ NULL, 0x4DD16 /* #372 'PHProjectAssetElement' => 'PhotosUI.PHProjectAssetElement, Xamarin.Mac' */ },
		{ NULL, 0x171C16 /* #373 'NSExtensionContext' => 'Foundation.NSExtensionContext, Xamarin.Mac' */ },
		{ NULL, 0x4E116 /* #374 'PHProjectExtensionContext' => 'PhotosUI.PHProjectExtensionContext, Xamarin.Mac' */ },
		{ NULL, 0x4E516 /* #375 'PHProjectInfo' => 'PhotosUI.PHProjectInfo, Xamarin.Mac' */ },
		{ NULL, 0x4E616 /* #376 'PHProjectJournalEntryElement' => 'PhotosUI.PHProjectJournalEntryElement, Xamarin.Mac' */ },
		{ NULL, 0x4E716 /* #377 'PHProjectMapElement' => 'PhotosUI.PHProjectMapElement, Xamarin.Mac' */ },
		{ NULL, 0x4E816 /* #378 'PHProjectRegionOfInterest' => 'PhotosUI.PHProjectRegionOfInterest, Xamarin.Mac' */ },
		{ NULL, 0x4E916 /* #379 'PHProjectSection' => 'PhotosUI.PHProjectSection, Xamarin.Mac' */ },
		{ NULL, 0x4EA16 /* #380 'PHProjectSectionContent' => 'PhotosUI.PHProjectSectionContent, Xamarin.Mac' */ },
		{ NULL, 0x4EB16 /* #381 'PHProjectTextElement' => 'PhotosUI.PHProjectTextElement, Xamarin.Mac' */ },
		{ NULL, 0x4ED16 /* #382 'PHProjectTypeDescription' => 'PhotosUI.PHProjectTypeDescription, Xamarin.Mac' */ },
		{ NULL, 0x4F116 /* #383 'PHProjectTypeDescriptionDataSource' => 'PhotosUI.PHProjectTypeDescriptionDataSource, Xamarin.Mac' */ },
		{ NULL, 0x4F516 /* #384 'PHAdjustmentData' => 'Photos.PHAdjustmentData, Xamarin.Mac' */ },
		{ NULL, 0x51E16 /* #385 'PHObject' => 'Photos.PHObject, Xamarin.Mac' */ },
		{ NULL, 0x4F616 /* #386 'PHAsset' => 'Photos.PHAsset, Xamarin.Mac' */ },
		{ NULL, 0x50416 /* #387 'PHCollection' => 'Photos.PHCollection, Xamarin.Mac' */ },
		{ NULL, 0x4F816 /* #388 'PHAssetCollection' => 'Photos.PHAssetCollection, Xamarin.Mac' */ },
		{ NULL, 0x50216 /* #389 'PHChange' => 'Photos.PHChange, Xamarin.Mac' */ },
		{ NULL, 0x50316 /* #390 'PHCloudIdentifier' => 'Photos.PHCloudIdentifier, Xamarin.Mac' */ },
		{ NULL, 0x50616 /* #391 'PHCollectionList' => 'Photos.PHCollectionList, Xamarin.Mac' */ },
		{ NULL, 0x50916 /* #392 'PHContentEditingInput' => 'Photos.PHContentEditingInput, Xamarin.Mac' */ },
		{ NULL, 0x50A16 /* #393 'PHContentEditingOutput' => 'Photos.PHContentEditingOutput, Xamarin.Mac' */ },
		{ NULL, 0x50B16 /* #394 'PHFetchOptions' => 'Photos.PHFetchOptions, Xamarin.Mac' */ },
		{ NULL, 0x50C16 /* #395 'PHFetchResult' => 'Photos.PHFetchResult, Xamarin.Mac' */ },
		{ NULL, 0x50D16 /* #396 'PHFetchResultChangeDetails' => 'Photos.PHFetchResultChangeDetails, Xamarin.Mac' */ },
		{ NULL, 0x51016 /* #397 'PHImageManager' => 'Photos.PHImageManager, Xamarin.Mac' */ },
		{ NULL, 0x51116 /* #398 'PHImageRequestOptions' => 'Photos.PHImageRequestOptions, Xamarin.Mac' */ },
		{ NULL, 0x51516 /* #399 'PHLivePhoto' => 'Photos.PHLivePhoto, Xamarin.Mac' */ },
		{ NULL, 0x51F16 /* #400 'PHObjectChangeDetails' => 'Photos.PHObjectChangeDetails, Xamarin.Mac' */ },
		{ NULL, 0x52416 /* #401 'PHPhotoLibraryChangeObserver' => 'Photos.PHPhotoLibraryChangeObserver, Xamarin.Mac' */ },
		{ NULL, 0x52516 /* #402 'PHProject' => 'Photos.PHProject, Xamarin.Mac' */ },
		{ NULL, 0x52616 /* #403 'PHProjectChangeRequest' => 'Photos.PHProjectChangeRequest, Xamarin.Mac' */ },
		{ NULL, 0x58316 /* #404 'PDFAction' => 'PdfKit.PdfAction, Xamarin.Mac' */ },
		{ NULL, 0x58416 /* #405 'PDFActionGoTo' => 'PdfKit.PdfActionGoTo, Xamarin.Mac' */ },
		{ NULL, 0x58516 /* #406 'PDFActionNamed' => 'PdfKit.PdfActionNamed, Xamarin.Mac' */ },
		{ NULL, 0x58716 /* #407 'PDFActionRemoteGoTo' => 'PdfKit.PdfActionRemoteGoTo, Xamarin.Mac' */ },
		{ NULL, 0x58816 /* #408 'PDFActionResetForm' => 'PdfKit.PdfActionResetForm, Xamarin.Mac' */ },
		{ NULL, 0x58916 /* #409 'PDFActionURL' => 'PdfKit.PdfActionUrl, Xamarin.Mac' */ },
		{ NULL, 0x58A16 /* #410 'PDFAnnotation' => 'PdfKit.PdfAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x58B16 /* #411 'PDFAnnotationButtonWidget' => 'PdfKit.PdfAnnotationButtonWidget, Xamarin.Mac' */ },
		{ NULL, 0x58C16 /* #412 'PDFAnnotationChoiceWidget' => 'PdfKit.PdfAnnotationChoiceWidget, Xamarin.Mac' */ },
		{ NULL, 0x58D16 /* #413 'PDFAnnotationCircle' => 'PdfKit.PdfAnnotationCircle, Xamarin.Mac' */ },
		{ NULL, 0x58E16 /* #414 'PDFAnnotationFreeText' => 'PdfKit.PdfAnnotationFreeText, Xamarin.Mac' */ },
		{ NULL, 0x59116 /* #415 'PDFAnnotationInk' => 'PdfKit.PdfAnnotationInk, Xamarin.Mac' */ },
		{ NULL, 0x59416 /* #416 'PDFAnnotationLine' => 'PdfKit.PdfAnnotationLine, Xamarin.Mac' */ },
		{ NULL, 0x59716 /* #417 'PDFAnnotationLink' => 'PdfKit.PdfAnnotationLink, Xamarin.Mac' */ },
		{ NULL, 0x59816 /* #418 'PDFAnnotationMarkup' => 'PdfKit.PdfAnnotationMarkup, Xamarin.Mac' */ },
		{ NULL, 0x59916 /* #419 'PDFAnnotationPopup' => 'PdfKit.PdfAnnotationPopup, Xamarin.Mac' */ },
		{ NULL, 0x59A16 /* #420 'PDFAnnotationSquare' => 'PdfKit.PdfAnnotationSquare, Xamarin.Mac' */ },
		{ NULL, 0x59B16 /* #421 'PDFAnnotationStamp' => 'PdfKit.PdfAnnotationStamp, Xamarin.Mac' */ },
		{ NULL, 0x59E16 /* #422 'PDFAnnotationText' => 'PdfKit.PdfAnnotationText, Xamarin.Mac' */ },
		{ NULL, 0x5A116 /* #423 'PDFAnnotationTextWidget' => 'PdfKit.PdfAnnotationTextWidget, Xamarin.Mac' */ },
		{ NULL, 0x5A416 /* #424 'PDFAppearanceCharacteristics' => 'PdfKit.PdfAppearanceCharacteristics, Xamarin.Mac' */ },
		{ NULL, 0x5A716 /* #425 'PDFBorder' => 'PdfKit.PdfBorder, Xamarin.Mac' */ },
		{ NULL, 0x5AA16 /* #426 'PDFDestination' => 'PdfKit.PdfDestination, Xamarin.Mac' */ },
		{ NULL, 0x5B416 /* #427 'PDFDocumentDelegate' => 'PdfKit.PdfDocumentDelegate, Xamarin.Mac' */ },
		{ NULL, 0x5BB16 /* #428 'PDFOutline' => 'PdfKit.PdfOutline, Xamarin.Mac' */ },
		{ NULL, 0x5BC16 /* #429 'PDFPage' => 'PdfKit.PdfPage, Xamarin.Mac' */ },
		{ NULL, 0x5BE16 /* #430 'PDFSelection' => 'PdfKit.PdfSelection, Xamarin.Mac' */ },
		{ NULL, 0x5C716 /* #431 'PDFViewDelegate' => 'PdfKit.PdfViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x5CF16 /* #432 'NCWidgetController' => 'NotificationCenter.NCWidgetController, Xamarin.Mac' */ },
		{ NULL, 0x5D616 /* #433 'NCWidgetListViewDelegate' => 'NotificationCenter.NCWidgetListViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x5DA16 /* #434 'NCWidgetProviding' => 'NotificationCenter.NCWidgetProviding, Xamarin.Mac' */ },
		{ NULL, 0x5E016 /* #435 'NCWidgetSearchViewDelegate' => 'NotificationCenter.NCWidgetSearchViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x5EC16 /* #436 'NEAppRule' => 'NetworkExtension.NEAppRule, Xamarin.Mac' */ },
		{ NULL, 0x61F16 /* #437 'NEVPNProtocol' => 'NetworkExtension.NEVpnProtocol, Xamarin.Mac' */ },
		{ NULL, 0x5ED16 /* #438 'NEDNSProxyProviderProtocol' => 'NetworkExtension.NEDnsProxyProviderProtocol, Xamarin.Mac' */ },
		{ NULL, 0x5EE16 /* #439 'NEDNSSettings' => 'NetworkExtension.NEDnsSettings, Xamarin.Mac' */ },
		{ NULL, 0x5EF16 /* #440 'NEEvaluateConnectionRule' => 'NetworkExtension.NEEvaluateConnectionRule, Xamarin.Mac' */ },
		{ NULL, 0x5F516 /* #441 'NEFilterProviderConfiguration' => 'NetworkExtension.NEFilterProviderConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x5F616 /* #442 'NEFlowMetaData' => 'NetworkExtension.NEFlowMetaData, Xamarin.Mac' */ },
		{ NULL, 0x5F716 /* #443 'NEIPv4Route' => 'NetworkExtension.NEIPv4Route, Xamarin.Mac' */ },
		{ NULL, 0x5F816 /* #444 'NEIPv4Settings' => 'NetworkExtension.NEIPv4Settings, Xamarin.Mac' */ },
		{ NULL, 0x5F916 /* #445 'NEIPv6Route' => 'NetworkExtension.NEIPv6Route, Xamarin.Mac' */ },
		{ NULL, 0x5FA16 /* #446 'NEIPv6Settings' => 'NetworkExtension.NEIPv6Settings, Xamarin.Mac' */ },
		{ NULL, 0x5FB16 /* #447 'NEOnDemandRule' => 'NetworkExtension.NEOnDemandRule, Xamarin.Mac' */ },
		{ NULL, 0x5FD16 /* #448 'NEOnDemandRuleConnect' => 'NetworkExtension.NEOnDemandRuleConnect, Xamarin.Mac' */ },
		{ NULL, 0x5FE16 /* #449 'NEOnDemandRuleDisconnect' => 'NetworkExtension.NEOnDemandRuleDisconnect, Xamarin.Mac' */ },
		{ NULL, 0x5FF16 /* #450 'NEOnDemandRuleEvaluateConnection' => 'NetworkExtension.NEOnDemandRuleEvaluateConnection, Xamarin.Mac' */ },
		{ NULL, 0x60016 /* #451 'NEOnDemandRuleIgnore' => 'NetworkExtension.NEOnDemandRuleIgnore, Xamarin.Mac' */ },
		{ NULL, 0x60216 /* #452 'NEPacket' => 'NetworkExtension.NEPacket, Xamarin.Mac' */ },
		{ NULL, 0x60A16 /* #453 'NETunnelNetworkSettings' => 'NetworkExtension.NETunnelNetworkSettings, Xamarin.Mac' */ },
		{ NULL, 0x60416 /* #454 'NEPacketTunnelNetworkSettings' => 'NetworkExtension.NEPacketTunnelNetworkSettings, Xamarin.Mac' */ },
		{ NULL, 0x60816 /* #455 'NEProxyServer' => 'NetworkExtension.NEProxyServer, Xamarin.Mac' */ },
		{ NULL, 0x60916 /* #456 'NEProxySettings' => 'NetworkExtension.NEProxySettings, Xamarin.Mac' */ },
		{ NULL, 0x60F16 /* #457 'NETunnelProviderProtocol' => 'NetworkExtension.NETunnelProviderProtocol, Xamarin.Mac' */ },
		{ NULL, 0x61216 /* #458 'NEVPNConnection' => 'NetworkExtension.NEVpnConnection, Xamarin.Mac' */ },
		{ NULL, 0x61116 /* #459 'NETunnelProviderSession' => 'NetworkExtension.NETunnelProviderSession, Xamarin.Mac' */ },
		{ NULL, 0x61B16 /* #460 'NEVPNIKEv2SecurityAssociationParameters' => 'NetworkExtension.NEVpnIke2SecurityAssociationParameters, Xamarin.Mac' */ },
		{ NULL, 0x62116 /* #461 'NEVPNProtocolIPSec' => 'NetworkExtension.NEVpnProtocolIpSec, Xamarin.Mac' */ },
		{ NULL, 0x62016 /* #462 'NEVPNProtocolIKEv2' => 'NetworkExtension.NEVpnProtocolIke2, Xamarin.Mac' */ },
		{ NULL, 0x62416 /* #463 'NWEndpoint' => 'NetworkExtension.NWEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x62316 /* #464 'NWBonjourServiceEndpoint' => 'NetworkExtension.NWBonjourServiceEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x62516 /* #465 'NWHostEndpoint' => 'NetworkExtension.NWHostEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x62616 /* #466 'NWPath' => 'NetworkExtension.NWPath, Xamarin.Mac' */ },
		{ NULL, 0x62C16 /* #467 'NWTCPConnectionAuthenticationDelegate' => 'NetworkExtension.NWTcpConnectionAuthenticationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x62E16 /* #468 'NWTLSParameters' => 'NetworkExtension.NWTlsParameters, Xamarin.Mac' */ },
		{ NULL, 0x65616 /* #469 'NLModel' => 'NaturalLanguage.NLModel, Xamarin.Mac' */ },
		{ NULL, 0x65716 /* #470 'NLModelConfiguration' => 'NaturalLanguage.NLModelConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x65E16 /* #471 'NLTokenizer' => 'NaturalLanguage.NLTokenizer, Xamarin.Mac' */ },
		{ NULL, 0x66316 /* #472 'MCAdvertiserAssistant' => 'MultipeerConnectivity.MCAdvertiserAssistant, Xamarin.Mac' */ },
		{ NULL, 0x66716 /* #473 'MCAdvertiserAssistantDelegate' => 'MultipeerConnectivity.MCAdvertiserAssistantDelegate, Xamarin.Mac' */ },
		{ NULL, 0x66816 /* #474 'MCBrowserViewController' => 'MultipeerConnectivity.MCBrowserViewController, Xamarin.Mac' */ },
		{ NULL, 0x66C16 /* #475 'MCBrowserViewControllerDelegate' => 'MultipeerConnectivity.MCBrowserViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x67016 /* #476 'MCNearbyServiceAdvertiser' => 'MultipeerConnectivity.MCNearbyServiceAdvertiser, Xamarin.Mac' */ },
		{ NULL, 0x67416 /* #477 'MCNearbyServiceAdvertiserDelegate' => 'MultipeerConnectivity.MCNearbyServiceAdvertiserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x67516 /* #478 'MCNearbyServiceBrowser' => 'MultipeerConnectivity.MCNearbyServiceBrowser, Xamarin.Mac' */ },
		{ NULL, 0x67916 /* #479 'MCNearbyServiceBrowserDelegate' => 'MultipeerConnectivity.MCNearbyServiceBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x67A16 /* #480 'MCPeerID' => 'MultipeerConnectivity.MCPeerID, Xamarin.Mac' */ },
		{ NULL, 0x67F16 /* #481 'MCSessionDelegate' => 'MultipeerConnectivity.MCSessionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x68816 /* #482 'MDLAnimatedValue' => 'ModelIO.MDLAnimatedValue, Xamarin.Mac' */ },
		{ NULL, 0x68416 /* #483 'MDLAnimatedMatrix4x4' => 'ModelIO.MDLAnimatedMatrix4x4, Xamarin.Mac' */ },
		{ NULL, 0x68516 /* #484 'MDLAnimatedQuaternionArray' => 'ModelIO.MDLAnimatedQuaternionArray, Xamarin.Mac' */ },
		{ NULL, 0x68616 /* #485 'MDLAnimatedScalar' => 'ModelIO.MDLAnimatedScalar, Xamarin.Mac' */ },
		{ NULL, 0x68716 /* #486 'MDLAnimatedScalarArray' => 'ModelIO.MDLAnimatedScalarArray, Xamarin.Mac' */ },
		{ NULL, 0x68A16 /* #487 'MDLAnimatedVector2' => 'ModelIO.MDLAnimatedVector2, Xamarin.Mac' */ },
		{ NULL, 0x68B16 /* #488 'MDLAnimatedVector3' => 'ModelIO.MDLAnimatedVector3, Xamarin.Mac' */ },
		{ NULL, 0x68C16 /* #489 'MDLAnimatedVector3Array' => 'ModelIO.MDLAnimatedVector3Array, Xamarin.Mac' */ },
		{ NULL, 0x68D16 /* #490 'MDLAnimatedVector4' => 'ModelIO.MDLAnimatedVector4, Xamarin.Mac' */ },
		{ NULL, 0x68E16 /* #491 'MDLAnimationBindComponent' => 'ModelIO.MDLAnimationBindComponent, Xamarin.Mac' */ },
		{ NULL, 0x6B916 /* #492 'MDLObject' => 'ModelIO.MDLObject, Xamarin.Mac' */ },
		{ NULL, 0x69C16 /* #493 'MDLLight' => 'ModelIO.MDLLight, Xamarin.Mac' */ },
		{ NULL, 0x6C116 /* #494 'MDLPhysicallyPlausibleLight' => 'ModelIO.MDLPhysicallyPlausibleLight, Xamarin.Mac' */ },
		{ NULL, 0x68F16 /* #495 'MDLAreaLight' => 'ModelIO.MDLAreaLight, Xamarin.Mac' */ },
		{ NULL, 0x69016 /* #496 'MDLAsset' => 'ModelIO.MDLAsset, Xamarin.Mac' */ },
		{ NULL, 0x69316 /* #497 'MDLBundleAssetResolver' => 'ModelIO.MDLBundleAssetResolver, Xamarin.Mac' */ },
		{ NULL, 0x69416 /* #498 'MDLCamera' => 'ModelIO.MDLCamera, Xamarin.Mac' */ },
		{ NULL, 0x6CA16 /* #499 'MDLTexture' => 'ModelIO.MDLTexture, Xamarin.Mac' */ },
		{ NULL, 0x69516 /* #500 'MDLCheckerboardTexture' => 'ModelIO.MDLCheckerboardTexture, Xamarin.Mac' */ },
		{ NULL, 0x69616 /* #501 'MDLColorSwatchTexture' => 'ModelIO.MDLColorSwatchTexture, Xamarin.Mac' */ },
		{ NULL, 0x69D16 /* #502 'MDLLightProbe' => 'ModelIO.MDLLightProbe, Xamarin.Mac' */ },
		{ NULL, 0x6A116 /* #503 'MDLLightProbeIrradianceDataSource' => 'ModelIO.MDLLightProbeIrradianceDataSource, Xamarin.Mac' */ },
		{ NULL, 0x6A216 /* #504 'MDLMaterial' => 'ModelIO.MDLMaterial, Xamarin.Mac' */ },
		{ NULL, 0x6A316 /* #505 'MDLMaterialProperty' => 'ModelIO.MDLMaterialProperty, Xamarin.Mac' */ },
		{ NULL, 0x6A416 /* #506 'MDLMaterialPropertyConnection' => 'ModelIO.MDLMaterialPropertyConnection, Xamarin.Mac' */ },
		{ NULL, 0x6A616 /* #507 'MDLMaterialPropertyNode' => 'ModelIO.MDLMaterialPropertyNode, Xamarin.Mac' */ },
		{ NULL, 0x6A516 /* #508 'MDLMaterialPropertyGraph' => 'ModelIO.MDLMaterialPropertyGraph, Xamarin.Mac' */ },
		{ NULL, 0x6A716 /* #509 'MDLMatrix4x4Array' => 'ModelIO.MDLMatrix4x4Array, Xamarin.Mac' */ },
		{ NULL, 0x6AE16 /* #510 'MDLMeshBufferData' => 'ModelIO.MDLMeshBufferData, Xamarin.Mac' */ },
		{ NULL, 0x6AF16 /* #511 'MDLMeshBufferDataAllocator' => 'ModelIO.MDLMeshBufferDataAllocator, Xamarin.Mac' */ },
		{ NULL, 0x6B016 /* #512 'MDLMeshBufferMap' => 'ModelIO.MDLMeshBufferMap, Xamarin.Mac' */ },
		{ NULL, 0x6B416 /* #513 'MDLMeshBufferZoneDefault' => 'ModelIO.MDLMeshBufferZoneDefault, Xamarin.Mac' */ },
		{ NULL, 0x6B716 /* #514 'MDLNoiseTexture' => 'ModelIO.MDLNoiseTexture, Xamarin.Mac' */ },
		{ NULL, 0x6B816 /* #515 'MDLNormalMapTexture' => 'ModelIO.MDLNormalMapTexture, Xamarin.Mac' */ },
		{ NULL, 0x6BA16 /* #516 'MDLObjectContainer' => 'ModelIO.MDLObjectContainer, Xamarin.Mac' */ },
		{ NULL, 0x6BE16 /* #517 'MDLPackedJointAnimation' => 'ModelIO.MDLPackedJointAnimation, Xamarin.Mac' */ },
		{ NULL, 0x6BF16 /* #518 'MDLPathAssetResolver' => 'ModelIO.MDLPathAssetResolver, Xamarin.Mac' */ },
		{ NULL, 0x6C016 /* #519 'MDLPhotometricLight' => 'ModelIO.MDLPhotometricLight, Xamarin.Mac' */ },
		{ NULL, 0x6C416 /* #520 'MDLScatteringFunction' => 'ModelIO.MDLScatteringFunction, Xamarin.Mac' */ },
		{ NULL, 0x6C216 /* #521 'MDLPhysicallyPlausibleScatteringFunction' => 'ModelIO.MDLPhysicallyPlausibleScatteringFunction, Xamarin.Mac' */ },
		{ NULL, 0x6C316 /* #522 'MDLRelativeAssetResolver' => 'ModelIO.MDLRelativeAssetResolver, Xamarin.Mac' */ },
		{ NULL, 0x6C516 /* #523 'MDLSkeleton' => 'ModelIO.MDLSkeleton, Xamarin.Mac' */ },
		{ NULL, 0x6C616 /* #524 'MDLSkyCubeTexture' => 'ModelIO.MDLSkyCubeTexture, Xamarin.Mac' */ },
		{ NULL, 0x6C716 /* #525 'MDLStereoscopicCamera' => 'ModelIO.MDLStereoscopicCamera, Xamarin.Mac' */ },
		{ NULL, 0x6C816 /* #526 'MDLSubmesh' => 'ModelIO.MDLSubmesh, Xamarin.Mac' */ },
		{ NULL, 0x6C916 /* #527 'MDLSubmeshTopology' => 'ModelIO.MDLSubmeshTopology, Xamarin.Mac' */ },
		{ NULL, 0x6CB16 /* #528 'MDLTextureFilter' => 'ModelIO.MDLTextureFilter, Xamarin.Mac' */ },
		{ NULL, 0x6CC16 /* #529 'MDLTextureSampler' => 'ModelIO.MDLTextureSampler, Xamarin.Mac' */ },
		{ NULL, 0x6CD16 /* #530 'MDLTransform' => 'ModelIO.MDLTransform, Xamarin.Mac' */ },
		{ NULL, 0x6D116 /* #531 'MDLTransformMatrixOp' => 'ModelIO.MDLTransformMatrixOp, Xamarin.Mac' */ },
		{ NULL, 0x6D516 /* #532 'MDLTransformRotateOp' => 'ModelIO.MDLTransformRotateOp, Xamarin.Mac' */ },
		{ NULL, 0x6D616 /* #533 'MDLTransformRotateXOp' => 'ModelIO.MDLTransformRotateXOp, Xamarin.Mac' */ },
		{ NULL, 0x6D716 /* #534 'MDLTransformRotateYOp' => 'ModelIO.MDLTransformRotateYOp, Xamarin.Mac' */ },
		{ NULL, 0x6D816 /* #535 'MDLTransformRotateZOp' => 'ModelIO.MDLTransformRotateZOp, Xamarin.Mac' */ },
		{ NULL, 0x6D916 /* #536 'MDLTransformScaleOp' => 'ModelIO.MDLTransformScaleOp, Xamarin.Mac' */ },
		{ NULL, 0x6DA16 /* #537 'MDLTransformStack' => 'ModelIO.MDLTransformStack, Xamarin.Mac' */ },
		{ NULL, 0x6DB16 /* #538 'MDLTransformTranslateOp' => 'ModelIO.MDLTransformTranslateOp, Xamarin.Mac' */ },
		{ NULL, 0x6DC16 /* #539 'MDLURLTexture' => 'ModelIO.MDLUrlTexture, Xamarin.Mac' */ },
		{ NULL, 0x6DD16 /* #540 'MDLVertexAttribute' => 'ModelIO.MDLVertexAttribute, Xamarin.Mac' */ },
		{ NULL, 0x6DE16 /* #541 'MDLVertexAttributeData' => 'ModelIO.MDLVertexAttributeData, Xamarin.Mac' */ },
		{ NULL, 0x6E016 /* #542 'MDLVertexBufferLayout' => 'ModelIO.MDLVertexBufferLayout, Xamarin.Mac' */ },
		{ NULL, 0x6E116 /* #543 'MDLVertexDescriptor' => 'ModelIO.MDLVertexDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x6E216 /* #544 'MDLVoxelArray' => 'ModelIO.MDLVoxelArray, Xamarin.Mac' */ },
		{ NULL, 0x77516 /* #545 'MPSKernel' => 'MetalPerformanceShaders.MPSKernel, Xamarin.Mac' */ },
		{ NULL, 0x6F916 /* #546 'MPSBinaryImageKernel' => 'MetalPerformanceShaders.MPSBinaryImageKernel, Xamarin.Mac' */ },
		{ NULL, 0x71216 /* #547 'MPSCNNKernel' => 'MetalPerformanceShaders.MPSCnnKernel, Xamarin.Mac' */ },
		{ NULL, 0x6FA16 /* #548 'MPSCNNBinaryConvolution' => 'MetalPerformanceShaders.MPSCnnBinaryConvolution, Xamarin.Mac' */ },
		{ NULL, 0x79016 /* #549 'MPSNNFilterNode' => 'MetalPerformanceShaders.MPSNNFilterNode, Xamarin.Mac' */ },
		{ NULL, 0x70616 /* #550 'MPSCNNConvolutionNode' => 'MetalPerformanceShaders.MPSCnnConvolutionNode, Xamarin.Mac' */ },
		{ NULL, 0x6FB16 /* #551 'MPSCNNBinaryConvolutionNode' => 'MetalPerformanceShaders.MPSCnnBinaryConvolutionNode, Xamarin.Mac' */ },
		{ NULL, 0x6FC16 /* #552 'MPSCNNBinaryFullyConnected' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnected, Xamarin.Mac' */ },
		{ NULL, 0x6FD16 /* #553 'MPSCNNBinaryFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnBinaryFullyConnectedNode, Xamarin.Mac' */ },
		{ NULL, 0x6FE16 /* #554 'MPSCNNBinaryKernel' => 'MetalPerformanceShaders.MPSCnnBinaryKernel, Xamarin.Mac' */ },
		{ NULL, 0x6FF16 /* #555 'MPSCNNConvolution' => 'MetalPerformanceShaders.MPSCnnConvolution, Xamarin.Mac' */ },
		{ NULL, 0x70316 /* #556 'MPSCNNConvolutionDataSource' => 'MetalPerformanceShaders.MPSCnnConvolutionDataSource, Xamarin.Mac' */ },
		{ NULL, 0x70416 /* #557 'MPSCNNConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnConvolutionDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7A216 /* #558 'MPSState' => 'MetalPerformanceShaders.MPSState, Xamarin.Mac' */ },
		{ NULL, 0x70716 /* #559 'MPSCNNConvolutionState' => 'MetalPerformanceShaders.MPSCnnConvolutionState, Xamarin.Mac' */ },
		{ NULL, 0x79916 /* #560 'MPSNNStateNode' => 'MetalPerformanceShaders.MPSNNStateNode, Xamarin.Mac' */ },
		{ NULL, 0x70816 /* #561 'MPSCNNConvolutionStateNode' => 'MetalPerformanceShaders.MPSCnnConvolutionStateNode, Xamarin.Mac' */ },
		{ NULL, 0x70916 /* #562 'MPSCNNConvolutionTranspose' => 'MetalPerformanceShaders.MPSCnnConvolutionTranspose, Xamarin.Mac' */ },
		{ NULL, 0x70A16 /* #563 'MPSCNNConvolutionTransposeNode' => 'MetalPerformanceShaders.MPSCnnConvolutionTransposeNode, Xamarin.Mac' */ },
		{ NULL, 0x70B16 /* #564 'MPSCNNCrossChannelNormalization' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalization, Xamarin.Mac' */ },
		{ NULL, 0x72F16 /* #565 'MPSCNNNormalizationNode' => 'MetalPerformanceShaders.MPSCnnNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x70C16 /* #566 'MPSCNNCrossChannelNormalizationNode' => 'MetalPerformanceShaders.MPSCnnCrossChannelNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x70D16 /* #567 'MPSCNNDepthWiseConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnDepthWiseConvolutionDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x73016 /* #568 'MPSCNNPooling' => 'MetalPerformanceShaders.MPSCnnPooling, Xamarin.Mac' */ },
		{ NULL, 0x70E16 /* #569 'MPSCNNDilatedPoolingMax' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMax, Xamarin.Mac' */ },
		{ NULL, 0x70F16 /* #570 'MPSCNNDilatedPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnDilatedPoolingMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x71016 /* #571 'MPSCNNFullyConnected' => 'MetalPerformanceShaders.MPSCnnFullyConnected, Xamarin.Mac' */ },
		{ NULL, 0x71116 /* #572 'MPSCNNFullyConnectedNode' => 'MetalPerformanceShaders.MPSCnnFullyConnectedNode, Xamarin.Mac' */ },
		{ NULL, 0x71316 /* #573 'MPSCNNLocalContrastNormalization' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalization, Xamarin.Mac' */ },
		{ NULL, 0x71416 /* #574 'MPSCNNLocalContrastNormalizationNode' => 'MetalPerformanceShaders.MPSCnnLocalContrastNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x71516 /* #575 'MPSCNNLogSoftMax' => 'MetalPerformanceShaders.MPSCnnLogSoftMax, Xamarin.Mac' */ },
		{ NULL, 0x71616 /* #576 'MPSCNNLogSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnLogSoftMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x71716 /* #577 'MPSCNNNeuron' => 'MetalPerformanceShaders.MPSCnnNeuron, Xamarin.Mac' */ },
		{ NULL, 0x71816 /* #578 'MPSCNNNeuronAbsolute' => 'MetalPerformanceShaders.MPSCnnNeuronAbsolute, Xamarin.Mac' */ },
		{ NULL, 0x72016 /* #579 'MPSCNNNeuronNode' => 'MetalPerformanceShaders.MPSCnnNeuronNode, Xamarin.Mac' */ },
		{ NULL, 0x71916 /* #580 'MPSCNNNeuronAbsoluteNode' => 'MetalPerformanceShaders.MPSCnnNeuronAbsoluteNode, Xamarin.Mac' */ },
		{ NULL, 0x71A16 /* #581 'MPSCNNNeuronELU' => 'MetalPerformanceShaders.MPSCnnNeuronElu, Xamarin.Mac' */ },
		{ NULL, 0x71B16 /* #582 'MPSCNNNeuronELUNode' => 'MetalPerformanceShaders.MPSCnnNeuronEluNode, Xamarin.Mac' */ },
		{ NULL, 0x71C16 /* #583 'MPSCNNNeuronHardSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoid, Xamarin.Mac' */ },
		{ NULL, 0x71D16 /* #584 'MPSCNNNeuronHardSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronHardSigmoidNode, Xamarin.Mac' */ },
		{ NULL, 0x71E16 /* #585 'MPSCNNNeuronLinear' => 'MetalPerformanceShaders.MPSCnnNeuronLinear, Xamarin.Mac' */ },
		{ NULL, 0x71F16 /* #586 'MPSCNNNeuronLinearNode' => 'MetalPerformanceShaders.MPSCnnNeuronLinearNode, Xamarin.Mac' */ },
		{ NULL, 0x72116 /* #587 'MPSCNNNeuronPReLU' => 'MetalPerformanceShaders.MPSCnnNeuronPReLU, Xamarin.Mac' */ },
		{ NULL, 0x72216 /* #588 'MPSCNNNeuronPReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronPReLUNode, Xamarin.Mac' */ },
		{ NULL, 0x72316 /* #589 'MPSCNNNeuronReLU' => 'MetalPerformanceShaders.MPSCnnNeuronReLU, Xamarin.Mac' */ },
		{ NULL, 0x72416 /* #590 'MPSCNNNeuronReLUN' => 'MetalPerformanceShaders.MPSCnnNeuronReLun, Xamarin.Mac' */ },
		{ NULL, 0x72516 /* #591 'MPSCNNNeuronReLUNNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLunNode, Xamarin.Mac' */ },
		{ NULL, 0x72616 /* #592 'MPSCNNNeuronReLUNode' => 'MetalPerformanceShaders.MPSCnnNeuronReLUNode, Xamarin.Mac' */ },
		{ NULL, 0x72716 /* #593 'MPSCNNNeuronSigmoid' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoid, Xamarin.Mac' */ },
		{ NULL, 0x72816 /* #594 'MPSCNNNeuronSigmoidNode' => 'MetalPerformanceShaders.MPSCnnNeuronSigmoidNode, Xamarin.Mac' */ },
		{ NULL, 0x72916 /* #595 'MPSCNNNeuronSoftPlus' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlus, Xamarin.Mac' */ },
		{ NULL, 0x72A16 /* #596 'MPSCNNNeuronSoftPlusNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftPlusNode, Xamarin.Mac' */ },
		{ NULL, 0x72B16 /* #597 'MPSCNNNeuronSoftSign' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSign, Xamarin.Mac' */ },
		{ NULL, 0x72C16 /* #598 'MPSCNNNeuronSoftSignNode' => 'MetalPerformanceShaders.MPSCnnNeuronSoftSignNode, Xamarin.Mac' */ },
		{ NULL, 0x72D16 /* #599 'MPSCNNNeuronTanH' => 'MetalPerformanceShaders.MPSCnnNeuronTanH, Xamarin.Mac' */ },
		{ NULL, 0x72E16 /* #600 'MPSCNNNeuronTanHNode' => 'MetalPerformanceShaders.MPSCnnNeuronTanHNode, Xamarin.Mac' */ },
		{ NULL, 0x73116 /* #601 'MPSCNNPoolingAverage' => 'MetalPerformanceShaders.MPSCnnPoolingAverage, Xamarin.Mac' */ },
		{ NULL, 0x73716 /* #602 'MPSCNNPoolingNode' => 'MetalPerformanceShaders.MPSCnnPoolingNode, Xamarin.Mac' */ },
		{ NULL, 0x73216 /* #603 'MPSCNNPoolingAverageNode' => 'MetalPerformanceShaders.MPSCnnPoolingAverageNode, Xamarin.Mac' */ },
		{ NULL, 0x73316 /* #604 'MPSCNNPoolingL2Norm' => 'MetalPerformanceShaders.MPSCnnPoolingL2Norm, Xamarin.Mac' */ },
		{ NULL, 0x73416 /* #605 'MPSCNNPoolingL2NormNode' => 'MetalPerformanceShaders.MPSCnnPoolingL2NormNode, Xamarin.Mac' */ },
		{ NULL, 0x73516 /* #606 'MPSCNNPoolingMax' => 'MetalPerformanceShaders.MPSCnnPoolingMax, Xamarin.Mac' */ },
		{ NULL, 0x73616 /* #607 'MPSCNNPoolingMaxNode' => 'MetalPerformanceShaders.MPSCnnPoolingMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x73816 /* #608 'MPSCNNSoftMax' => 'MetalPerformanceShaders.MPSCnnSoftMax, Xamarin.Mac' */ },
		{ NULL, 0x73916 /* #609 'MPSCNNSoftMaxNode' => 'MetalPerformanceShaders.MPSCnnSoftMaxNode, Xamarin.Mac' */ },
		{ NULL, 0x73A16 /* #610 'MPSCNNSpatialNormalization' => 'MetalPerformanceShaders.MPSCnnSpatialNormalization, Xamarin.Mac' */ },
		{ NULL, 0x73B16 /* #611 'MPSCNNSpatialNormalizationNode' => 'MetalPerformanceShaders.MPSCnnSpatialNormalizationNode, Xamarin.Mac' */ },
		{ NULL, 0x73C16 /* #612 'MPSCNNSubPixelConvolutionDescriptor' => 'MetalPerformanceShaders.MPSCnnSubPixelConvolutionDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x73D16 /* #613 'MPSCNNUpsampling' => 'MetalPerformanceShaders.MPSCnnUpsampling, Xamarin.Mac' */ },
		{ NULL, 0x73E16 /* #614 'MPSCNNUpsamplingBilinear' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinear, Xamarin.Mac' */ },
		{ NULL, 0x73F16 /* #615 'MPSCNNUpsamplingBilinearNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingBilinearNode, Xamarin.Mac' */ },
		{ NULL, 0x74016 /* #616 'MPSCNNUpsamplingNearest' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearest, Xamarin.Mac' */ },
		{ NULL, 0x74116 /* #617 'MPSCNNUpsamplingNearestNode' => 'MetalPerformanceShaders.MPSCnnUpsamplingNearestNode, Xamarin.Mac' */ },
		{ NULL, 0x79C16 /* #618 'MPSRNNDescriptor' => 'MetalPerformanceShaders.MPSRnnDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x74416 /* #619 'MPSGRUDescriptor' => 'MetalPerformanceShaders.MPSGRUDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x74716 /* #620 'MPSImage' => 'MetalPerformanceShaders.MPSImage, Xamarin.Mac' */ },
		{ NULL, 0x74D16 /* #621 'MPSImageArithmetic' => 'MetalPerformanceShaders.MPSImageArithmetic, Xamarin.Mac' */ },
		{ NULL, 0x74816 /* #622 'MPSImageAdd' => 'MetalPerformanceShaders.MPSImageAdd, Xamarin.Mac' */ },
		{ NULL, 0x7A616 /* #623 'MPSUnaryImageKernel' => 'MetalPerformanceShaders.MPSUnaryImageKernel, Xamarin.Mac' */ },
		{ NULL, 0x74B16 /* #624 'MPSImageAreaMax' => 'MetalPerformanceShaders.MPSImageAreaMax, Xamarin.Mac' */ },
		{ NULL, 0x74C16 /* #625 'MPSImageAreaMin' => 'MetalPerformanceShaders.MPSImageAreaMin, Xamarin.Mac' */ },
		{ NULL, 0x76416 /* #626 'MPSImageScale' => 'MetalPerformanceShaders.MPSImageScale, Xamarin.Mac' */ },
		{ NULL, 0x74E16 /* #627 'MPSImageBilinearScale' => 'MetalPerformanceShaders.MPSImageBilinearScale, Xamarin.Mac' */ },
		{ NULL, 0x74F16 /* #628 'MPSImageBox' => 'MetalPerformanceShaders.MPSImageBox, Xamarin.Mac' */ },
		{ NULL, 0x75016 /* #629 'MPSImageConversion' => 'MetalPerformanceShaders.MPSImageConversion, Xamarin.Mac' */ },
		{ NULL, 0x75116 /* #630 'MPSImageConvolution' => 'MetalPerformanceShaders.MPSImageConvolution, Xamarin.Mac' */ },
		{ NULL, 0x75216 /* #631 'MPSImageCopyToMatrix' => 'MetalPerformanceShaders.MPSImageCopyToMatrix, Xamarin.Mac' */ },
		{ NULL, 0x75316 /* #632 'MPSImageDescriptor' => 'MetalPerformanceShaders.MPSImageDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x75416 /* #633 'MPSImageDilate' => 'MetalPerformanceShaders.MPSImageDilate, Xamarin.Mac' */ },
		{ NULL, 0x75516 /* #634 'MPSImageDivide' => 'MetalPerformanceShaders.MPSImageDivide, Xamarin.Mac' */ },
		{ NULL, 0x75616 /* #635 'MPSImageErode' => 'MetalPerformanceShaders.MPSImageErode, Xamarin.Mac' */ },
		{ NULL, 0x75716 /* #636 'MPSImageFindKeypoints' => 'MetalPerformanceShaders.MPSImageFindKeypoints, Xamarin.Mac' */ },
		{ NULL, 0x75816 /* #637 'MPSImageGaussianBlur' => 'MetalPerformanceShaders.MPSImageGaussianBlur, Xamarin.Mac' */ },
		{ NULL, 0x76316 /* #638 'MPSImagePyramid' => 'MetalPerformanceShaders.MPSImagePyramid, Xamarin.Mac' */ },
		{ NULL, 0x75916 /* #639 'MPSImageGaussianPyramid' => 'MetalPerformanceShaders.MPSImageGaussianPyramid, Xamarin.Mac' */ },
		{ NULL, 0x75A16 /* #640 'MPSImageHistogram' => 'MetalPerformanceShaders.MPSImageHistogram, Xamarin.Mac' */ },
		{ NULL, 0x75B16 /* #641 'MPSImageHistogramEqualization' => 'MetalPerformanceShaders.MPSImageHistogramEqualization, Xamarin.Mac' */ },
		{ NULL, 0x75C16 /* #642 'MPSImageHistogramSpecification' => 'MetalPerformanceShaders.MPSImageHistogramSpecification, Xamarin.Mac' */ },
		{ NULL, 0x75D16 /* #643 'MPSImageIntegral' => 'MetalPerformanceShaders.MPSImageIntegral, Xamarin.Mac' */ },
		{ NULL, 0x75E16 /* #644 'MPSImageIntegralOfSquares' => 'MetalPerformanceShaders.MPSImageIntegralOfSquares, Xamarin.Mac' */ },
		{ NULL, 0x75F16 /* #645 'MPSImageLanczosScale' => 'MetalPerformanceShaders.MPSImageLanczosScale, Xamarin.Mac' */ },
		{ NULL, 0x76016 /* #646 'MPSImageLaplacian' => 'MetalPerformanceShaders.MPSImageLaplacian, Xamarin.Mac' */ },
		{ NULL, 0x76116 /* #647 'MPSImageMedian' => 'MetalPerformanceShaders.MPSImageMedian, Xamarin.Mac' */ },
		{ NULL, 0x76216 /* #648 'MPSImageMultiply' => 'MetalPerformanceShaders.MPSImageMultiply, Xamarin.Mac' */ },
		{ NULL, 0x76716 /* #649 'MPSImageSobel' => 'MetalPerformanceShaders.MPSImageSobel, Xamarin.Mac' */ },
		{ NULL, 0x76816 /* #650 'MPSImageStatisticsMean' => 'MetalPerformanceShaders.MPSImageStatisticsMean, Xamarin.Mac' */ },
		{ NULL, 0x76916 /* #651 'MPSImageStatisticsMeanAndVariance' => 'MetalPerformanceShaders.MPSImageStatisticsMeanAndVariance, Xamarin.Mac' */ },
		{ NULL, 0x76A16 /* #652 'MPSImageStatisticsMinAndMax' => 'MetalPerformanceShaders.MPSImageStatisticsMinAndMax, Xamarin.Mac' */ },
		{ NULL, 0x76B16 /* #653 'MPSImageSubtract' => 'MetalPerformanceShaders.MPSImageSubtract, Xamarin.Mac' */ },
		{ NULL, 0x76C16 /* #654 'MPSImageTent' => 'MetalPerformanceShaders.MPSImageTent, Xamarin.Mac' */ },
		{ NULL, 0x76D16 /* #655 'MPSImageThresholdBinary' => 'MetalPerformanceShaders.MPSImageThresholdBinary, Xamarin.Mac' */ },
		{ NULL, 0x76E16 /* #656 'MPSImageThresholdBinaryInverse' => 'MetalPerformanceShaders.MPSImageThresholdBinaryInverse, Xamarin.Mac' */ },
		{ NULL, 0x76F16 /* #657 'MPSImageThresholdToZero' => 'MetalPerformanceShaders.MPSImageThresholdToZero, Xamarin.Mac' */ },
		{ NULL, 0x77016 /* #658 'MPSImageThresholdToZeroInverse' => 'MetalPerformanceShaders.MPSImageThresholdToZeroInverse, Xamarin.Mac' */ },
		{ NULL, 0x77116 /* #659 'MPSImageThresholdTruncate' => 'MetalPerformanceShaders.MPSImageThresholdTruncate, Xamarin.Mac' */ },
		{ NULL, 0x77416 /* #660 'MPSImageTranspose' => 'MetalPerformanceShaders.MPSImageTranspose, Xamarin.Mac' */ },
		{ NULL, 0x77616 /* #661 'MPSLSTMDescriptor' => 'MetalPerformanceShaders.MPSLSTMDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x77716 /* #662 'MPSMatrix' => 'MetalPerformanceShaders.MPSMatrix, Xamarin.Mac' */ },
		{ NULL, 0x77816 /* #663 'MPSMatrixBinaryKernel' => 'MetalPerformanceShaders.MPSMatrixBinaryKernel, Xamarin.Mac' */ },
		{ NULL, 0x77916 /* #664 'MPSMatrixCopy' => 'MetalPerformanceShaders.MPSMatrixCopy, Xamarin.Mac' */ },
		{ NULL, 0x77A16 /* #665 'MPSMatrixCopyDescriptor' => 'MetalPerformanceShaders.MPSMatrixCopyDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x78816 /* #666 'MPSMatrixUnaryKernel' => 'MetalPerformanceShaders.MPSMatrixUnaryKernel, Xamarin.Mac' */ },
		{ NULL, 0x77B16 /* #667 'MPSMatrixDecompositionCholesky' => 'MetalPerformanceShaders.MPSMatrixDecompositionCholesky, Xamarin.Mac' */ },
		{ NULL, 0x77C16 /* #668 'MPSMatrixDecompositionLU' => 'MetalPerformanceShaders.MPSMatrixDecompositionLU, Xamarin.Mac' */ },
		{ NULL, 0x77D16 /* #669 'MPSMatrixDescriptor' => 'MetalPerformanceShaders.MPSMatrixDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x77E16 /* #670 'MPSMatrixFindTopK' => 'MetalPerformanceShaders.MPSMatrixFindTopK, Xamarin.Mac' */ },
		{ NULL, 0x77F16 /* #671 'MPSMatrixFullyConnected' => 'MetalPerformanceShaders.MPSMatrixFullyConnected, Xamarin.Mac' */ },
		{ NULL, 0x78316 /* #672 'MPSMatrixSoftMax' => 'MetalPerformanceShaders.MPSMatrixSoftMax, Xamarin.Mac' */ },
		{ NULL, 0x78016 /* #673 'MPSMatrixLogSoftMax' => 'MetalPerformanceShaders.MPSMatrixLogSoftMax, Xamarin.Mac' */ },
		{ NULL, 0x78116 /* #674 'MPSMatrixMultiplication' => 'MetalPerformanceShaders.MPSMatrixMultiplication, Xamarin.Mac' */ },
		{ NULL, 0x78216 /* #675 'MPSMatrixNeuron' => 'MetalPerformanceShaders.MPSMatrixNeuron, Xamarin.Mac' */ },
		{ NULL, 0x78416 /* #676 'MPSMatrixSolveCholesky' => 'MetalPerformanceShaders.MPSMatrixSolveCholesky, Xamarin.Mac' */ },
		{ NULL, 0x78516 /* #677 'MPSMatrixSolveLU' => 'MetalPerformanceShaders.MPSMatrixSolveLU, Xamarin.Mac' */ },
		{ NULL, 0x78616 /* #678 'MPSMatrixSolveTriangular' => 'MetalPerformanceShaders.MPSMatrixSolveTriangular, Xamarin.Mac' */ },
		{ NULL, 0x78716 /* #679 'MPSMatrixSum' => 'MetalPerformanceShaders.MPSMatrixSum, Xamarin.Mac' */ },
		{ NULL, 0x78916 /* #680 'MPSMatrixVectorMultiplication' => 'MetalPerformanceShaders.MPSMatrixVectorMultiplication, Xamarin.Mac' */ },
		{ NULL, 0x78C16 /* #681 'MPSNNBinaryArithmeticNode' => 'MetalPerformanceShaders.MPSNNBinaryArithmeticNode, Xamarin.Mac' */ },
		{ NULL, 0x78A16 /* #682 'MPSNNAdditionNode' => 'MetalPerformanceShaders.MPSNNAdditionNode, Xamarin.Mac' */ },
		{ NULL, 0x79816 /* #683 'MPSNNScaleNode' => 'MetalPerformanceShaders.MPSNNScaleNode, Xamarin.Mac' */ },
		{ NULL, 0x78B16 /* #684 'MPSNNBilinearScaleNode' => 'MetalPerformanceShaders.MPSNNBilinearScaleNode, Xamarin.Mac' */ },
		{ NULL, 0x78D16 /* #685 'MPSNNConcatenationNode' => 'MetalPerformanceShaders.MPSNNConcatenationNode, Xamarin.Mac' */ },
		{ NULL, 0x78E16 /* #686 'MPSNNDefaultPadding' => 'MetalPerformanceShaders.MPSNNDefaultPadding, Xamarin.Mac' */ },
		{ NULL, 0x78F16 /* #687 'MPSNNDivisionNode' => 'MetalPerformanceShaders.MPSNNDivisionNode, Xamarin.Mac' */ },
		{ NULL, 0x79216 /* #688 'MPSNNImageNode' => 'MetalPerformanceShaders.MPSNNImageNode, Xamarin.Mac' */ },
		{ NULL, 0x79316 /* #689 'MPSNNLanczosScaleNode' => 'MetalPerformanceShaders.MPSNNLanczosScaleNode, Xamarin.Mac' */ },
		{ NULL, 0x79416 /* #690 'MPSNNMultiplicationNode' => 'MetalPerformanceShaders.MPSNNMultiplicationNode, Xamarin.Mac' */ },
		{ NULL, 0x79A16 /* #691 'MPSNNSubtractionNode' => 'MetalPerformanceShaders.MPSNNSubtractionNode, Xamarin.Mac' */ },
		{ NULL, 0x79D16 /* #692 'MPSRNNImageInferenceLayer' => 'MetalPerformanceShaders.MPSRnnImageInferenceLayer, Xamarin.Mac' */ },
		{ NULL, 0x79E16 /* #693 'MPSRNNMatrixInferenceLayer' => 'MetalPerformanceShaders.MPSRnnMatrixInferenceLayer, Xamarin.Mac' */ },
		{ NULL, 0x79F16 /* #694 'MPSRNNRecurrentImageState' => 'MetalPerformanceShaders.MPSRnnRecurrentImageState, Xamarin.Mac' */ },
		{ NULL, 0x7A016 /* #695 'MPSRNNRecurrentMatrixState' => 'MetalPerformanceShaders.MPSRnnRecurrentMatrixState, Xamarin.Mac' */ },
		{ NULL, 0x7A116 /* #696 'MPSRNNSingleGateDescriptor' => 'MetalPerformanceShaders.MPSRnnSingleGateDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7A316 /* #697 'MPSTemporaryImage' => 'MetalPerformanceShaders.MPSTemporaryImage, Xamarin.Mac' */ },
		{ NULL, 0x7A416 /* #698 'MPSTemporaryMatrix' => 'MetalPerformanceShaders.MPSTemporaryMatrix, Xamarin.Mac' */ },
		{ NULL, 0x7A716 /* #699 'MPSVector' => 'MetalPerformanceShaders.MPSVector, Xamarin.Mac' */ },
		{ NULL, 0x7A516 /* #700 'MPSTemporaryVector' => 'MetalPerformanceShaders.MPSTemporaryVector, Xamarin.Mac' */ },
		{ NULL, 0x7A816 /* #701 'MPSVectorDescriptor' => 'MetalPerformanceShaders.MPSVectorDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7C016 /* #702 'MTKMesh' => 'MetalKit.MTKMesh, Xamarin.Mac' */ },
		{ NULL, 0x7C116 /* #703 'MTKMeshBuffer' => 'MetalKit.MTKMeshBuffer, Xamarin.Mac' */ },
		{ NULL, 0x7C216 /* #704 'MTKMeshBufferAllocator' => 'MetalKit.MTKMeshBufferAllocator, Xamarin.Mac' */ },
		{ NULL, 0x7C416 /* #705 'MTKSubmesh' => 'MetalKit.MTKSubmesh, Xamarin.Mac' */ },
		{ NULL, 0x7CD16 /* #706 'MTKView' => 'MetalKit.MTKView, Xamarin.Mac' */ },
		{ NULL, 0x7D016 /* #707 'MTKViewDelegate' => 'MetalKit.MTKViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x7D316 /* #708 'MTLArgument' => 'Metal.MTLArgument, Xamarin.Mac' */ },
		{ NULL, 0x7D616 /* #709 'MTLArgumentDescriptor' => 'Metal.MTLArgumentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x87916 /* #710 'MTLType' => 'Metal.MTLType, Xamarin.Mac' */ },
		{ NULL, 0x7DB16 /* #711 'MTLArrayType' => 'Metal.MTLArrayType, Xamarin.Mac' */ },
		{ NULL, 0x7DC16 /* #712 'MTLAttribute' => 'Metal.MTLAttribute, Xamarin.Mac' */ },
		{ NULL, 0x7DD16 /* #713 'MTLAttributeDescriptor' => 'Metal.MTLAttributeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7DE16 /* #714 'MTLAttributeDescriptorArray' => 'Metal.MTLAttributeDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x7EA16 /* #715 'MTLBufferLayoutDescriptor' => 'Metal.MTLBufferLayoutDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x7EB16 /* #716 'MTLBufferLayoutDescriptorArray' => 'Metal.MTLBufferLayoutDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x7EC16 /* #717 'MTLCaptureManager' => 'Metal.MTLCaptureManager, Xamarin.Mac' */ },
		{ NULL, 0x7EF16 /* #718 'Xamarin_Mac__Metal_MTLCaptureScope' => 'Metal.MTLCaptureScope, Xamarin.Mac' */ },
		{ NULL, 0x7FC16 /* #719 'MTLCompileOptions' => 'Metal.MTLCompileOptions, Xamarin.Mac' */ },
		{ NULL, 0x80016 /* #720 'MTLComputePipelineDescriptor' => 'Metal.MTLComputePipelineDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x80116 /* #721 'MTLComputePipelineReflection' => 'Metal.MTLComputePipelineReflection, Xamarin.Mac' */ },
		{ NULL, 0x80916 /* #722 'MTLDepthStencilDescriptor' => 'Metal.MTLDepthStencilDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x81216 /* #723 'MTLDrawable' => 'Metal.MTLDrawable, Xamarin.Mac' */ },
		{ NULL, 0x81B16 /* #724 'MTLFunctionConstant' => 'Metal.MTLFunctionConstant, Xamarin.Mac' */ },
		{ NULL, 0x81C16 /* #725 'MTLFunctionConstantValues' => 'Metal.MTLFunctionConstantValues, Xamarin.Mac' */ },
		{ NULL, 0x82116 /* #726 'MTLHeapDescriptor' => 'Metal.MTLHeapDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x82516 /* #727 'MTLIndirectCommandBufferDescriptor' => 'Metal.MTLIndirectCommandBufferDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x83716 /* #728 'MTLPipelineBufferDescriptor' => 'Metal.MTLPipelineBufferDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x83816 /* #729 'MTLPipelineBufferDescriptorArray' => 'Metal.MTLPipelineBufferDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x83B16 /* #730 'MTLPointerType' => 'Metal.MTLPointerType, Xamarin.Mac' */ },
		{ NULL, 0x84316 /* #731 'MTLRenderPassAttachmentDescriptor' => 'Metal.MTLRenderPassAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84416 /* #732 'MTLRenderPassColorAttachmentDescriptor' => 'Metal.MTLRenderPassColorAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84516 /* #733 'MTLRenderPassColorAttachmentDescriptorArray' => 'Metal.MTLRenderPassColorAttachmentDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x84616 /* #734 'MTLRenderPassDepthAttachmentDescriptor' => 'Metal.MTLRenderPassDepthAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84716 /* #735 'MTLRenderPassDescriptor' => 'Metal.MTLRenderPassDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84816 /* #736 'MTLRenderPassStencilAttachmentDescriptor' => 'Metal.MTLRenderPassStencilAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84916 /* #737 'MTLRenderPipelineColorAttachmentDescriptor' => 'Metal.MTLRenderPipelineColorAttachmentDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84A16 /* #738 'MTLRenderPipelineColorAttachmentDescriptorArray' => 'Metal.MTLRenderPipelineColorAttachmentDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x84B16 /* #739 'MTLRenderPipelineDescriptor' => 'Metal.MTLRenderPipelineDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x84E16 /* #740 'MTLRenderPipelineReflection' => 'Metal.MTLRenderPipelineReflection, Xamarin.Mac' */ },
		{ NULL, 0x85A16 /* #741 'MTLSamplerDescriptor' => 'Metal.MTLSamplerDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x86116 /* #742 'MTLSharedEventHandle' => 'Metal.MTLSharedEventHandle, Xamarin.Mac' */ },
		{ NULL, 0x86216 /* #743 'MTLSharedEventListener' => 'Metal.MTLSharedEventListener, Xamarin.Mac' */ },
		{ NULL, 0x86316 /* #744 'MTLSharedTextureHandle' => 'Metal.MTLSharedTextureHandle, Xamarin.Mac' */ },
		{ NULL, 0x86416 /* #745 'MTLStageInputOutputDescriptor' => 'Metal.MTLStageInputOutputDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x86516 /* #746 'MTLStencilDescriptor' => 'Metal.MTLStencilDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x86B16 /* #747 'MTLStructMember' => 'Metal.MTLStructMember, Xamarin.Mac' */ },
		{ NULL, 0x86C16 /* #748 'MTLStructType' => 'Metal.MTLStructType, Xamarin.Mac' */ },
		{ NULL, 0x87416 /* #749 'MTLTextureDescriptor' => 'Metal.MTLTextureDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x87516 /* #750 'MTLTextureReferenceType' => 'Metal.MTLTextureReferenceType, Xamarin.Mac' */ },
		{ NULL, 0x87A16 /* #751 'MTLVertexAttribute' => 'Metal.MTLVertexAttribute, Xamarin.Mac' */ },
		{ NULL, 0x87B16 /* #752 'MTLVertexAttributeDescriptor' => 'Metal.MTLVertexAttributeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x87C16 /* #753 'MTLVertexAttributeDescriptorArray' => 'Metal.MTLVertexAttributeDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x87D16 /* #754 'MTLVertexBufferLayoutDescriptor' => 'Metal.MTLVertexBufferLayoutDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x87E16 /* #755 'MTLVertexBufferLayoutDescriptorArray' => 'Metal.MTLVertexBufferLayoutDescriptorArray, Xamarin.Mac' */ },
		{ NULL, 0x87F16 /* #756 'MTLVertexDescriptor' => 'Metal.MTLVertexDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x8B816 /* #757 'MPRemoteCommandEvent' => 'MediaPlayer.MPRemoteCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x89D16 /* #758 'MPChangeLanguageOptionCommandEvent' => 'MediaPlayer.MPChangeLanguageOptionCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8B616 /* #759 'MPRemoteCommand' => 'MediaPlayer.MPRemoteCommand, Xamarin.Mac' */ },
		{ NULL, 0x89F16 /* #760 'MPChangePlaybackPositionCommand' => 'MediaPlayer.MPChangePlaybackPositionCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A016 /* #761 'MPChangePlaybackPositionCommandEvent' => 'MediaPlayer.MPChangePlaybackPositionCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8A116 /* #762 'MPChangePlaybackRateCommand' => 'MediaPlayer.MPChangePlaybackRateCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A216 /* #763 'MPChangePlaybackRateCommandEvent' => 'MediaPlayer.MPChangePlaybackRateCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8A316 /* #764 'MPChangeRepeatModeCommand' => 'MediaPlayer.MPChangeRepeatModeCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A416 /* #765 'MPChangeRepeatModeCommandEvent' => 'MediaPlayer.MPChangeRepeatModeCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8A516 /* #766 'MPChangeShuffleModeCommand' => 'MediaPlayer.MPChangeShuffleModeCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A616 /* #767 'MPChangeShuffleModeCommandEvent' => 'MediaPlayer.MPChangeShuffleModeCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8A716 /* #768 'MPContentItem' => 'MediaPlayer.MPContentItem, Xamarin.Mac' */ },
		{ NULL, 0x8A816 /* #769 'MPFeedbackCommand' => 'MediaPlayer.MPFeedbackCommand, Xamarin.Mac' */ },
		{ NULL, 0x8A916 /* #770 'MPFeedbackCommandEvent' => 'MediaPlayer.MPFeedbackCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8AB16 /* #771 'MPMediaItem' => 'MediaPlayer.MPMediaItem, Xamarin.Mac' */ },
		{ NULL, 0x8AC16 /* #772 'MPMediaItemArtwork' => 'MediaPlayer.MPMediaItemArtwork, Xamarin.Mac' */ },
		{ NULL, 0x8AE16 /* #773 'MPNowPlayingInfoCenter' => 'MediaPlayer.MPNowPlayingInfoCenter, Xamarin.Mac' */ },
		{ NULL, 0x8AF16 /* #774 'MPNowPlayingInfoLanguageOption' => 'MediaPlayer.MPNowPlayingInfoLanguageOption, Xamarin.Mac' */ },
		{ NULL, 0x8B016 /* #775 'MPNowPlayingInfoLanguageOptionGroup' => 'MediaPlayer.MPNowPlayingInfoLanguageOptionGroup, Xamarin.Mac' */ },
		{ NULL, 0x8B416 /* #776 'MPRatingCommand' => 'MediaPlayer.MPRatingCommand, Xamarin.Mac' */ },
		{ NULL, 0x8B516 /* #777 'MPRatingCommandEvent' => 'MediaPlayer.MPRatingCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8B716 /* #778 'MPRemoteCommandCenter' => 'MediaPlayer.MPRemoteCommandCenter, Xamarin.Mac' */ },
		{ NULL, 0x8BB16 /* #779 'MPSeekCommandEvent' => 'MediaPlayer.MPSeekCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8BF16 /* #780 'MPSkipIntervalCommandEvent' => 'MediaPlayer.MPSkipIntervalCommandEvent, Xamarin.Mac' */ },
		{ NULL, 0x8C316 /* #781 'MLMediaGroup' => 'MediaLibrary.MLMediaGroup, Xamarin.Mac' */ },
		{ NULL, 0x8C416 /* #782 'MLMediaLibrary' => 'MediaLibrary.MLMediaLibrary, Xamarin.Mac' */ },
		{ NULL, 0x8C516 /* #783 'MLMediaObject' => 'MediaLibrary.MLMediaObject, Xamarin.Mac' */ },
		{ NULL, 0x8C616 /* #784 'MLMediaSource' => 'MediaLibrary.MLMediaSource, Xamarin.Mac' */ },
		{ NULL, 0x8D416 /* #785 'MKAnnotation' => 'MapKit.MKAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x8D516 /* #786 'MKAnnotationView' => 'MapKit.MKAnnotationView, Xamarin.Mac' */ },
		{ NULL, 0x91616 /* #787 'MKShape' => 'MapKit.MKShape, Xamarin.Mac' */ },
		{ NULL, 0x8D816 /* #788 'MKCircle' => 'MapKit.MKCircle, Xamarin.Mac' */ },
		{ NULL, 0x90A16 /* #789 'MKOverlayRenderer' => 'MapKit.MKOverlayRenderer, Xamarin.Mac' */ },
		{ NULL, 0x90916 /* #790 'MKOverlayPathRenderer' => 'MapKit.MKOverlayPathRenderer, Xamarin.Mac' */ },
		{ NULL, 0x8D916 /* #791 'MKCircleRenderer' => 'MapKit.MKCircleRenderer, Xamarin.Mac' */ },
		{ NULL, 0x8DA16 /* #792 'MKClusterAnnotation' => 'MapKit.MKClusterAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x8DC16 /* #793 'MKDirectionsRequest' => 'MapKit.MKDirectionsRequest, Xamarin.Mac' */ },
		{ NULL, 0x8DD16 /* #794 'MKDirectionsResponse' => 'MapKit.MKDirectionsResponse, Xamarin.Mac' */ },
		{ NULL, 0x173116 /* #795 'NSFormatter' => 'Foundation.NSFormatter, Xamarin.Mac' */ },
		{ NULL, 0x8DF16 /* #796 'MKDistanceFormatter' => 'MapKit.MKDistanceFormatter, Xamarin.Mac' */ },
		{ NULL, 0x8E416 /* #797 'MKETAResponse' => 'MapKit.MKETAResponse, Xamarin.Mac' */ },
		{ NULL, 0x90316 /* #798 'MKMultiPoint' => 'MapKit.MKMultiPoint, Xamarin.Mac' */ },
		{ NULL, 0x91116 /* #799 'MKPolyline' => 'MapKit.MKPolyline, Xamarin.Mac' */ },
		{ NULL, 0x8E616 /* #800 'MKGeodesicPolyline' => 'MapKit.MKGeodesicPolyline, Xamarin.Mac' */ },
		{ NULL, 0x8E816 /* #801 'MKLocalSearchCompleter' => 'MapKit.MKLocalSearchCompleter, Xamarin.Mac' */ },
		{ NULL, 0x8EC16 /* #802 'MKLocalSearchCompleterDelegate' => 'MapKit.MKLocalSearchCompleterDelegate, Xamarin.Mac' */ },
		{ NULL, 0x8ED16 /* #803 'MKLocalSearchCompletion' => 'MapKit.MKLocalSearchCompletion, Xamarin.Mac' */ },
		{ NULL, 0x8EE16 /* #804 'MKLocalSearchRequest' => 'MapKit.MKLocalSearchRequest, Xamarin.Mac' */ },
		{ NULL, 0x8EF16 /* #805 'MKLocalSearchResponse' => 'MapKit.MKLocalSearchResponse, Xamarin.Mac' */ },
		{ NULL, 0x8F016 /* #806 'MKMapCamera' => 'MapKit.MKMapCamera, Xamarin.Mac' */ },
		{ NULL, 0x8F116 /* #807 'MKMapItem' => 'MapKit.MKMapItem, Xamarin.Mac' */ },
		{ NULL, 0x8F216 /* #808 'MKMapSnapshot' => 'MapKit.MKMapSnapshot, Xamarin.Mac' */ },
		{ NULL, 0x8F316 /* #809 'MKMapSnapshotOptions' => 'MapKit.MKMapSnapshotOptions, Xamarin.Mac' */ },
		{ NULL, 0x90216 /* #810 'MKMapViewDelegate' => 'MapKit.MKMapViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x90716 /* #811 'MKOverlay' => 'MapKit.MKOverlay, Xamarin.Mac' */ },
		{ NULL, 0x90C16 /* #812 'MKPinAnnotationView' => 'MapKit.MKPinAnnotationView, Xamarin.Mac' */ },
		{ NULL, 0xCDF16 /* #813 'CLPlacemark' => 'CoreLocation.CLPlacemark, Xamarin.Mac' */ },
		{ NULL, 0x90D16 /* #814 'MKPlacemark' => 'MapKit.MKPlacemark, Xamarin.Mac' */ },
		{ NULL, 0x90E16 /* #815 'MKPointAnnotation' => 'MapKit.MKPointAnnotation, Xamarin.Mac' */ },
		{ NULL, 0x90F16 /* #816 'MKPolygon' => 'MapKit.MKPolygon, Xamarin.Mac' */ },
		{ NULL, 0x91016 /* #817 'MKPolygonRenderer' => 'MapKit.MKPolygonRenderer, Xamarin.Mac' */ },
		{ NULL, 0x91216 /* #818 'MKPolylineRenderer' => 'MapKit.MKPolylineRenderer, Xamarin.Mac' */ },
		{ NULL, 0x91316 /* #819 'MKRoute' => 'MapKit.MKRoute, Xamarin.Mac' */ },
		{ NULL, 0x91416 /* #820 'MKRouteStep' => 'MapKit.MKRouteStep, Xamarin.Mac' */ },
		{ NULL, 0x91716 /* #821 'MKTileOverlay' => 'MapKit.MKTileOverlay, Xamarin.Mac' */ },
		{ NULL, 0x91816 /* #822 'MKTileOverlayRenderer' => 'MapKit.MKTileOverlayRenderer, Xamarin.Mac' */ },
		{ NULL, 0x91916 /* #823 'MKUserLocation' => 'MapKit.MKUserLocation, Xamarin.Mac' */ },
		{ NULL, 0x93716 /* #824 'JSContext' => 'JavaScriptCore.JSContext, Xamarin.Mac' */ },
		{ NULL, 0x93A16 /* #825 'Xamarin_Mac__JavaScriptCore_JSExport' => 'JavaScriptCore.JSExport, Xamarin.Mac' */ },
		{ NULL, 0x93B16 /* #826 'JSManagedValue' => 'JavaScriptCore.JSManagedValue, Xamarin.Mac' */ },
		{ NULL, 0x93D16 /* #827 'JSValue' => 'JavaScriptCore.JSValue, Xamarin.Mac' */ },
		{ NULL, 0x93E16 /* #828 'JSVirtualMachine' => 'JavaScriptCore.JSVirtualMachine, Xamarin.Mac' */ },
		{ NULL, 0x94316 /* #829 'ITLibAlbum' => 'iTunesLibrary.ITLibAlbum, Xamarin.Mac' */ },
		{ NULL, 0x94416 /* #830 'ITLibArtist' => 'iTunesLibrary.ITLibArtist, Xamarin.Mac' */ },
		{ NULL, 0x94516 /* #831 'ITLibArtwork' => 'iTunesLibrary.ITLibArtwork, Xamarin.Mac' */ },
		{ NULL, 0x94A16 /* #832 'ITLibMediaEntity' => 'iTunesLibrary.ITLibMediaEntity, Xamarin.Mac' */ },
		{ NULL, 0x94D16 /* #833 'ITLibMediaItem' => 'iTunesLibrary.ITLibMediaItem, Xamarin.Mac' */ },
		{ NULL, 0x95216 /* #834 'ITLibMediaItemVideoInfo' => 'iTunesLibrary.ITLibMediaItemVideoInfo, Xamarin.Mac' */ },
		{ NULL, 0x95316 /* #835 'ITLibPlaylist' => 'iTunesLibrary.ITLibPlaylist, Xamarin.Mac' */ },
		{ NULL, 0x95716 /* #836 'ITLibrary' => 'iTunesLibrary.ITLibrary, Xamarin.Mac' */ },
		{ NULL, 0x95B16 /* #837 'IOSurface' => 'IOSurface.IOSurface, Xamarin.Mac' */ },
		{ NULL, 0x97516 /* #838 'INIntentResolutionResult' => 'Intents.INIntentResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96416 /* #839 'INCallDestinationTypeResolutionResult' => 'Intents.INCallDestinationTypeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96516 /* #840 'INCallRecord' => 'Intents.INCallRecord, Xamarin.Mac' */ },
		{ NULL, 0x96816 /* #841 'INCallRecordTypeOptionsResolutionResult' => 'Intents.INCallRecordTypeOptionsResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96916 /* #842 'INCallRecordTypeResolutionResult' => 'Intents.INCallRecordTypeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96D16 /* #843 'INDateComponentsRange' => 'Intents.INDateComponentsRange, Xamarin.Mac' */ },
		{ NULL, 0x96E16 /* #844 'INDateComponentsRangeResolutionResult' => 'Intents.INDateComponentsRangeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x96F16 /* #845 'INImage' => 'Intents.INImage, Xamarin.Mac' */ },
		{ NULL, 0x97016 /* #846 'INIntent' => 'Intents.INIntent, Xamarin.Mac' */ },
		{ NULL, 0x97616 /* #847 'INIntentResponse' => 'Intents.INIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x97916 /* #848 'INMessage' => 'Intents.INMessage, Xamarin.Mac' */ },
		{ NULL, 0x97C16 /* #849 'INMessageAttributeOptionsResolutionResult' => 'Intents.INMessageAttributeOptionsResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x97D16 /* #850 'INMessageAttributeResolutionResult' => 'Intents.INMessageAttributeResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x97F16 /* #851 'INParameter' => 'Intents.INParameter, Xamarin.Mac' */ },
		{ NULL, 0x98016 /* #852 'INPerson' => 'Intents.INPerson, Xamarin.Mac' */ },
		{ NULL, 0x98116 /* #853 'INPersonHandle' => 'Intents.INPersonHandle, Xamarin.Mac' */ },
		{ NULL, 0x98716 /* #854 'INPersonResolutionResult' => 'Intents.INPersonResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x98916 /* #855 'INPlacemarkResolutionResult' => 'Intents.INPlacemarkResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x98B16 /* #856 'INRecurrenceRule' => 'Intents.INRecurrenceRule, Xamarin.Mac' */ },
		{ NULL, 0x98C16 /* #857 'INSearchCallHistoryIntent' => 'Intents.INSearchCallHistoryIntent, Xamarin.Mac' */ },
		{ NULL, 0x99016 /* #858 'INSearchCallHistoryIntentResponse' => 'Intents.INSearchCallHistoryIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x99216 /* #859 'INSearchForMessagesIntent' => 'Intents.INSearchForMessagesIntent, Xamarin.Mac' */ },
		{ NULL, 0x99616 /* #860 'INSearchForMessagesIntentResponse' => 'Intents.INSearchForMessagesIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x99816 /* #861 'INSendMessageIntent' => 'Intents.INSendMessageIntent, Xamarin.Mac' */ },
		{ NULL, 0x99C16 /* #862 'INSendMessageIntentResponse' => 'Intents.INSendMessageIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x99E16 /* #863 'INSendMessageRecipientResolutionResult' => 'Intents.INSendMessageRecipientResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x9A416 /* #864 'INSpeakableString' => 'Intents.INSpeakableString, Xamarin.Mac' */ },
		{ NULL, 0x9A516 /* #865 'INSpeakableStringResolutionResult' => 'Intents.INSpeakableStringResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x9A616 /* #866 'INStartAudioCallIntent' => 'Intents.INStartAudioCallIntent, Xamarin.Mac' */ },
		{ NULL, 0x9AA16 /* #867 'INStartAudioCallIntentResponse' => 'Intents.INStartAudioCallIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x9AC16 /* #868 'INStartVideoCallIntent' => 'Intents.INStartVideoCallIntent, Xamarin.Mac' */ },
		{ NULL, 0x9B016 /* #869 'INStartVideoCallIntentResponse' => 'Intents.INStartVideoCallIntentResponse, Xamarin.Mac' */ },
		{ NULL, 0x9B216 /* #870 'INStringResolutionResult' => 'Intents.INStringResolutionResult, Xamarin.Mac' */ },
		{ NULL, 0x9BA16 /* #871 'IKCameraDeviceViewDelegate' => 'ImageKit.IKCameraDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9C016 /* #872 'IKDeviceBrowserViewDelegate' => 'ImageKit.IKDeviceBrowserViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9C216 /* #873 'IKFilterBrowserView' => 'ImageKit.IKFilterBrowserView, Xamarin.Mac' */ },
		{ NULL, 0x9C516 /* #874 'IKFilterCustomUIProvider' => 'ImageKit.IKFilterCustomUIProvider, Xamarin.Mac' */ },
		{ NULL, 0x9C616 /* #875 'IKFilterUIView' => 'ImageKit.IKFilterUIView, Xamarin.Mac' */ },
		{ NULL, 0x9C716 /* #876 'IKImageBrowserCell' => 'ImageKit.IKImageBrowserCell, Xamarin.Mac' */ },
		{ NULL, 0x9CB16 /* #877 'IKImageBrowserDataSource' => 'ImageKit.IKImageBrowserDataSource, Xamarin.Mac' */ },
		{ NULL, 0x9CF16 /* #878 'IKImageBrowserDelegate' => 'ImageKit.IKImageBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9D316 /* #879 'IKImageBrowserItem' => 'ImageKit.IKImageBrowserItem, Xamarin.Mac' */ },
		{ NULL, 0x9D816 /* #880 'IKImageEditPanel' => 'ImageKit.IKImageEditPanel, Xamarin.Mac' */ },
		{ NULL, 0x9DC16 /* #881 'IKImageEditPanelDataSource' => 'ImageKit.IKImageEditPanelDataSource, Xamarin.Mac' */ },
		{ NULL, 0x9DD16 /* #882 'IKImageView' => 'ImageKit.IKImageView, Xamarin.Mac' */ },
		{ NULL, 0x9E016 /* #883 'IKPictureTaker' => 'ImageKit.IKPictureTaker, Xamarin.Mac' */ },
		{ NULL, 0x9E516 /* #884 'IKSaveOptionsDelegate' => 'ImageKit.IKSaveOptionsDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9ED16 /* #885 'IKScannerDeviceViewDelegate' => 'ImageKit.IKScannerDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x9EE16 /* #886 'IKSlideshow' => 'ImageKit.IKSlideshow, Xamarin.Mac' */ },
		{ NULL, 0x9F216 /* #887 'IKSlideshowDataSource' => 'ImageKit.IKSlideshowDataSource, Xamarin.Mac' */ },
		{ NULL, 0xA1916 /* #888 'GLKBaseEffect' => 'GLKit.GLKBaseEffect, Xamarin.Mac' */ },
		{ NULL, 0xA1A16 /* #889 'GLKEffectProperty' => 'GLKit.GLKEffectProperty, Xamarin.Mac' */ },
		{ NULL, 0xA1B16 /* #890 'GLKEffectPropertyFog' => 'GLKit.GLKEffectPropertyFog, Xamarin.Mac' */ },
		{ NULL, 0xA1C16 /* #891 'GLKEffectPropertyLight' => 'GLKit.GLKEffectPropertyLight, Xamarin.Mac' */ },
		{ NULL, 0xA1D16 /* #892 'GLKEffectPropertyMaterial' => 'GLKit.GLKEffectPropertyMaterial, Xamarin.Mac' */ },
		{ NULL, 0xA1E16 /* #893 'GLKEffectPropertyTexture' => 'GLKit.GLKEffectPropertyTexture, Xamarin.Mac' */ },
		{ NULL, 0xA1F16 /* #894 'GLKEffectPropertyTransform' => 'GLKit.GLKEffectPropertyTransform, Xamarin.Mac' */ },
		{ NULL, 0xA2016 /* #895 'GLKMesh' => 'GLKit.GLKMesh, Xamarin.Mac' */ },
		{ NULL, 0xA2116 /* #896 'GLKMeshBuffer' => 'GLKit.GLKMeshBuffer, Xamarin.Mac' */ },
		{ NULL, 0xA2216 /* #897 'GLKMeshBufferAllocator' => 'GLKit.GLKMeshBufferAllocator, Xamarin.Mac' */ },
		{ NULL, 0xA2616 /* #898 'GLKNamedEffect' => 'GLKit.GLKNamedEffect, Xamarin.Mac' */ },
		{ NULL, 0xA2716 /* #899 'GLKReflectionMapEffect' => 'GLKit.GLKReflectionMapEffect, Xamarin.Mac' */ },
		{ NULL, 0xA2816 /* #900 'GLKSkyboxEffect' => 'GLKit.GLKSkyboxEffect, Xamarin.Mac' */ },
		{ NULL, 0xA2916 /* #901 'GLKSubmesh' => 'GLKit.GLKSubmesh, Xamarin.Mac' */ },
		{ NULL, 0xA2A16 /* #902 'GLKTextureInfo' => 'GLKit.GLKTextureInfo, Xamarin.Mac' */ },
		{ NULL, 0xA4816 /* #903 'GKComponent' => 'GameplayKit.GKComponent, Xamarin.Mac' */ },
		{ NULL, 0xA3B16 /* #904 'GKAgent' => 'GameplayKit.GKAgent, Xamarin.Mac' */ },
		{ NULL, 0xA3C16 /* #905 'GKAgent2D' => 'GameplayKit.GKAgent2D, Xamarin.Mac' */ },
		{ NULL, 0xA3D16 /* #906 'GKAgent3D' => 'GameplayKit.GKAgent3D, Xamarin.Mac' */ },
		{ NULL, 0xA4116 /* #907 'GKAgentDelegate' => 'GameplayKit.GKAgentDelegate, Xamarin.Mac' */ },
		{ NULL, 0xA7616 /* #908 'GKRandomSource' => 'GameplayKit.GKRandomSource, Xamarin.Mac' */ },
		{ NULL, 0xA4216 /* #909 'GKARC4RandomSource' => 'GameplayKit.GKARC4RandomSource, Xamarin.Mac' */ },
		{ NULL, 0xA4316 /* #910 'GKBehavior' => 'GameplayKit.GKBehavior, Xamarin.Mac' */ },
		{ NULL, 0xA6816 /* #911 'GKNoiseSource' => 'GameplayKit.GKNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4716 /* #912 'GKCoherentNoiseSource' => 'GameplayKit.GKCoherentNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4416 /* #913 'GKBillowNoiseSource' => 'GameplayKit.GKBillowNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4516 /* #914 'GKCheckerboardNoiseSource' => 'GameplayKit.GKCheckerboardNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA6A16 /* #915 'GKObstacle' => 'GameplayKit.GKObstacle, Xamarin.Mac' */ },
		{ NULL, 0xA4616 /* #916 'GKCircleObstacle' => 'GameplayKit.GKCircleObstacle, Xamarin.Mac' */ },
		{ NULL, 0xA4916 /* #917 'GKComponentSystem' => 'GameplayKit.GKComponentSystem`1, Xamarin.Mac' */ },
		{ NULL, 0xA4A16 /* #918 'GKCompositeBehavior' => 'GameplayKit.GKCompositeBehavior, Xamarin.Mac' */ },
		{ NULL, 0xA4B16 /* #919 'GKConstantNoiseSource' => 'GameplayKit.GKConstantNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4C16 /* #920 'GKCylindersNoiseSource' => 'GameplayKit.GKCylindersNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA4D16 /* #921 'GKDecisionNode' => 'GameplayKit.GKDecisionNode, Xamarin.Mac' */ },
		{ NULL, 0xA4E16 /* #922 'GKDecisionTree' => 'GameplayKit.GKDecisionTree, Xamarin.Mac' */ },
		{ NULL, 0xA4F16 /* #923 'GKEntity' => 'GameplayKit.GKEntity, Xamarin.Mac' */ },
		{ NULL, 0xA7516 /* #924 'GKRandomDistribution' => 'GameplayKit.GKRandomDistribution, Xamarin.Mac' */ },
		{ NULL, 0xA5816 /* #925 'GKGaussianDistribution' => 'GameplayKit.GKGaussianDistribution, Xamarin.Mac' */ },
		{ NULL, 0xA5916 /* #926 'GKGoal' => 'GameplayKit.GKGoal, Xamarin.Mac' */ },
		{ NULL, 0xA5A16 /* #927 'GKGraph' => 'GameplayKit.GKGraph, Xamarin.Mac' */ },
		{ NULL, 0xA5B16 /* #928 'GKGraphNode' => 'GameplayKit.GKGraphNode, Xamarin.Mac' */ },
		{ NULL, 0xA5C16 /* #929 'GKGraphNode2D' => 'GameplayKit.GKGraphNode2D, Xamarin.Mac' */ },
		{ NULL, 0xA5D16 /* #930 'GKGraphNode3D' => 'GameplayKit.GKGraphNode3D, Xamarin.Mac' */ },
		{ NULL, 0xA5E16 /* #931 'GKGridGraph' => 'GameplayKit.GKGridGraph, Xamarin.Mac' */ },
		{ NULL, 0xA5F16 /* #932 'GKGridGraphNode' => 'GameplayKit.GKGridGraphNode, Xamarin.Mac' */ },
		{ NULL, 0xA6016 /* #933 'GKLinearCongruentialRandomSource' => 'GameplayKit.GKLinearCongruentialRandomSource, Xamarin.Mac' */ },
		{ NULL, 0xA6116 /* #934 'GKMersenneTwisterRandomSource' => 'GameplayKit.GKMersenneTwisterRandomSource, Xamarin.Mac' */ },
		{ NULL, 0xA6216 /* #935 'GKMeshGraph' => 'GameplayKit.GKMeshGraph`1, Xamarin.Mac' */ },
		{ NULL, 0xA6416 /* #936 'GKMinmaxStrategist' => 'GameplayKit.GKMinMaxStrategist, Xamarin.Mac' */ },
		{ NULL, 0xA6516 /* #937 'GKMonteCarloStrategist' => 'GameplayKit.GKMonteCarloStrategist, Xamarin.Mac' */ },
		{ NULL, 0xA6616 /* #938 'GKNoise' => 'GameplayKit.GKNoise, Xamarin.Mac' */ },
		{ NULL, 0xA6716 /* #939 'GKNoiseMap' => 'GameplayKit.GKNoiseMap, Xamarin.Mac' */ },
		{ NULL, 0xA7A16 /* #940 'GKRule' => 'GameplayKit.GKRule, Xamarin.Mac' */ },
		{ NULL, 0xA6916 /* #941 'GKNSPredicateRule' => 'GameplayKit.GKNSPredicateRule, Xamarin.Mac' */ },
		{ NULL, 0xA6B16 /* #942 'GKObstacleGraph' => 'GameplayKit.GKObstacleGraph, Xamarin.Mac' */ },
		{ NULL, 0xA6C16 /* #943 'GKOctree' => 'GameplayKit.GKOctree`1, Xamarin.Mac' */ },
		{ NULL, 0xA6D16 /* #944 'GKOctreeNode' => 'GameplayKit.GKOctreeNode, Xamarin.Mac' */ },
		{ NULL, 0xA6E16 /* #945 'GKPath' => 'GameplayKit.GKPath, Xamarin.Mac' */ },
		{ NULL, 0xA6F16 /* #946 'GKPerlinNoiseSource' => 'GameplayKit.GKPerlinNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA7016 /* #947 'GKPolygonObstacle' => 'GameplayKit.GKPolygonObstacle, Xamarin.Mac' */ },
		{ NULL, 0xA7116 /* #948 'GKQuadtree' => 'GameplayKit.GKQuadTree, Xamarin.Mac' */ },
		{ NULL, 0xA7216 /* #949 'GKQuadtreeNode' => 'GameplayKit.GKQuadTreeNode, Xamarin.Mac' */ },
		{ NULL, 0xA7716 /* #950 'GKRidgedNoiseSource' => 'GameplayKit.GKRidgedNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA7816 /* #951 'GKRTree' => 'GameplayKit.GKRTree`1, Xamarin.Mac' */ },
		{ NULL, 0xA7B16 /* #952 'GKRuleSystem' => 'GameplayKit.GKRuleSystem, Xamarin.Mac' */ },
		{ NULL, 0xA7C16 /* #953 'GKScene' => 'GameplayKit.GKScene, Xamarin.Mac' */ },
		{ NULL, 0xA7F16 /* #954 'GKSCNNodeComponent' => 'GameplayKit.GKSCNNodeComponent, Xamarin.Mac' */ },
		{ NULL, 0xA8016 /* #955 'GKShuffledDistribution' => 'GameplayKit.GKShuffledDistribution, Xamarin.Mac' */ },
		{ NULL, 0xA8116 /* #956 'GKSKNodeComponent' => 'GameplayKit.GKSKNodeComponent, Xamarin.Mac' */ },
		{ NULL, 0xA8216 /* #957 'GKSphereObstacle' => 'GameplayKit.GKSphereObstacle, Xamarin.Mac' */ },
		{ NULL, 0xA8316 /* #958 'GKSpheresNoiseSource' => 'GameplayKit.GKSpheresNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA8416 /* #959 'GKState' => 'GameplayKit.GKState, Xamarin.Mac' */ },
		{ NULL, 0xA8516 /* #960 'GKStateMachine' => 'GameplayKit.GKStateMachine, Xamarin.Mac' */ },
		{ NULL, 0xA8816 /* #961 'GKVoronoiNoiseSource' => 'GameplayKit.GKVoronoiNoiseSource, Xamarin.Mac' */ },
		{ NULL, 0xA9B16 /* #962 'GKChallenge' => 'GameKit.GKChallenge, Xamarin.Mac' */ },
		{ NULL, 0xA9316 /* #963 'GKAchievementChallenge' => 'GameKit.GKAchievementChallenge, Xamarin.Mac' */ },
		{ NULL, 0xA9816 /* #964 'GKAchievementViewControllerDelegate' => 'GameKit.GKAchievementViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xA9A16 /* #965 'GKBasePlayer' => 'GameKit.GKBasePlayer, Xamarin.Mac' */ },
		{ NULL, 0xAA016 /* #966 'GKChallengeEventHandlerDelegate' => 'GameKit.GKChallengeEventHandlerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAA416 /* #967 'GKChallengeListener' => 'GameKit.GKChallengeListener, Xamarin.Mac' */ },
		{ NULL, 0xAA616 /* #968 'GKChallengesViewController' => 'GameKit.GKChallengesViewController, Xamarin.Mac' */ },
		{ NULL, 0xAA916 /* #969 'GKChallengesViewControllerDelegate' => 'GameKit.GKChallengesViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAAA16 /* #970 'GKCloudPlayer' => 'GameKit.GKCloudPlayer, Xamarin.Mac' */ },
		{ NULL, 0xAAC16 /* #971 'GKDialogController' => 'GameKit.GKDialogController, Xamarin.Mac' */ },
		{ NULL, 0xAB216 /* #972 'GKFriendRequestComposeViewControllerDelegate' => 'GameKit.GKFriendRequestComposeViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAB516 /* #973 'GKGameCenterControllerDelegate' => 'GameKit.GKGameCenterControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xABE16 /* #974 'GKInvite' => 'GameKit.GKInvite, Xamarin.Mac' */ },
		{ NULL, 0xAC316 /* #975 'GKInviteEventListener' => 'GameKit.GKInviteEventListener, Xamarin.Mac' */ },
		{ NULL, 0xACD16 /* #976 'GKLeaderboardViewControllerDelegate' => 'GameKit.GKLeaderboardViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAD216 /* #977 'GKLocalPlayerListener' => 'GameKit.GKLocalPlayerListener, Xamarin.Mac' */ },
		{ NULL, 0xADE16 /* #978 'GKMatchDelegate' => 'GameKit.GKMatchDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAE916 /* #979 'GKMatchmakerViewControllerDelegate' => 'GameKit.GKMatchmakerViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xAEA16 /* #980 'GKMatchRequest' => 'GameKit.GKMatchRequest, Xamarin.Mac' */ },
		{ NULL, 0xAF616 /* #981 'GKSavedGameListener' => 'GameKit.GKSavedGameListener, Xamarin.Mac' */ },
		{ NULL, 0xAF816 /* #982 'GKScoreChallenge' => 'GameKit.GKScoreChallenge, Xamarin.Mac' */ },
		{ NULL, 0xAFA16 /* #983 'GKSession' => 'GameKit.GKSession, Xamarin.Mac' */ },
		{ NULL, 0xAFE16 /* #984 'GKSessionDelegate' => 'GameKit.GKSessionDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB0116 /* #985 'GKTurnBasedEventHandler' => 'GameKit.GKTurnBasedEventHandler, Xamarin.Mac' */ },
		{ NULL, 0xB0516 /* #986 'GKTurnBasedEventHandlerDelegate' => 'GameKit.GKTurnBasedEventHandlerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB0916 /* #987 'GKTurnBasedEventListener' => 'GameKit.GKTurnBasedEventListener, Xamarin.Mac' */ },
		{ NULL, 0xB0B16 /* #988 'GKTurnBasedExchangeReply' => 'GameKit.GKTurnBasedExchangeReply, Xamarin.Mac' */ },
		{ NULL, 0xB0E16 /* #989 'GKTurnBasedMatchmakerViewController' => 'GameKit.GKTurnBasedMatchmakerViewController, Xamarin.Mac' */ },
		{ NULL, 0xB1116 /* #990 'GKTurnBasedMatchmakerViewControllerDelegate' => 'GameKit.GKTurnBasedMatchmakerViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB1416 /* #991 'GKTurnBasedParticipant' => 'GameKit.GKTurnBasedParticipant, Xamarin.Mac' */ },
		{ NULL, 0xB1816 /* #992 'GKVoiceChat' => 'GameKit.GKVoiceChat, Xamarin.Mac' */ },
		{ NULL, 0xB3416 /* #993 'GCControllerElement' => 'GameController.GCControllerElement, Xamarin.Mac' */ },
		{ NULL, 0xB3116 /* #994 'GCControllerAxisInput' => 'GameController.GCControllerAxisInput, Xamarin.Mac' */ },
		{ NULL, 0xB3216 /* #995 'GCControllerButtonInput' => 'GameController.GCControllerButtonInput, Xamarin.Mac' */ },
		{ NULL, 0xB3316 /* #996 'GCControllerDirectionPad' => 'GameController.GCControllerDirectionPad, Xamarin.Mac' */ },
		{ NULL, 0xB3516 /* #997 'GCEventViewController' => 'GameController.GCEventViewController, Xamarin.Mac' */ },
		{ NULL, 0xB3616 /* #998 'GCExtendedGamepad' => 'GameController.GCExtendedGamepad, Xamarin.Mac' */ },
		{ NULL, 0xB3716 /* #999 'GCExtendedGamepadSnapshot' => 'GameController.GCExtendedGamepadSnapshot, Xamarin.Mac' */ },
		{ NULL, 0xB3816 /* #1000 'GCGamepad' => 'GameController.GCGamepad, Xamarin.Mac' */ },
		{ NULL, 0xB3916 /* #1001 'GCGamepadSnapshot' => 'GameController.GCGamepadSnapshot, Xamarin.Mac' */ },
		{ NULL, 0xB3A16 /* #1002 'GCMicroGamepad' => 'GameController.GCMicroGamepad, Xamarin.Mac' */ },
		{ NULL, 0xB3B16 /* #1003 'GCMicroGamepadSnapshot' => 'GameController.GCMicroGamepadSnapshot, Xamarin.Mac' */ },
		{ NULL, 0xB3C16 /* #1004 'GCMotion' => 'GameController.GCMotion, Xamarin.Mac' */ },
		{ NULL, 0xB5216 /* #1005 'EAAccessoryDelegate' => 'ExternalAccessory.EAAccessoryDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB5616 /* #1006 'EASession' => 'ExternalAccessory.EASession, Xamarin.Mac' */ },
		{ NULL, 0xB6916 /* #1007 'EKObject' => 'EventKit.EKObject, Xamarin.Mac' */ },
		{ NULL, 0xB5816 /* #1008 'EKAlarm' => 'EventKit.EKAlarm, Xamarin.Mac' */ },
		{ NULL, 0xB5C16 /* #1009 'EKCalendar' => 'EventKit.EKCalendar, Xamarin.Mac' */ },
		{ NULL, 0xB5E16 /* #1010 'EKCalendarItem' => 'EventKit.EKCalendarItem, Xamarin.Mac' */ },
		{ NULL, 0xB6516 /* #1011 'EKEvent' => 'EventKit.EKEvent, Xamarin.Mac' */ },
		{ NULL, 0xB6A16 /* #1012 'EKParticipant' => 'EventKit.EKParticipant, Xamarin.Mac' */ },
		{ NULL, 0xB6F16 /* #1013 'EKRecurrenceDayOfWeek' => 'EventKit.EKRecurrenceDayOfWeek, Xamarin.Mac' */ },
		{ NULL, 0xB7016 /* #1014 'EKRecurrenceEnd' => 'EventKit.EKRecurrenceEnd, Xamarin.Mac' */ },
		{ NULL, 0xB7216 /* #1015 'EKRecurrenceRule' => 'EventKit.EKRecurrenceRule, Xamarin.Mac' */ },
		{ NULL, 0xB7316 /* #1016 'EKReminder' => 'EventKit.EKReminder, Xamarin.Mac' */ },
		{ NULL, 0xB7516 /* #1017 'EKSource' => 'EventKit.EKSource, Xamarin.Mac' */ },
		{ NULL, 0xB7816 /* #1018 'EKStructuredLocation' => 'EventKit.EKStructuredLocation, Xamarin.Mac' */ },
		{ NULL, 0xB7B16 /* #1019 'CW8021XProfile' => 'CoreWlan.CW8021XProfile, Xamarin.Mac' */ },
		{ NULL, 0xB7C16 /* #1020 'CWChannel' => 'CoreWlan.CWChannel, Xamarin.Mac' */ },
		{ NULL, 0xB7D16 /* #1021 'CWConfiguration' => 'CoreWlan.CWConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xB8116 /* #1022 'CWEventDelegate' => 'CoreWlan.CWEventDelegate, Xamarin.Mac' */ },
		{ NULL, 0xB8316 /* #1023 'CWMutableConfiguration' => 'CoreWlan.CWMutableConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xB8616 /* #1024 'CWNetworkProfile' => 'CoreWlan.CWNetworkProfile, Xamarin.Mac' */ },
		{ NULL, 0xB8416 /* #1025 'CWMutableNetworkProfile' => 'CoreWlan.CWMutableNetworkProfile, Xamarin.Mac' */ },
		{ NULL, 0xB8516 /* #1026 'CWNetwork' => 'CoreWlan.CWNetwork, Xamarin.Mac' */ },
		{ NULL, 0xB8716 /* #1027 'CWWiFiClient' => 'CoreWlan.CWWiFiClient, Xamarin.Mac' */ },
		{ NULL, 0xB8816 /* #1028 'CWWirelessProfile' => 'CoreWlan.CWWirelessProfile, Xamarin.Mac' */ },
		{ NULL, 0xC3416 /* #1029 'CSCustomAttributeKey' => 'CoreSpotlight.CSCustomAttributeKey, Xamarin.Mac' */ },
		{ NULL, 0xC3716 /* #1030 'CSIndexExtensionRequestHandler' => 'CoreSpotlight.CSIndexExtensionRequestHandler, Xamarin.Mac' */ },
		{ NULL, 0x17CA16 /* #1031 'NSString' => 'Foundation.NSString, Xamarin.Mac' */ },
		{ NULL, 0xC3816 /* #1032 'CSLocalizedString' => 'CoreSpotlight.CSLocalizedString, Xamarin.Mac' */ },
		{ NULL, 0xC3A16 /* #1033 'CSPerson' => 'CoreSpotlight.CSPerson, Xamarin.Mac' */ },
		{ NULL, 0xC4016 /* #1034 'CSSearchableIndexDelegate' => 'CoreSpotlight.CSSearchableIndexDelegate, Xamarin.Mac' */ },
		{ NULL, 0xC4116 /* #1035 'CSSearchableItem' => 'CoreSpotlight.CSSearchableItem, Xamarin.Mac' */ },
		{ NULL, 0xC4216 /* #1036 'CSSearchableItemAttributeSet' => 'CoreSpotlight.CSSearchableItemAttributeSet, Xamarin.Mac' */ },
		{ NULL, 0xC4316 /* #1037 'CSSearchQuery' => 'CoreSpotlight.CSSearchQuery, Xamarin.Mac' */ },
		{ NULL, 0xC5516 /* #1038 'MLArrayBatchProvider' => 'CoreML.MLArrayBatchProvider, Xamarin.Mac' */ },
		{ NULL, 0xC5F16 /* #1039 'Xamarin_Mac__CoreML_MLCustomModel' => 'CoreML.MLCustomModel, Xamarin.Mac' */ },
		{ NULL, 0xC6016 /* #1040 'MLDictionaryConstraint' => 'CoreML.MLDictionaryConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC6116 /* #1041 'MLDictionaryFeatureProvider' => 'CoreML.MLDictionaryFeatureProvider, Xamarin.Mac' */ },
		{ NULL, 0xC6216 /* #1042 'MLFeatureDescription' => 'CoreML.MLFeatureDescription, Xamarin.Mac' */ },
		{ NULL, 0xC6616 /* #1043 'MLFeatureValue' => 'CoreML.MLFeatureValue, Xamarin.Mac' */ },
		{ NULL, 0xC6716 /* #1044 'MLImageConstraint' => 'CoreML.MLImageConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC6816 /* #1045 'MLImageSize' => 'CoreML.MLImageSize, Xamarin.Mac' */ },
		{ NULL, 0xC6916 /* #1046 'MLImageSizeConstraint' => 'CoreML.MLImageSizeConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC6B16 /* #1047 'MLModel' => 'CoreML.MLModel, Xamarin.Mac' */ },
		{ NULL, 0xC6C16 /* #1048 'MLModelConfiguration' => 'CoreML.MLModelConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xC6D16 /* #1049 'MLModelDescription' => 'CoreML.MLModelDescription, Xamarin.Mac' */ },
		{ NULL, 0xC7316 /* #1050 'MLMultiArrayConstraint' => 'CoreML.MLMultiArrayConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC7516 /* #1051 'MLMultiArrayShapeConstraint' => 'CoreML.MLMultiArrayShapeConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC7716 /* #1052 'MLPredictionOptions' => 'CoreML.MLPredictionOptions, Xamarin.Mac' */ },
		{ NULL, 0xC7816 /* #1053 'MLSequence' => 'CoreML.MLSequence, Xamarin.Mac' */ },
		{ NULL, 0xC7916 /* #1054 'MLSequenceConstraint' => 'CoreML.MLSequenceConstraint, Xamarin.Mac' */ },
		{ NULL, 0xC7A16 /* #1055 'MIDICIProfile' => 'CoreMidi.MidiCIProfile, Xamarin.Mac' */ },
		{ NULL, 0xC7B16 /* #1056 'MIDICIProfileState' => 'CoreMidi.MidiCIProfileState, Xamarin.Mac' */ },
		{ NULL, 0xC7C16 /* #1057 'MIDICISession' => 'CoreMidi.MidiCISession, Xamarin.Mac' */ },
		{ NULL, 0xCE116 /* #1058 'CLRegion' => 'CoreLocation.CLRegion, Xamarin.Mac' */ },
		{ NULL, 0xCCF16 /* #1059 'CLCircularRegion' => 'CoreLocation.CLCircularRegion, Xamarin.Mac' */ },
		{ NULL, 0xCD116 /* #1060 'CLHeading' => 'CoreLocation.CLHeading, Xamarin.Mac' */ },
		{ NULL, 0xCD216 /* #1061 'CLLocation' => 'CoreLocation.CLLocation, Xamarin.Mac' */ },
		{ NULL, 0xCDE16 /* #1062 'CLLocationManagerDelegate' => 'CoreLocation.CLLocationManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xD5316 /* #1063 'CIFilter' => 'CoreImage.CIFilter, Xamarin.Mac' */ },
		{ NULL, 0xCEA16 /* #1064 'CoreImage_CIAccordionFoldTransition' => 'CoreImage.CIAccordionFoldTransition, Xamarin.Mac' */ },
		{ NULL, 0xD2716 /* #1065 'CoreImage_CICompositingFilter' => 'CoreImage.CICompositingFilter, Xamarin.Mac' */ },
		{ NULL, 0xCEB16 /* #1066 'CoreImage_CIAdditionCompositing' => 'CoreImage.CIAdditionCompositing, Xamarin.Mac' */ },
		{ NULL, 0xCED16 /* #1067 'CoreImage_CIAffineFilter' => 'CoreImage.CIAffineFilter, Xamarin.Mac' */ },
		{ NULL, 0xCEC16 /* #1068 'CoreImage_CIAffineClamp' => 'CoreImage.CIAffineClamp, Xamarin.Mac' */ },
		{ NULL, 0xCEE16 /* #1069 'CoreImage_CIAffineTile' => 'CoreImage.CIAffineTile, Xamarin.Mac' */ },
		{ NULL, 0xCEF16 /* #1070 'CoreImage_CIAffineTransform' => 'CoreImage.CIAffineTransform, Xamarin.Mac' */ },
		{ NULL, 0xCF016 /* #1071 'CoreImage_CIAreaAverage' => 'CoreImage.CIAreaAverage, Xamarin.Mac' */ },
		{ NULL, 0xCF116 /* #1072 'CoreImage_CIAreaHistogram' => 'CoreImage.CIAreaHistogram, Xamarin.Mac' */ },
		{ NULL, 0xDC916 /* #1073 'CoreImage_CIReductionFilter' => 'CoreImage.CIReductionFilter, Xamarin.Mac' */ },
		{ NULL, 0xCF216 /* #1074 'CoreImage_CIAreaMaximum' => 'CoreImage.CIAreaMaximum, Xamarin.Mac' */ },
		{ NULL, 0xCF316 /* #1075 'CoreImage_CIAreaMaximumAlpha' => 'CoreImage.CIAreaMaximumAlpha, Xamarin.Mac' */ },
		{ NULL, 0xCF416 /* #1076 'CoreImage_CIAreaMinimum' => 'CoreImage.CIAreaMinimum, Xamarin.Mac' */ },
		{ NULL, 0xCF516 /* #1077 'CoreImage_CIAreaMinimumAlpha' => 'CoreImage.CIAreaMinimumAlpha, Xamarin.Mac' */ },
		{ NULL, 0xCF616 /* #1078 'CoreImage_CIAreaMinMax' => 'CoreImage.CIAreaMinMax, Xamarin.Mac' */ },
		{ NULL, 0xCF716 /* #1079 'CoreImage_CIAreaMinMaxRed' => 'CoreImage.CIAreaMinMaxRed, Xamarin.Mac' */ },
		{ NULL, 0xD7516 /* #1080 'CoreImage_CIImageGenerator' => 'CoreImage.CIImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCF816 /* #1081 'CoreImage_CIAttributedTextImageGenerator' => 'CoreImage.CIAttributedTextImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCFB16 /* #1082 'CIBarcodeDescriptor' => 'CoreImage.CIBarcodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xCF916 /* #1083 'CIAztecCodeDescriptor' => 'CoreImage.CIAztecCodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xD1216 /* #1084 'CoreImage_CICodeGenerator' => 'CoreImage.CICodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCFA16 /* #1085 'CoreImage_CIAztecCodeGenerator' => 'CoreImage.CIAztecCodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xCFC16 /* #1086 'CoreImage_CIBarcodeGenerator' => 'CoreImage.CIBarcodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDF116 /* #1087 'CoreImage_CITransitionFilter' => 'CoreImage.CITransitionFilter, Xamarin.Mac' */ },
		{ NULL, 0xCFD16 /* #1088 'CoreImage_CIBarsSwipeTransition' => 'CoreImage.CIBarsSwipeTransition, Xamarin.Mac' */ },
		{ NULL, 0xCFE16 /* #1089 'CoreImage_CIBicubicScaleTransform' => 'CoreImage.CIBicubicScaleTransform, Xamarin.Mac' */ },
		{ NULL, 0xCFF16 /* #1090 'CoreImage_CIBlendFilter' => 'CoreImage.CIBlendFilter, Xamarin.Mac' */ },
		{ NULL, 0xD8616 /* #1091 'CIKernel' => 'CoreImage.CIKernel, Xamarin.Mac' */ },
		{ NULL, 0xD1F16 /* #1092 'CIColorKernel' => 'CoreImage.CIColorKernel, Xamarin.Mac' */ },
		{ NULL, 0xD0016 /* #1093 'CIBlendKernel' => 'CoreImage.CIBlendKernel, Xamarin.Mac' */ },
		{ NULL, 0xD0316 /* #1094 'CoreImage_CIBlendWithMask' => 'CoreImage.CIBlendWithMask, Xamarin.Mac' */ },
		{ NULL, 0xD0116 /* #1095 'CoreImage_CIBlendWithAlphaMask' => 'CoreImage.CIBlendWithAlphaMask, Xamarin.Mac' */ },
		{ NULL, 0xD0216 /* #1096 'CoreImage_CIBlendWithBlueMask' => 'CoreImage.CIBlendWithBlueMask, Xamarin.Mac' */ },
		{ NULL, 0xD0416 /* #1097 'CoreImage_CIBlendWithRedMask' => 'CoreImage.CIBlendWithRedMask, Xamarin.Mac' */ },
		{ NULL, 0xD0516 /* #1098 'CoreImage_CIBloom' => 'CoreImage.CIBloom, Xamarin.Mac' */ },
		{ NULL, 0xD8C16 /* #1099 'CoreImage_CILinearBlur' => 'CoreImage.CILinearBlur, Xamarin.Mac' */ },
		{ NULL, 0xD0616 /* #1100 'CoreImage_CIBokehBlur' => 'CoreImage.CIBokehBlur, Xamarin.Mac' */ },
		{ NULL, 0xD0716 /* #1101 'CoreImage_CIBoxBlur' => 'CoreImage.CIBoxBlur, Xamarin.Mac' */ },
		{ NULL, 0xD4416 /* #1102 'CoreImage_CIDistortionFilter' => 'CoreImage.CIDistortionFilter, Xamarin.Mac' */ },
		{ NULL, 0xD0816 /* #1103 'CoreImage_CIBumpDistortion' => 'CoreImage.CIBumpDistortion, Xamarin.Mac' */ },
		{ NULL, 0xD0916 /* #1104 'CoreImage_CIBumpDistortionLinear' => 'CoreImage.CIBumpDistortionLinear, Xamarin.Mac' */ },
		{ NULL, 0xD0A16 /* #1105 'CoreImage_CICameraCalibrationLensCorrection' => 'CoreImage.CICameraCalibrationLensCorrection, Xamarin.Mac' */ },
		{ NULL, 0xD0B16 /* #1106 'CoreImage_CICheckerboardGenerator' => 'CoreImage.CICheckerboardGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD0C16 /* #1107 'CoreImage_CICircleSplashDistortion' => 'CoreImage.CICircleSplashDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDD416 /* #1108 'CoreImage_CIScreenFilter' => 'CoreImage.CIScreenFilter, Xamarin.Mac' */ },
		{ NULL, 0xD0D16 /* #1109 'CoreImage_CICircularScreen' => 'CoreImage.CICircularScreen, Xamarin.Mac' */ },
		{ NULL, 0xD0E16 /* #1110 'CoreImage_CICircularWrap' => 'CoreImage.CICircularWrap, Xamarin.Mac' */ },
		{ NULL, 0xD0F16 /* #1111 'CoreImage_CIClamp' => 'CoreImage.CIClamp, Xamarin.Mac' */ },
		{ NULL, 0xD1016 /* #1112 'CoreImage_CICmykHalftone' => 'CoreImage.CICmykHalftone, Xamarin.Mac' */ },
		{ NULL, 0xD1116 /* #1113 'CoreImage_CICode128BarcodeGenerator' => 'CoreImage.CICode128BarcodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD1316 /* #1114 'CIColor' => 'CoreImage.CIColor, Xamarin.Mac' */ },
		{ NULL, 0xD1416 /* #1115 'CoreImage_CIColorBlendMode' => 'CoreImage.CIColorBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD1516 /* #1116 'CoreImage_CIColorBurnBlendMode' => 'CoreImage.CIColorBurnBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD1616 /* #1117 'CoreImage_CIColorClamp' => 'CoreImage.CIColorClamp, Xamarin.Mac' */ },
		{ NULL, 0xD1716 /* #1118 'CoreImage_CIColorControls' => 'CoreImage.CIColorControls, Xamarin.Mac' */ },
		{ NULL, 0xD1816 /* #1119 'CoreImage_CIColorCrossPolynomial' => 'CoreImage.CIColorCrossPolynomial, Xamarin.Mac' */ },
		{ NULL, 0xD1916 /* #1120 'CoreImage_CIColorCube' => 'CoreImage.CIColorCube, Xamarin.Mac' */ },
		{ NULL, 0xD1A16 /* #1121 'CoreImage_CIColorCubesMixedWithMask' => 'CoreImage.CIColorCubesMixedWithMask, Xamarin.Mac' */ },
		{ NULL, 0xD1B16 /* #1122 'CoreImage_CIColorCubeWithColorSpace' => 'CoreImage.CIColorCubeWithColorSpace, Xamarin.Mac' */ },
		{ NULL, 0xD1C16 /* #1123 'CoreImage_CIColorCurves' => 'CoreImage.CIColorCurves, Xamarin.Mac' */ },
		{ NULL, 0xD1D16 /* #1124 'CoreImage_CIColorDodgeBlendMode' => 'CoreImage.CIColorDodgeBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD1E16 /* #1125 'CoreImage_CIColorInvert' => 'CoreImage.CIColorInvert, Xamarin.Mac' */ },
		{ NULL, 0xD2016 /* #1126 'CoreImage_CIColorMap' => 'CoreImage.CIColorMap, Xamarin.Mac' */ },
		{ NULL, 0xD2116 /* #1127 'CoreImage_CIColorMatrix' => 'CoreImage.CIColorMatrix, Xamarin.Mac' */ },
		{ NULL, 0xD2216 /* #1128 'CoreImage_CIColorMonochrome' => 'CoreImage.CIColorMonochrome, Xamarin.Mac' */ },
		{ NULL, 0xD2316 /* #1129 'CoreImage_CIColorPolynomial' => 'CoreImage.CIColorPolynomial, Xamarin.Mac' */ },
		{ NULL, 0xD2416 /* #1130 'CoreImage_CIColorPosterize' => 'CoreImage.CIColorPosterize, Xamarin.Mac' */ },
		{ NULL, 0xD2516 /* #1131 'CoreImage_CIColumnAverage' => 'CoreImage.CIColumnAverage, Xamarin.Mac' */ },
		{ NULL, 0xD2616 /* #1132 'CoreImage_CIComicEffect' => 'CoreImage.CIComicEffect, Xamarin.Mac' */ },
		{ NULL, 0xD2816 /* #1133 'CoreImage_CIConstantColorGenerator' => 'CoreImage.CIConstantColorGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD2916 /* #1134 'CIContext' => 'CoreImage.CIContext, Xamarin.Mac' */ },
		{ NULL, 0xD3216 /* #1135 'CoreImage_CIConvolutionCore' => 'CoreImage.CIConvolutionCore, Xamarin.Mac' */ },
		{ NULL, 0xD2D16 /* #1136 'CoreImage_CIConvolution3X3' => 'CoreImage.CIConvolution3X3, Xamarin.Mac' */ },
		{ NULL, 0xD2E16 /* #1137 'CoreImage_CIConvolution5X5' => 'CoreImage.CIConvolution5X5, Xamarin.Mac' */ },
		{ NULL, 0xD2F16 /* #1138 'CoreImage_CIConvolution7X7' => 'CoreImage.CIConvolution7X7, Xamarin.Mac' */ },
		{ NULL, 0xD3016 /* #1139 'CoreImage_CIConvolution9Horizontal' => 'CoreImage.CIConvolution9Horizontal, Xamarin.Mac' */ },
		{ NULL, 0xD3116 /* #1140 'CoreImage_CIConvolution9Vertical' => 'CoreImage.CIConvolution9Vertical, Xamarin.Mac' */ },
		{ NULL, 0xD3316 /* #1141 'CoreImage_CICopyMachineTransition' => 'CoreImage.CICopyMachineTransition, Xamarin.Mac' */ },
		{ NULL, 0xD3416 /* #1142 'CoreImage_CICoreMLModelFilter' => 'CoreImage.CICoreMLModelFilter, Xamarin.Mac' */ },
		{ NULL, 0xD3516 /* #1143 'CoreImage_CICrop' => 'CoreImage.CICrop, Xamarin.Mac' */ },
		{ NULL, 0xD3616 /* #1144 'CoreImage_CICrystallize' => 'CoreImage.CICrystallize, Xamarin.Mac' */ },
		{ NULL, 0xD3716 /* #1145 'CoreImage_CIDarkenBlendMode' => 'CoreImage.CIDarkenBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD3816 /* #1146 'CIDataMatrixCodeDescriptor' => 'CoreImage.CIDataMatrixCodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xD3916 /* #1147 'CoreImage_CIDepthBlurEffect' => 'CoreImage.CIDepthBlurEffect, Xamarin.Mac' */ },
		{ NULL, 0xD3A16 /* #1148 'CoreImage_CIDepthDisparityConverter' => 'CoreImage.CIDepthDisparityConverter, Xamarin.Mac' */ },
		{ NULL, 0xD3B16 /* #1149 'CoreImage_CIDepthOfField' => 'CoreImage.CIDepthOfField, Xamarin.Mac' */ },
		{ NULL, 0xD3C16 /* #1150 'CoreImage_CIDepthToDisparity' => 'CoreImage.CIDepthToDisparity, Xamarin.Mac' */ },
		{ NULL, 0xD3D16 /* #1151 'CIDetector' => 'CoreImage.CIDetector, Xamarin.Mac' */ },
		{ NULL, 0xD3E16 /* #1152 'CoreImage_CIDifferenceBlendMode' => 'CoreImage.CIDifferenceBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD3F16 /* #1153 'CoreImage_CIDiscBlur' => 'CoreImage.CIDiscBlur, Xamarin.Mac' */ },
		{ NULL, 0xD4016 /* #1154 'CoreImage_CIDisintegrateWithMaskTransition' => 'CoreImage.CIDisintegrateWithMaskTransition, Xamarin.Mac' */ },
		{ NULL, 0xD4116 /* #1155 'CoreImage_CIDisparityToDepth' => 'CoreImage.CIDisparityToDepth, Xamarin.Mac' */ },
		{ NULL, 0xD4216 /* #1156 'CoreImage_CIDisplacementDistortion' => 'CoreImage.CIDisplacementDistortion, Xamarin.Mac' */ },
		{ NULL, 0xD4316 /* #1157 'CoreImage_CIDissolveTransition' => 'CoreImage.CIDissolveTransition, Xamarin.Mac' */ },
		{ NULL, 0xD4516 /* #1158 'CoreImage_CIDither' => 'CoreImage.CIDither, Xamarin.Mac' */ },
		{ NULL, 0xD4616 /* #1159 'CoreImage_CIDivideBlendMode' => 'CoreImage.CIDivideBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD4716 /* #1160 'CoreImage_CIDotScreen' => 'CoreImage.CIDotScreen, Xamarin.Mac' */ },
		{ NULL, 0xD4816 /* #1161 'CoreImage_CIDroste' => 'CoreImage.CIDroste, Xamarin.Mac' */ },
		{ NULL, 0xD4916 /* #1162 'CoreImage_CIEdgePreserveUpsampleFilter' => 'CoreImage.CIEdgePreserveUpsampleFilter, Xamarin.Mac' */ },
		{ NULL, 0xD4A16 /* #1163 'CoreImage_CIEdges' => 'CoreImage.CIEdges, Xamarin.Mac' */ },
		{ NULL, 0xD4B16 /* #1164 'CoreImage_CIEdgeWork' => 'CoreImage.CIEdgeWork, Xamarin.Mac' */ },
		{ NULL, 0xDEE16 /* #1165 'CoreImage_CITileFilter' => 'CoreImage.CITileFilter, Xamarin.Mac' */ },
		{ NULL, 0xD4C16 /* #1166 'CoreImage_CIEightfoldReflectedTile' => 'CoreImage.CIEightfoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xD4D16 /* #1167 'CoreImage_CIExclusionBlendMode' => 'CoreImage.CIExclusionBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD4E16 /* #1168 'CoreImage_CIExposureAdjust' => 'CoreImage.CIExposureAdjust, Xamarin.Mac' */ },
		{ NULL, 0xD4F16 /* #1169 'CoreImage_CIFaceBalance' => 'CoreImage.CIFaceBalance, Xamarin.Mac' */ },
		{ NULL, 0xD5216 /* #1170 'CIFeature' => 'CoreImage.CIFeature, Xamarin.Mac' */ },
		{ NULL, 0xD5016 /* #1171 'CIFaceFeature' => 'CoreImage.CIFaceFeature, Xamarin.Mac' */ },
		{ NULL, 0xD5116 /* #1172 'CoreImage_CIFalseColor' => 'CoreImage.CIFalseColor, Xamarin.Mac' */ },
		{ NULL, 0xD5916 /* #1173 'CIFilterGenerator' => 'CoreImage.CIFilterGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD5C16 /* #1174 'CIFilterShape' => 'CoreImage.CIFilterShape, Xamarin.Mac' */ },
		{ NULL, 0xD5D16 /* #1175 'CoreImage_CIFlashTransition' => 'CoreImage.CIFlashTransition, Xamarin.Mac' */ },
		{ NULL, 0xD5E16 /* #1176 'CoreImage_CIFourfoldReflectedTile' => 'CoreImage.CIFourfoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xD5F16 /* #1177 'CoreImage_CIFourfoldRotatedTile' => 'CoreImage.CIFourfoldRotatedTile, Xamarin.Mac' */ },
		{ NULL, 0xD6016 /* #1178 'CoreImage_CIFourfoldTranslatedTile' => 'CoreImage.CIFourfoldTranslatedTile, Xamarin.Mac' */ },
		{ NULL, 0xD6116 /* #1179 'CoreImage_CIGammaAdjust' => 'CoreImage.CIGammaAdjust, Xamarin.Mac' */ },
		{ NULL, 0xD6216 /* #1180 'CoreImage_CIGaussianBlur' => 'CoreImage.CIGaussianBlur, Xamarin.Mac' */ },
		{ NULL, 0xD6316 /* #1181 'CoreImage_CIGaussianGradient' => 'CoreImage.CIGaussianGradient, Xamarin.Mac' */ },
		{ NULL, 0xD6416 /* #1182 'CoreImage_CIGlassDistortion' => 'CoreImage.CIGlassDistortion, Xamarin.Mac' */ },
		{ NULL, 0xD6516 /* #1183 'CoreImage_CIGlassLozenge' => 'CoreImage.CIGlassLozenge, Xamarin.Mac' */ },
		{ NULL, 0xD6616 /* #1184 'CoreImage_CIGlideReflectedTile' => 'CoreImage.CIGlideReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xD6716 /* #1185 'CoreImage_CIGloom' => 'CoreImage.CIGloom, Xamarin.Mac' */ },
		{ NULL, 0xD6816 /* #1186 'CoreImage_CIGuidedFilter' => 'CoreImage.CIGuidedFilter, Xamarin.Mac' */ },
		{ NULL, 0xD6916 /* #1187 'CoreImage_CIHardLightBlendMode' => 'CoreImage.CIHardLightBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD6A16 /* #1188 'CoreImage_CIHatchedScreen' => 'CoreImage.CIHatchedScreen, Xamarin.Mac' */ },
		{ NULL, 0xD6B16 /* #1189 'CoreImage_CIHeightFieldFromMask' => 'CoreImage.CIHeightFieldFromMask, Xamarin.Mac' */ },
		{ NULL, 0xD6C16 /* #1190 'CoreImage_CIHexagonalPixellate' => 'CoreImage.CIHexagonalPixellate, Xamarin.Mac' */ },
		{ NULL, 0xD6D16 /* #1191 'CoreImage_CIHighlightShadowAdjust' => 'CoreImage.CIHighlightShadowAdjust, Xamarin.Mac' */ },
		{ NULL, 0xD6E16 /* #1192 'CoreImage_CIHistogramDisplayFilter' => 'CoreImage.CIHistogramDisplayFilter, Xamarin.Mac' */ },
		{ NULL, 0xD6F16 /* #1193 'CoreImage_CIHoleDistortion' => 'CoreImage.CIHoleDistortion, Xamarin.Mac' */ },
		{ NULL, 0xD7016 /* #1194 'CoreImage_CIHueAdjust' => 'CoreImage.CIHueAdjust, Xamarin.Mac' */ },
		{ NULL, 0xD7116 /* #1195 'CoreImage_CIHueBlendMode' => 'CoreImage.CIHueBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD7216 /* #1196 'CoreImage_CIHueSaturationValueGradient' => 'CoreImage.CIHueSaturationValueGradient, Xamarin.Mac' */ },
		{ NULL, 0xD7316 /* #1197 'CIImage' => 'CoreImage.CIImage, Xamarin.Mac' */ },
		{ NULL, 0xD7416 /* #1198 'CIImageAccumulator' => 'CoreImage.CIImageAccumulator, Xamarin.Mac' */ },
		{ NULL, 0xD7B16 /* #1199 'CIImageProcessorKernel' => 'CoreImage.CIImageProcessorKernel, Xamarin.Mac' */ },
		{ NULL, 0xD8516 /* #1200 'CoreImage_CIKaleidoscope' => 'CoreImage.CIKaleidoscope, Xamarin.Mac' */ },
		{ NULL, 0xD8716 /* #1201 'CoreImage_CILabDeltaE' => 'CoreImage.CILabDeltaE, Xamarin.Mac' */ },
		{ NULL, 0xD8816 /* #1202 'CoreImage_CILanczosScaleTransform' => 'CoreImage.CILanczosScaleTransform, Xamarin.Mac' */ },
		{ NULL, 0xD8916 /* #1203 'CoreImage_CILenticularHaloGenerator' => 'CoreImage.CILenticularHaloGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD8A16 /* #1204 'CoreImage_CILightenBlendMode' => 'CoreImage.CILightenBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD8B16 /* #1205 'CoreImage_CILightTunnel' => 'CoreImage.CILightTunnel, Xamarin.Mac' */ },
		{ NULL, 0xD8D16 /* #1206 'CoreImage_CILinearBurnBlendMode' => 'CoreImage.CILinearBurnBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD8E16 /* #1207 'CoreImage_CILinearDodgeBlendMode' => 'CoreImage.CILinearDodgeBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD8F16 /* #1208 'CoreImage_CILinearGradient' => 'CoreImage.CILinearGradient, Xamarin.Mac' */ },
		{ NULL, 0xD9016 /* #1209 'CoreImage_CILinearToSRGBToneCurve' => 'CoreImage.CILinearToSRGBToneCurve, Xamarin.Mac' */ },
		{ NULL, 0xD9116 /* #1210 'CoreImage_CILineOverlay' => 'CoreImage.CILineOverlay, Xamarin.Mac' */ },
		{ NULL, 0xD9216 /* #1211 'CoreImage_CILineScreen' => 'CoreImage.CILineScreen, Xamarin.Mac' */ },
		{ NULL, 0xD9316 /* #1212 'CoreImage_CILuminosityBlendMode' => 'CoreImage.CILuminosityBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xD9416 /* #1213 'CoreImage_CIMaskedVariableBlur' => 'CoreImage.CIMaskedVariableBlur, Xamarin.Mac' */ },
		{ NULL, 0xD9516 /* #1214 'CoreImage_CIMaskToAlpha' => 'CoreImage.CIMaskToAlpha, Xamarin.Mac' */ },
		{ NULL, 0xD9616 /* #1215 'CoreImage_CIMaximumComponent' => 'CoreImage.CIMaximumComponent, Xamarin.Mac' */ },
		{ NULL, 0xD9716 /* #1216 'CoreImage_CIMaximumCompositing' => 'CoreImage.CIMaximumCompositing, Xamarin.Mac' */ },
		{ NULL, 0xD9816 /* #1217 'CoreImage_CIMedianFilter' => 'CoreImage.CIMedianFilter, Xamarin.Mac' */ },
		{ NULL, 0xD9916 /* #1218 'CoreImage_CIMeshGenerator' => 'CoreImage.CIMeshGenerator, Xamarin.Mac' */ },
		{ NULL, 0xD9A16 /* #1219 'CoreImage_CIMinimumComponent' => 'CoreImage.CIMinimumComponent, Xamarin.Mac' */ },
		{ NULL, 0xD9B16 /* #1220 'CoreImage_CIMinimumCompositing' => 'CoreImage.CIMinimumCompositing, Xamarin.Mac' */ },
		{ NULL, 0xD9C16 /* #1221 'CoreImage_CIMix' => 'CoreImage.CIMix, Xamarin.Mac' */ },
		{ NULL, 0xD9D16 /* #1222 'CoreImage_CIModTransition' => 'CoreImage.CIModTransition, Xamarin.Mac' */ },
		{ NULL, 0xD9E16 /* #1223 'CoreImage_CIMorphology' => 'CoreImage.CIMorphology, Xamarin.Mac' */ },
		{ NULL, 0xD9F16 /* #1224 'CoreImage_CIMorphologyGradient' => 'CoreImage.CIMorphologyGradient, Xamarin.Mac' */ },
		{ NULL, 0xDA016 /* #1225 'CoreImage_CIMorphologyMaximum' => 'CoreImage.CIMorphologyMaximum, Xamarin.Mac' */ },
		{ NULL, 0xDA116 /* #1226 'CoreImage_CIMorphologyMinimum' => 'CoreImage.CIMorphologyMinimum, Xamarin.Mac' */ },
		{ NULL, 0xDA216 /* #1227 'CoreImage_CIMotionBlur' => 'CoreImage.CIMotionBlur, Xamarin.Mac' */ },
		{ NULL, 0xDA316 /* #1228 'CoreImage_CIMultiplyBlendMode' => 'CoreImage.CIMultiplyBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDA416 /* #1229 'CoreImage_CIMultiplyCompositing' => 'CoreImage.CIMultiplyCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDA516 /* #1230 'CoreImage_CINinePartStretched' => 'CoreImage.CINinePartStretched, Xamarin.Mac' */ },
		{ NULL, 0xDA616 /* #1231 'CoreImage_CINinePartTiled' => 'CoreImage.CINinePartTiled, Xamarin.Mac' */ },
		{ NULL, 0xDA716 /* #1232 'CoreImage_CINoiseReduction' => 'CoreImage.CINoiseReduction, Xamarin.Mac' */ },
		{ NULL, 0xDA816 /* #1233 'CoreImage_CIOpTile' => 'CoreImage.CIOpTile, Xamarin.Mac' */ },
		{ NULL, 0xDA916 /* #1234 'CoreImage_CIOverlayBlendMode' => 'CoreImage.CIOverlayBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDAA16 /* #1235 'CoreImage_CIPageCurlTransition' => 'CoreImage.CIPageCurlTransition, Xamarin.Mac' */ },
		{ NULL, 0xDAB16 /* #1236 'CoreImage_CIPageCurlWithShadowTransition' => 'CoreImage.CIPageCurlWithShadowTransition, Xamarin.Mac' */ },
		{ NULL, 0xDAC16 /* #1237 'CoreImage_CIParallelogramTile' => 'CoreImage.CIParallelogramTile, Xamarin.Mac' */ },
		{ NULL, 0xDAD16 /* #1238 'CoreImage_CIPdf417BarcodeGenerator' => 'CoreImage.CIPdf417BarcodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDAE16 /* #1239 'CIPDF417CodeDescriptor' => 'CoreImage.CIPdf417CodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xDB116 /* #1240 'CoreImage_CIPerspectiveTransform' => 'CoreImage.CIPerspectiveTransform, Xamarin.Mac' */ },
		{ NULL, 0xDAF16 /* #1241 'CoreImage_CIPerspectiveCorrection' => 'CoreImage.CIPerspectiveCorrection, Xamarin.Mac' */ },
		{ NULL, 0xDB016 /* #1242 'CoreImage_CIPerspectiveTile' => 'CoreImage.CIPerspectiveTile, Xamarin.Mac' */ },
		{ NULL, 0xDB216 /* #1243 'CoreImage_CIPerspectiveTransformWithExtent' => 'CoreImage.CIPerspectiveTransformWithExtent, Xamarin.Mac' */ },
		{ NULL, 0xDB316 /* #1244 'CoreImage_CIPhotoEffect' => 'CoreImage.CIPhotoEffect, Xamarin.Mac' */ },
		{ NULL, 0xDB416 /* #1245 'CoreImage_CIPhotoEffectChrome' => 'CoreImage.CIPhotoEffectChrome, Xamarin.Mac' */ },
		{ NULL, 0xDB516 /* #1246 'CoreImage_CIPhotoEffectFade' => 'CoreImage.CIPhotoEffectFade, Xamarin.Mac' */ },
		{ NULL, 0xDB616 /* #1247 'CoreImage_CIPhotoEffectInstant' => 'CoreImage.CIPhotoEffectInstant, Xamarin.Mac' */ },
		{ NULL, 0xDB716 /* #1248 'CoreImage_CIPhotoEffectMono' => 'CoreImage.CIPhotoEffectMono, Xamarin.Mac' */ },
		{ NULL, 0xDB816 /* #1249 'CoreImage_CIPhotoEffectNoir' => 'CoreImage.CIPhotoEffectNoir, Xamarin.Mac' */ },
		{ NULL, 0xDB916 /* #1250 'CoreImage_CIPhotoEffectProcess' => 'CoreImage.CIPhotoEffectProcess, Xamarin.Mac' */ },
		{ NULL, 0xDBA16 /* #1251 'CoreImage_CIPhotoEffectTonal' => 'CoreImage.CIPhotoEffectTonal, Xamarin.Mac' */ },
		{ NULL, 0xDBB16 /* #1252 'CoreImage_CIPhotoEffectTransfer' => 'CoreImage.CIPhotoEffectTransfer, Xamarin.Mac' */ },
		{ NULL, 0xDBC16 /* #1253 'CoreImage_CIPinchDistortion' => 'CoreImage.CIPinchDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDBD16 /* #1254 'CoreImage_CIPinLightBlendMode' => 'CoreImage.CIPinLightBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDBE16 /* #1255 'CoreImage_CIPixellate' => 'CoreImage.CIPixellate, Xamarin.Mac' */ },
		{ NULL, 0xDBF16 /* #1256 'CIPlugIn' => 'CoreImage.CIPlugIn, Xamarin.Mac' */ },
		{ NULL, 0xDC016 /* #1257 'CoreImage_CIPointillize' => 'CoreImage.CIPointillize, Xamarin.Mac' */ },
		{ NULL, 0xDC116 /* #1258 'CIQRCodeDescriptor' => 'CoreImage.CIQRCodeDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xDC216 /* #1259 'CIQRCodeFeature' => 'CoreImage.CIQRCodeFeature, Xamarin.Mac' */ },
		{ NULL, 0xDC316 /* #1260 'CoreImage_CIQRCodeGenerator' => 'CoreImage.CIQRCodeGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDC416 /* #1261 'CoreImage_CIRadialGradient' => 'CoreImage.CIRadialGradient, Xamarin.Mac' */ },
		{ NULL, 0xDC516 /* #1262 'CoreImage_CIRandomGenerator' => 'CoreImage.CIRandomGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDC816 /* #1263 'CIRectangleFeature' => 'CoreImage.CIRectangleFeature, Xamarin.Mac' */ },
		{ NULL, 0xDCA16 /* #1264 'CIRenderDestination' => 'CoreImage.CIRenderDestination, Xamarin.Mac' */ },
		{ NULL, 0xDCB16 /* #1265 'CIRenderInfo' => 'CoreImage.CIRenderInfo, Xamarin.Mac' */ },
		{ NULL, 0xDCC16 /* #1266 'CIRenderTask' => 'CoreImage.CIRenderTask, Xamarin.Mac' */ },
		{ NULL, 0xDCD16 /* #1267 'CoreImage_CIRippleTransition' => 'CoreImage.CIRippleTransition, Xamarin.Mac' */ },
		{ NULL, 0xDCE16 /* #1268 'CoreImage_CIRowAverage' => 'CoreImage.CIRowAverage, Xamarin.Mac' */ },
		{ NULL, 0xDCF16 /* #1269 'CoreImage_CISaliencyMapFilter' => 'CoreImage.CISaliencyMapFilter, Xamarin.Mac' */ },
		{ NULL, 0xDD016 /* #1270 'CoreImage_CISampleNearest' => 'CoreImage.CISampleNearest, Xamarin.Mac' */ },
		{ NULL, 0xDD116 /* #1271 'CISampler' => 'CoreImage.CISampler, Xamarin.Mac' */ },
		{ NULL, 0xDD216 /* #1272 'CoreImage_CISaturationBlendMode' => 'CoreImage.CISaturationBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDD316 /* #1273 'CoreImage_CIScreenBlendMode' => 'CoreImage.CIScreenBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDD516 /* #1274 'CoreImage_CISepiaTone' => 'CoreImage.CISepiaTone, Xamarin.Mac' */ },
		{ NULL, 0xDD616 /* #1275 'CoreImage_CIShadedMaterial' => 'CoreImage.CIShadedMaterial, Xamarin.Mac' */ },
		{ NULL, 0xDD716 /* #1276 'CoreImage_CISharpenLuminance' => 'CoreImage.CISharpenLuminance, Xamarin.Mac' */ },
		{ NULL, 0xDD816 /* #1277 'CoreImage_CISixfoldReflectedTile' => 'CoreImage.CISixfoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xDD916 /* #1278 'CoreImage_CISixfoldRotatedTile' => 'CoreImage.CISixfoldRotatedTile, Xamarin.Mac' */ },
		{ NULL, 0xDDA16 /* #1279 'CoreImage_CISmoothLinearGradient' => 'CoreImage.CISmoothLinearGradient, Xamarin.Mac' */ },
		{ NULL, 0xDDB16 /* #1280 'CoreImage_CISoftLightBlendMode' => 'CoreImage.CISoftLightBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDDC16 /* #1281 'CoreImage_CISourceAtopCompositing' => 'CoreImage.CISourceAtopCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDDD16 /* #1282 'CoreImage_CISourceInCompositing' => 'CoreImage.CISourceInCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDDE16 /* #1283 'CoreImage_CISourceOutCompositing' => 'CoreImage.CISourceOutCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDDF16 /* #1284 'CoreImage_CISourceOverCompositing' => 'CoreImage.CISourceOverCompositing, Xamarin.Mac' */ },
		{ NULL, 0xDE016 /* #1285 'CoreImage_CISpotColor' => 'CoreImage.CISpotColor, Xamarin.Mac' */ },
		{ NULL, 0xDE116 /* #1286 'CoreImage_CISpotLight' => 'CoreImage.CISpotLight, Xamarin.Mac' */ },
		{ NULL, 0xDE216 /* #1287 'CoreImage_CISRGBToneCurveToLinear' => 'CoreImage.CISRGBToneCurveToLinear, Xamarin.Mac' */ },
		{ NULL, 0xDE316 /* #1288 'CoreImage_CIStarShineGenerator' => 'CoreImage.CIStarShineGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDE416 /* #1289 'CoreImage_CIStraightenFilter' => 'CoreImage.CIStraightenFilter, Xamarin.Mac' */ },
		{ NULL, 0xDE516 /* #1290 'CoreImage_CIStretchCrop' => 'CoreImage.CIStretchCrop, Xamarin.Mac' */ },
		{ NULL, 0xDE616 /* #1291 'CoreImage_CIStripesGenerator' => 'CoreImage.CIStripesGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDE716 /* #1292 'CoreImage_CISubtractBlendMode' => 'CoreImage.CISubtractBlendMode, Xamarin.Mac' */ },
		{ NULL, 0xDE816 /* #1293 'CoreImage_CISunbeamsGenerator' => 'CoreImage.CISunbeamsGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDE916 /* #1294 'CoreImage_CISwipeTransition' => 'CoreImage.CISwipeTransition, Xamarin.Mac' */ },
		{ NULL, 0xDEA16 /* #1295 'CoreImage_CITemperatureAndTint' => 'CoreImage.CITemperatureAndTint, Xamarin.Mac' */ },
		{ NULL, 0xDEB16 /* #1296 'CITextFeature' => 'CoreImage.CITextFeature, Xamarin.Mac' */ },
		{ NULL, 0xDEC16 /* #1297 'CoreImage_CITextImageGenerator' => 'CoreImage.CITextImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0xDED16 /* #1298 'CoreImage_CIThermal' => 'CoreImage.CIThermal, Xamarin.Mac' */ },
		{ NULL, 0xDEF16 /* #1299 'CoreImage_CIToneCurve' => 'CoreImage.CIToneCurve, Xamarin.Mac' */ },
		{ NULL, 0xDF016 /* #1300 'CoreImage_CITorusLensDistortion' => 'CoreImage.CITorusLensDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDF216 /* #1301 'CoreImage_CITriangleKaleidoscope' => 'CoreImage.CITriangleKaleidoscope, Xamarin.Mac' */ },
		{ NULL, 0xDF316 /* #1302 'CoreImage_CITriangleTile' => 'CoreImage.CITriangleTile, Xamarin.Mac' */ },
		{ NULL, 0xDF416 /* #1303 'CoreImage_CITwelvefoldReflectedTile' => 'CoreImage.CITwelvefoldReflectedTile, Xamarin.Mac' */ },
		{ NULL, 0xDF516 /* #1304 'CoreImage_CITwirlDistortion' => 'CoreImage.CITwirlDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDF716 /* #1305 'CoreImage_CIUnsharpMask' => 'CoreImage.CIUnsharpMask, Xamarin.Mac' */ },
		{ NULL, 0xDF816 /* #1306 'CIVector' => 'CoreImage.CIVector, Xamarin.Mac' */ },
		{ NULL, 0xDF916 /* #1307 'CoreImage_CIVibrance' => 'CoreImage.CIVibrance, Xamarin.Mac' */ },
		{ NULL, 0xDFA16 /* #1308 'CoreImage_CIVignette' => 'CoreImage.CIVignette, Xamarin.Mac' */ },
		{ NULL, 0xDFB16 /* #1309 'CoreImage_CIVignetteEffect' => 'CoreImage.CIVignetteEffect, Xamarin.Mac' */ },
		{ NULL, 0xDFC16 /* #1310 'CoreImage_CIVortexDistortion' => 'CoreImage.CIVortexDistortion, Xamarin.Mac' */ },
		{ NULL, 0xDFD16 /* #1311 'CIWarpKernel' => 'CoreImage.CIWarpKernel, Xamarin.Mac' */ },
		{ NULL, 0xDFE16 /* #1312 'CoreImage_CIWhitePointAdjust' => 'CoreImage.CIWhitePointAdjust, Xamarin.Mac' */ },
		{ NULL, 0xDFF16 /* #1313 'CoreImage_CIXRay' => 'CoreImage.CIXRay, Xamarin.Mac' */ },
		{ NULL, 0xE0016 /* #1314 'CoreImage_CIZoomBlur' => 'CoreImage.CIZoomBlur, Xamarin.Mac' */ },
		{ NULL, 0xE0516 /* #1315 'CoreImage_CICMYKHalftone' => 'CoreImage.CICMYKHalftone, Xamarin.Mac' */ },
		{ NULL, 0xEE916 /* #1316 'NSPersistentStoreRequest' => 'CoreData.NSPersistentStoreRequest, Xamarin.Mac' */ },
		{ NULL, 0xEB316 /* #1317 'NSAsynchronousFetchRequest' => 'CoreData.NSAsynchronousFetchRequest, Xamarin.Mac' */ },
		{ NULL, 0xEEB16 /* #1318 'NSPersistentStoreResult' => 'CoreData.NSPersistentStoreResult, Xamarin.Mac' */ },
		{ NULL, 0xEE616 /* #1319 'NSPersistentStoreAsynchronousResult' => 'CoreData.NSPersistentStoreAsynchronousResult, Xamarin.Mac' */ },
		{ NULL, 0xEB416 /* #1320 'NSAsynchronousFetchResult' => 'CoreData.NSAsynchronousFetchResult, Xamarin.Mac' */ },
		{ NULL, 0xEE516 /* #1321 'NSPersistentStore' => 'CoreData.NSPersistentStore, Xamarin.Mac' */ },
		{ NULL, 0xEB516 /* #1322 'NSAtomicStore' => 'CoreData.NSAtomicStore, Xamarin.Mac' */ },
		{ NULL, 0xEB616 /* #1323 'NSAtomicStoreCacheNode' => 'CoreData.NSAtomicStoreCacheNode, Xamarin.Mac' */ },
		{ NULL, 0xEED16 /* #1324 'NSPropertyDescription' => 'CoreData.NSPropertyDescription, Xamarin.Mac' */ },
		{ NULL, 0xEB716 /* #1325 'NSAttributeDescription' => 'CoreData.NSAttributeDescription, Xamarin.Mac' */ },
		{ NULL, 0xEB916 /* #1326 'NSBatchDeleteRequest' => 'CoreData.NSBatchDeleteRequest, Xamarin.Mac' */ },
		{ NULL, 0xEBB16 /* #1327 'NSBatchDeleteResult' => 'CoreData.NSBatchDeleteResult, Xamarin.Mac' */ },
		{ NULL, 0xEBC16 /* #1328 'NSBatchUpdateRequest' => 'CoreData.NSBatchUpdateRequest, Xamarin.Mac' */ },
		{ NULL, 0xEBE16 /* #1329 'NSBatchUpdateResult' => 'CoreData.NSBatchUpdateResult, Xamarin.Mac' */ },
		{ NULL, 0xEBF16 /* #1330 'NSConstraintConflict' => 'CoreData.NSConstraintConflict, Xamarin.Mac' */ },
		{ NULL, 0xEC016 /* #1331 'NSCoreDataCoreSpotlightDelegate' => 'CoreData.NSCoreDataCoreSpotlightDelegate, Xamarin.Mac' */ },
		{ NULL, 0xEC216 /* #1332 'NSEntityDescription' => 'CoreData.NSEntityDescription, Xamarin.Mac' */ },
		{ NULL, 0xEC316 /* #1333 'NSEntityMapping' => 'CoreData.NSEntityMapping, Xamarin.Mac' */ },
		{ NULL, 0xEC516 /* #1334 'NSEntityMigrationPolicy' => 'CoreData.NSEntityMigrationPolicy, Xamarin.Mac' */ },
		{ NULL, 0xEC616 /* #1335 'NSExpressionDescription' => 'CoreData.NSExpressionDescription, Xamarin.Mac' */ },
		{ NULL, 0xEC716 /* #1336 'NSFetchedPropertyDescription' => 'CoreData.NSFetchedPropertyDescription, Xamarin.Mac' */ },
		{ NULL, 0xEC916 /* #1337 'NSFetchIndexDescription' => 'CoreData.NSFetchIndexDescription, Xamarin.Mac' */ },
		{ NULL, 0xECA16 /* #1338 'NSFetchIndexElementDescription' => 'CoreData.NSFetchIndexElementDescription, Xamarin.Mac' */ },
		{ NULL, 0xECC16 /* #1339 'NSFetchRequest' => 'CoreData.NSFetchRequest, Xamarin.Mac' */ },
		{ NULL, 0x171B16 /* #1340 'NSExpression' => 'Foundation.NSExpression, Xamarin.Mac' */ },
		{ NULL, 0xECD16 /* #1341 'NSFetchRequestExpression' => 'CoreData.NSFetchRequestExpression, Xamarin.Mac' */ },
		{ NULL, 0xED116 /* #1342 'NSIncrementalStore' => 'CoreData.NSIncrementalStore, Xamarin.Mac' */ },
		{ NULL, 0xED216 /* #1343 'NSIncrementalStoreNode' => 'CoreData.NSIncrementalStoreNode, Xamarin.Mac' */ },
		{ NULL, 0xED316 /* #1344 'NSManagedObject' => 'CoreData.NSManagedObject, Xamarin.Mac' */ },
		{ NULL, 0xED616 /* #1345 'NSManagedObjectID' => 'CoreData.NSManagedObjectID, Xamarin.Mac' */ },
		{ NULL, 0xED716 /* #1346 'NSManagedObjectModel' => 'CoreData.NSManagedObjectModel, Xamarin.Mac' */ },
		{ NULL, 0xED816 /* #1347 'NSMappingModel' => 'CoreData.NSMappingModel, Xamarin.Mac' */ },
		{ NULL, 0xED916 /* #1348 'NSMergeConflict' => 'CoreData.NSMergeConflict, Xamarin.Mac' */ },
		{ NULL, 0xEDA16 /* #1349 'NSMergePolicy' => 'CoreData.NSMergePolicy, Xamarin.Mac' */ },
		{ NULL, 0xEDC16 /* #1350 'NSMigrationManager' => 'CoreData.NSMigrationManager, Xamarin.Mac' */ },
		{ NULL, 0xEDE16 /* #1351 'NSPersistentHistoryChange' => 'CoreData.NSPersistentHistoryChange, Xamarin.Mac' */ },
		{ NULL, 0xEDF16 /* #1352 'NSPersistentHistoryChangeRequest' => 'CoreData.NSPersistentHistoryChangeRequest, Xamarin.Mac' */ },
		{ NULL, 0xEE116 /* #1353 'NSPersistentHistoryResult' => 'CoreData.NSPersistentHistoryResult, Xamarin.Mac' */ },
		{ NULL, 0xEE316 /* #1354 'NSPersistentHistoryToken' => 'CoreData.NSPersistentHistoryToken, Xamarin.Mac' */ },
		{ NULL, 0xEE416 /* #1355 'NSPersistentHistoryTransaction' => 'CoreData.NSPersistentHistoryTransaction, Xamarin.Mac' */ },
		{ NULL, 0xEE816 /* #1356 'NSPersistentStoreDescription' => 'CoreData.NSPersistentStoreDescription, Xamarin.Mac' */ },
		{ NULL, 0xEEE16 /* #1357 'NSPropertyMapping' => 'CoreData.NSPropertyMapping, Xamarin.Mac' */ },
		{ NULL, 0xEEF16 /* #1358 'NSQueryGenerationToken' => 'CoreData.NSQueryGenerationToken, Xamarin.Mac' */ },
		{ NULL, 0xEF016 /* #1359 'NSRelationshipDescription' => 'CoreData.NSRelationshipDescription, Xamarin.Mac' */ },
		{ NULL, 0xEF116 /* #1360 'NSSaveChangesRequest' => 'CoreData.NSSaveChangesRequest, Xamarin.Mac' */ },
		{ NULL, 0xEFF16 /* #1361 'CBATTRequest' => 'CoreBluetooth.CBATTRequest, Xamarin.Mac' */ },
		{ NULL, 0xF0016 /* #1362 'CBAttribute' => 'CoreBluetooth.CBAttribute, Xamarin.Mac' */ },
		{ NULL, 0xF1B16 /* #1363 'CBPeer' => 'CoreBluetooth.CBPeer, Xamarin.Mac' */ },
		{ NULL, 0xF0216 /* #1364 'CBCentral' => 'CoreBluetooth.CBCentral, Xamarin.Mac' */ },
		{ NULL, 0xF0D16 /* #1365 'CBCentralManagerDelegate' => 'CoreBluetooth.CBCentralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF0F16 /* #1366 'CBCharacteristic' => 'CoreBluetooth.CBCharacteristic, Xamarin.Mac' */ },
		{ NULL, 0xF1216 /* #1367 'CBDescriptor' => 'CoreBluetooth.CBDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xF1516 /* #1368 'CBL2CAPChannel' => 'CoreBluetooth.CBL2CapChannel, Xamarin.Mac' */ },
		{ NULL, 0xF1616 /* #1369 'CBManager' => 'CoreBluetooth.CBManager, Xamarin.Mac' */ },
		{ NULL, 0xF1816 /* #1370 'CBMutableCharacteristic' => 'CoreBluetooth.CBMutableCharacteristic, Xamarin.Mac' */ },
		{ NULL, 0xF1916 /* #1371 'CBMutableDescriptor' => 'CoreBluetooth.CBMutableDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xF3616 /* #1372 'CBService' => 'CoreBluetooth.CBService, Xamarin.Mac' */ },
		{ NULL, 0xF1A16 /* #1373 'CBMutableService' => 'CoreBluetooth.CBMutableService, Xamarin.Mac' */ },
		{ NULL, 0xF2616 /* #1374 'CBPeripheralDelegate' => 'CoreBluetooth.CBPeripheralDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF3316 /* #1375 'CBPeripheralManagerDelegate' => 'CoreBluetooth.CBPeripheralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF3716 /* #1376 'CBUUID' => 'CoreBluetooth.CBUUID, Xamarin.Mac' */ },
		{ NULL, 0xF3E16 /* #1377 'AUAudioUnitViewConfiguration' => 'CoreAudioKit.AUAudioUnitViewConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xF4216 /* #1378 'AUGenericView' => 'CoreAudioKit.AUGenericView, Xamarin.Mac' */ },
		{ NULL, 0xF4416 /* #1379 'AUPannerView' => 'CoreAudioKit.AUPannerView, Xamarin.Mac' */ },
		{ NULL, 0xF4516 /* #1380 'AUViewController' => 'CoreAudioKit.AUViewController, Xamarin.Mac' */ },
		{ NULL, 0x150616 /* #1381 'NSWindowController' => 'AppKit.NSWindowController, Xamarin.Mac' */ },
		{ NULL, 0xF4616 /* #1382 'CABTLEMIDIWindowController' => 'CoreAudioKit.CABtleMidiWindowController, Xamarin.Mac' */ },
		{ NULL, 0xF4716 /* #1383 'CAInterDeviceAudioViewController' => 'CoreAudioKit.CAInterDeviceAudioViewController, Xamarin.Mac' */ },
		{ NULL, 0xF4816 /* #1384 'CANetworkBrowserWindowController' => 'CoreAudioKit.CANetworkBrowserWindowController, Xamarin.Mac' */ },
		{ NULL, 0xF4B16 /* #1385 'CAAction' => 'CoreAnimation.CAAction, Xamarin.Mac' */ },
		{ NULL, 0xF5016 /* #1386 'CAAnimationDelegate' => 'CoreAnimation.CAAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF4C16 /* #1387 'CAAnimation' => 'CoreAnimation.CAAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF5116 /* #1388 'CAAnimationGroup' => 'CoreAnimation.CAAnimationGroup, Xamarin.Mac' */ },
		{ NULL, 0xF6C16 /* #1389 'CAPropertyAnimation' => 'CoreAnimation.CAPropertyAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF5216 /* #1390 'CABasicAnimation' => 'CoreAnimation.CABasicAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF5316 /* #1391 'CAConstraint' => 'CoreAnimation.CAConstraint, Xamarin.Mac' */ },
		{ NULL, 0xF5416 /* #1392 'CAConstraintLayoutManager' => 'CoreAnimation.CAConstraintLayoutManager, Xamarin.Mac' */ },
		{ NULL, 0xF5716 /* #1393 'CAEmitterBehavior' => 'CoreAnimation.CAEmitterBehavior, Xamarin.Mac' */ },
		{ NULL, 0xF5816 /* #1394 'CAEmitterCell' => 'CoreAnimation.CAEmitterCell, Xamarin.Mac' */ },
		{ NULL, 0xF5916 /* #1395 'CAEmitterLayer' => 'CoreAnimation.CAEmitterLayer, Xamarin.Mac' */ },
		{ NULL, 0xF5B16 /* #1396 'CAGradientLayer' => 'CoreAnimation.CAGradientLayer, Xamarin.Mac' */ },
		{ NULL, 0xF5E16 /* #1397 'CAKeyframeAnimation' => 'CoreAnimation.CAKeyFrameAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF6316 /* #1398 'CALayerDelegate' => 'CoreAnimation.CALayerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF6616 /* #1399 'CAMediaTiming' => 'CoreAnimation.CAMediaTiming, Xamarin.Mac' */ },
		{ NULL, 0xF6716 /* #1400 'CAMediaTimingFunction' => 'CoreAnimation.CAMediaTimingFunction, Xamarin.Mac' */ },
		{ NULL, 0xF6A16 /* #1401 'CAMetalLayer' => 'CoreAnimation.CAMetalLayer, Xamarin.Mac' */ },
		{ NULL, 0xF6D16 /* #1402 'CARenderer' => 'CoreAnimation.CARenderer, Xamarin.Mac' */ },
		{ NULL, 0xF7016 /* #1403 'CAReplicatorLayer' => 'CoreAnimation.CAReplicatorLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7316 /* #1404 'CAScrollLayer' => 'CoreAnimation.CAScrollLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7416 /* #1405 'CAShapeLayer' => 'CoreAnimation.CAShapeLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7516 /* #1406 'CASpringAnimation' => 'CoreAnimation.CASpringAnimation, Xamarin.Mac' */ },
		{ NULL, 0xF7616 /* #1407 'CATextLayer' => 'CoreAnimation.CATextLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7B16 /* #1408 'CATiledLayer' => 'CoreAnimation.CATiledLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7C16 /* #1409 'CATransaction' => 'CoreAnimation.CATransaction, Xamarin.Mac' */ },
		{ NULL, 0xF7D16 /* #1410 'CATransformLayer' => 'CoreAnimation.CATransformLayer, Xamarin.Mac' */ },
		{ NULL, 0xF7E16 /* #1411 'CATransition' => 'CoreAnimation.CATransition, Xamarin.Mac' */ },
		{ NULL, 0xF7F16 /* #1412 'CAValueFunction' => 'CoreAnimation.CAValueFunction, Xamarin.Mac' */ },
		{ NULL, 0xF8616 /* #1413 'CNContactPicker' => 'ContactsUI.CNContactPicker, Xamarin.Mac' */ },
		{ NULL, 0xF8A16 /* #1414 'CNContactPickerDelegate' => 'ContactsUI.CNContactPickerDelegate, Xamarin.Mac' */ },
		{ NULL, 0xF8B16 /* #1415 'CNContactViewController' => 'ContactsUI.CNContactViewController, Xamarin.Mac' */ },
		{ NULL, 0xF8F16 /* #1416 'CNContactFetchRequest' => 'Contacts.CNContactFetchRequest, Xamarin.Mac' */ },
		{ NULL, 0xF9016 /* #1417 'CNContactFormatter' => 'Contacts.CNContactFormatter, Xamarin.Mac' */ },
		{ NULL, 0xF9316 /* #1418 'CNContactProperty' => 'Contacts.CNContactProperty, Xamarin.Mac' */ },
		{ NULL, 0xF9416 /* #1419 'CNContactRelation' => 'Contacts.CNContactRelation, Xamarin.Mac' */ },
		{ NULL, 0xF9716 /* #1420 'CNContactsUserDefaults' => 'Contacts.CNContactsUserDefaults, Xamarin.Mac' */ },
		{ NULL, 0xF9916 /* #1421 'CNContactVCardSerialization' => 'Contacts.CNContactVCardSerialization, Xamarin.Mac' */ },
		{ NULL, 0xF9A16 /* #1422 'CNContainer' => 'Contacts.CNContainer, Xamarin.Mac' */ },
		{ NULL, 0xFA216 /* #1423 'CNGroup' => 'Contacts.CNGroup, Xamarin.Mac' */ },
		{ NULL, 0xFA516 /* #1424 'CNInstantMessageAddress' => 'Contacts.CNInstantMessageAddress, Xamarin.Mac' */ },
		{ NULL, 0xFAB16 /* #1425 'CNLabeledValue' => 'Contacts.CNLabeledValue`1, Xamarin.Mac' */ },
		{ NULL, 0xF8D16 /* #1426 'CNContact' => 'Contacts.CNContact, Xamarin.Mac' */ },
		{ NULL, 0xFAE16 /* #1427 'CNMutableContact' => 'Contacts.CNMutableContact, Xamarin.Mac' */ },
		{ NULL, 0xFAF16 /* #1428 'CNMutableGroup' => 'Contacts.CNMutableGroup, Xamarin.Mac' */ },
		{ NULL, 0xFB216 /* #1429 'CNPostalAddress' => 'Contacts.CNPostalAddress, Xamarin.Mac' */ },
		{ NULL, 0xFB016 /* #1430 'CNMutablePostalAddress' => 'Contacts.CNMutablePostalAddress, Xamarin.Mac' */ },
		{ NULL, 0xFB116 /* #1431 'CNPhoneNumber' => 'Contacts.CNPhoneNumber, Xamarin.Mac' */ },
		{ NULL, 0xFB316 /* #1432 'CNPostalAddressFormatter' => 'Contacts.CNPostalAddressFormatter, Xamarin.Mac' */ },
		{ NULL, 0xFB816 /* #1433 'CNSaveRequest' => 'Contacts.CNSaveRequest, Xamarin.Mac' */ },
		{ NULL, 0xFB916 /* #1434 'CNSocialProfile' => 'Contacts.CNSocialProfile, Xamarin.Mac' */ },
		{ NULL, 0x179616 /* #1435 'NSOperation' => 'Foundation.NSOperation, Xamarin.Mac' */ },
		{ NULL, 0xFED16 /* #1436 'CKOperation' => 'CloudKit.CKOperation, Xamarin.Mac' */ },
		{ NULL, 0xFC416 /* #1437 'CKAcceptSharesOperation' => 'CloudKit.CKAcceptSharesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFC816 /* #1438 'CKAsset' => 'CloudKit.CKAsset, Xamarin.Mac' */ },
		{ NULL, 0xFE916 /* #1439 'CKNotification' => 'CloudKit.CKNotification, Xamarin.Mac' */ },
		{ NULL, 0xFCB16 /* #1440 'CKDatabaseNotification' => 'CloudKit.CKDatabaseNotification, Xamarin.Mac' */ },
		{ NULL, 0xFCC16 /* #1441 'CKDatabaseOperation' => 'CloudKit.CKDatabaseOperation, Xamarin.Mac' */ },
		{ NULL, 0x100E16 /* #1442 'CKSubscription' => 'CloudKit.CKSubscription, Xamarin.Mac' */ },
		{ NULL, 0xFCE16 /* #1443 'CKDatabaseSubscription' => 'CloudKit.CKDatabaseSubscription, Xamarin.Mac' */ },
		{ NULL, 0xFCF16 /* #1444 'CKDiscoverAllContactsOperation' => 'CloudKit.CKDiscoverAllContactsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD016 /* #1445 'CKDiscoverAllUserIdentitiesOperation' => 'CloudKit.CKDiscoverAllUserIdentitiesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD116 /* #1446 'CKDiscoveredUserInfo' => 'CloudKit.CKDiscoveredUserInfo, Xamarin.Mac' */ },
		{ NULL, 0xFD216 /* #1447 'CKDiscoverUserIdentitiesOperation' => 'CloudKit.CKDiscoverUserIdentitiesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD316 /* #1448 'CKDiscoverUserInfosOperation' => 'CloudKit.CKDiscoverUserInfosOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD716 /* #1449 'CKFetchDatabaseChangesOperation' => 'CloudKit.CKFetchDatabaseChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD816 /* #1450 'CKFetchNotificationChangesOperation' => 'CloudKit.CKFetchNotificationChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFD916 /* #1451 'CKFetchRecordChangesOperation' => 'CloudKit.CKFetchRecordChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFDA16 /* #1452 'CKFetchRecordsOperation' => 'CloudKit.CKFetchRecordsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFDB16 /* #1453 'CKFetchRecordZoneChangesConfiguration' => 'CloudKit.CKFetchRecordZoneChangesConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xFDC16 /* #1454 'CKFetchRecordZoneChangesOperation' => 'CloudKit.CKFetchRecordZoneChangesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFDD16 /* #1455 'CKFetchRecordZoneChangesOptions' => 'CloudKit.CKFetchRecordZoneChangesOptions, Xamarin.Mac' */ },
		{ NULL, 0xFDE16 /* #1456 'CKFetchRecordZonesOperation' => 'CloudKit.CKFetchRecordZonesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFDF16 /* #1457 'CKFetchShareMetadataOperation' => 'CloudKit.CKFetchShareMetadataOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE016 /* #1458 'CKFetchShareParticipantsOperation' => 'CloudKit.CKFetchShareParticipantsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE116 /* #1459 'CKFetchSubscriptionsOperation' => 'CloudKit.CKFetchSubscriptionsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE216 /* #1460 'CKFetchWebAuthTokenOperation' => 'CloudKit.CKFetchWebAuthTokenOperation, Xamarin.Mac' */ },
		{ NULL, 0x17C216 /* #1461 'NSSortDescriptor' => 'Foundation.NSSortDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xFE316 /* #1462 'CKLocationSortDescriptor' => 'CloudKit.CKLocationSortDescriptor, Xamarin.Mac' */ },
		{ NULL, 0xFE416 /* #1463 'CKMarkNotificationsReadOperation' => 'CloudKit.CKMarkNotificationsReadOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE516 /* #1464 'CKModifyBadgeOperation' => 'CloudKit.CKModifyBadgeOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE616 /* #1465 'CKModifyRecordsOperation' => 'CloudKit.CKModifyRecordsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE716 /* #1466 'CKModifyRecordZonesOperation' => 'CloudKit.CKModifyRecordZonesOperation, Xamarin.Mac' */ },
		{ NULL, 0xFE816 /* #1467 'CKModifySubscriptionsOperation' => 'CloudKit.CKModifySubscriptionsOperation, Xamarin.Mac' */ },
		{ NULL, 0xFEA16 /* #1468 'CKNotificationID' => 'CloudKit.CKNotificationID, Xamarin.Mac' */ },
		{ NULL, 0xFEB16 /* #1469 'CKNotificationInfo' => 'CloudKit.CKNotificationInfo, Xamarin.Mac' */ },
		{ NULL, 0xFEE16 /* #1470 'CKOperationConfiguration' => 'CloudKit.CKOperationConfiguration, Xamarin.Mac' */ },
		{ NULL, 0xFEF16 /* #1471 'CKOperationGroup' => 'CloudKit.CKOperationGroup, Xamarin.Mac' */ },
		{ NULL, 0xFF116 /* #1472 'CKQuery' => 'CloudKit.CKQuery, Xamarin.Mac' */ },
		{ NULL, 0xFF216 /* #1473 'CKQueryCursor' => 'CloudKit.CKQueryCursor, Xamarin.Mac' */ },
		{ NULL, 0xFF316 /* #1474 'CKQueryNotification' => 'CloudKit.CKQueryNotification, Xamarin.Mac' */ },
		{ NULL, 0xFF516 /* #1475 'CKQueryOperation' => 'CloudKit.CKQueryOperation, Xamarin.Mac' */ },
		{ NULL, 0xFF616 /* #1476 'CKQuerySubscription' => 'CloudKit.CKQuerySubscription, Xamarin.Mac' */ },
		{ NULL, 0xFF816 /* #1477 'CKRecord' => 'CloudKit.CKRecord, Xamarin.Mac' */ },
		{ NULL, 0xFF916 /* #1478 'CKRecordID' => 'CloudKit.CKRecordID, Xamarin.Mac' */ },
		{ NULL, 0xFFD16 /* #1479 'CKRecordValue' => 'CloudKit.CKRecordValue, Xamarin.Mac' */ },
		{ NULL, 0xFFE16 /* #1480 'CKRecordZone' => 'CloudKit.CKRecordZone, Xamarin.Mac' */ },
		{ NULL, 0x100016 /* #1481 'CKRecordZoneID' => 'CloudKit.CKRecordZoneID, Xamarin.Mac' */ },
		{ NULL, 0x100116 /* #1482 'CKRecordZoneNotification' => 'CloudKit.CKRecordZoneNotification, Xamarin.Mac' */ },
		{ NULL, 0x100216 /* #1483 'CKRecordZoneSubscription' => 'CloudKit.CKRecordZoneSubscription, Xamarin.Mac' */ },
		{ NULL, 0x100316 /* #1484 'CKReference' => 'CloudKit.CKReference, Xamarin.Mac' */ },
		{ NULL, 0x100516 /* #1485 'CKServerChangeToken' => 'CloudKit.CKServerChangeToken, Xamarin.Mac' */ },
		{ NULL, 0x100616 /* #1486 'CKShare' => 'CloudKit.CKShare, Xamarin.Mac' */ },
		{ NULL, 0x100816 /* #1487 'CKShareMetadata' => 'CloudKit.CKShareMetadata, Xamarin.Mac' */ },
		{ NULL, 0x100916 /* #1488 'CKShareParticipant' => 'CloudKit.CKShareParticipant, Xamarin.Mac' */ },
		{ NULL, 0x101116 /* #1489 'CKUserIdentity' => 'CloudKit.CKUserIdentity, Xamarin.Mac' */ },
		{ NULL, 0x101216 /* #1490 'CKUserIdentityLookupInfo' => 'CloudKit.CKUserIdentityLookupInfo, Xamarin.Mac' */ },
		{ NULL, 0x102416 /* #1491 'BCChatAction' => 'BusinessChat.BCChatAction, Xamarin.Mac' */ },
		{ NULL, 0x130316 /* #1492 'NSControl' => 'AppKit.NSControl, Xamarin.Mac' */ },
		{ NULL, 0x102516 /* #1493 'BCChatButton' => 'BusinessChat.BCChatButton, Xamarin.Mac' */ },
		{ NULL, 0x102916 /* #1494 'AVCaptureView' => 'AVKit.AVCaptureView, Xamarin.Mac' */ },
		{ NULL, 0x102D16 /* #1495 'AVCaptureViewDelegate' => 'AVKit.AVCaptureViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x103016 /* #1496 'AVPlayerView' => 'AVKit.AVPlayerView, Xamarin.Mac' */ },
		{ NULL, 0x103416 /* #1497 'AVAssetCache' => 'AVFoundation.AVAssetCache, Xamarin.Mac' */ },
		{ NULL, 0x103A16 /* #1498 'AVAssetImageGenerator' => 'AVFoundation.AVAssetImageGenerator, Xamarin.Mac' */ },
		{ NULL, 0x103C16 /* #1499 'AVAssetReader' => 'AVFoundation.AVAssetReader, Xamarin.Mac' */ },
		{ NULL, 0x103E16 /* #1500 'AVAssetReaderOutput' => 'AVFoundation.AVAssetReaderOutput, Xamarin.Mac' */ },
		{ NULL, 0x103D16 /* #1501 'AVAssetReaderAudioMixOutput' => 'AVFoundation.AVAssetReaderAudioMixOutput, Xamarin.Mac' */ },
		{ NULL, 0x103F16 /* #1502 'AVAssetReaderOutputMetadataAdaptor' => 'AVFoundation.AVAssetReaderOutputMetadataAdaptor, Xamarin.Mac' */ },
		{ NULL, 0x104016 /* #1503 'AVAssetReaderSampleReferenceOutput' => 'AVFoundation.AVAssetReaderSampleReferenceOutput, Xamarin.Mac' */ },
		{ NULL, 0x104216 /* #1504 'AVAssetReaderTrackOutput' => 'AVFoundation.AVAssetReaderTrackOutput, Xamarin.Mac' */ },
		{ NULL, 0x104316 /* #1505 'AVAssetReaderVideoCompositionOutput' => 'AVFoundation.AVAssetReaderVideoCompositionOutput, Xamarin.Mac' */ },
		{ NULL, 0x104516 /* #1506 'AVAssetResourceLoader' => 'AVFoundation.AVAssetResourceLoader, Xamarin.Mac' */ },
		{ NULL, 0x104916 /* #1507 'AVAssetResourceLoaderDelegate' => 'AVFoundation.AVAssetResourceLoaderDelegate, Xamarin.Mac' */ },
		{ NULL, 0x104A16 /* #1508 'AVAssetResourceLoadingContentInformationRequest' => 'AVFoundation.AVAssetResourceLoadingContentInformationRequest, Xamarin.Mac' */ },
		{ NULL, 0x104B16 /* #1509 'AVAssetResourceLoadingDataRequest' => 'AVFoundation.AVAssetResourceLoadingDataRequest, Xamarin.Mac' */ },
		{ NULL, 0x104C16 /* #1510 'AVAssetResourceLoadingRequest' => 'AVFoundation.AVAssetResourceLoadingRequest, Xamarin.Mac' */ },
		{ NULL, 0x104D16 /* #1511 'AVAssetResourceLoadingRequestor' => 'AVFoundation.AVAssetResourceLoadingRequestor, Xamarin.Mac' */ },
		{ NULL, 0x104E16 /* #1512 'AVAssetResourceRenewalRequest' => 'AVFoundation.AVAssetResourceRenewalRequest, Xamarin.Mac' */ },
		{ NULL, 0x105016 /* #1513 'AVAssetTrackGroup' => 'AVFoundation.AVAssetTrackGroup, Xamarin.Mac' */ },
		{ NULL, 0x105116 /* #1514 'AVAssetTrackSegment' => 'AVFoundation.AVAssetTrackSegment, Xamarin.Mac' */ },
		{ NULL, 0x105416 /* #1515 'AVAssetWriterInput' => 'AVFoundation.AVAssetWriterInput, Xamarin.Mac' */ },
		{ NULL, 0x112516 /* #1516 'AVMediaSelectionGroup' => 'AVFoundation.AVMediaSelectionGroup, Xamarin.Mac' */ },
		{ NULL, 0x105516 /* #1517 'AVAssetWriterInputGroup' => 'AVFoundation.AVAssetWriterInputGroup, Xamarin.Mac' */ },
		{ NULL, 0x105816 /* #1518 'AVAssetWriterInputMetadataAdaptor' => 'AVFoundation.AVAssetWriterInputMetadataAdaptor, Xamarin.Mac' */ },
		{ NULL, 0x105916 /* #1519 'AVAssetWriterInputPassDescription' => 'AVFoundation.AVAssetWriterInputPassDescription, Xamarin.Mac' */ },
		{ NULL, 0x105A16 /* #1520 'AVAssetWriterInputPixelBufferAdaptor' => 'AVFoundation.AVAssetWriterInputPixelBufferAdaptor, Xamarin.Mac' */ },
		{ NULL, 0x105C16 /* #1521 'AVAsynchronousCIImageFilteringRequest' => 'AVFoundation.AVAsynchronousCIImageFilteringRequest, Xamarin.Mac' */ },
		{ NULL, 0x105F16 /* #1522 'AVAsynchronousKeyValueLoading' => 'AVFoundation.AVAsynchronousKeyValueLoading, Xamarin.Mac' */ },
		{ NULL, 0x106016 /* #1523 'AVAsynchronousVideoCompositionRequest' => 'AVFoundation.AVAsynchronousVideoCompositionRequest, Xamarin.Mac' */ },
		{ NULL, 0x106316 /* #1524 'AVAudio3DMixing' => 'AVFoundation.AVAudio3DMixing, Xamarin.Mac' */ },
		{ NULL, 0x106616 /* #1525 'AVAudioBuffer' => 'AVFoundation.AVAudioBuffer, Xamarin.Mac' */ },
		{ NULL, 0x106716 /* #1526 'AVAudioChannelLayout' => 'AVFoundation.AVAudioChannelLayout, Xamarin.Mac' */ },
		{ NULL, 0x106916 /* #1527 'AVAudioCompressedBuffer' => 'AVFoundation.AVAudioCompressedBuffer, Xamarin.Mac' */ },
		{ NULL, 0x106A16 /* #1528 'AVAudioConnectionPoint' => 'AVFoundation.AVAudioConnectionPoint, Xamarin.Mac' */ },
		{ NULL, 0x106B16 /* #1529 'AVAudioConverter' => 'AVFoundation.AVAudioConverter, Xamarin.Mac' */ },
		{ NULL, 0x107416 /* #1530 'AVAudioEnvironmentDistanceAttenuationParameters' => 'AVFoundation.AVAudioEnvironmentDistanceAttenuationParameters, Xamarin.Mac' */ },
		{ NULL, 0x108216 /* #1531 'AVAudioNode' => 'AVFoundation.AVAudioNode, Xamarin.Mac' */ },
		{ NULL, 0x107516 /* #1532 'AVAudioEnvironmentNode' => 'AVFoundation.AVAudioEnvironmentNode, Xamarin.Mac' */ },
		{ NULL, 0x107616 /* #1533 'AVAudioEnvironmentReverbParameters' => 'AVFoundation.AVAudioEnvironmentReverbParameters, Xamarin.Mac' */ },
		{ NULL, 0x107716 /* #1534 'AVAudioFile' => 'AVFoundation.AVAudioFile, Xamarin.Mac' */ },
		{ NULL, 0x107816 /* #1535 'AVAudioFormat' => 'AVFoundation.AVAudioFormat, Xamarin.Mac' */ },
		{ NULL, 0x107A16 /* #1536 'AVAudioIONode' => 'AVFoundation.AVAudioIONode, Xamarin.Mac' */ },
		{ NULL, 0x107916 /* #1537 'AVAudioInputNode' => 'AVFoundation.AVAudioInputNode, Xamarin.Mac' */ },
		{ NULL, 0x107B16 /* #1538 'AVAudioMix' => 'AVFoundation.AVAudioMix, Xamarin.Mac' */ },
		{ NULL, 0x107C16 /* #1539 'AVAudioMixerNode' => 'AVFoundation.AVAudioMixerNode, Xamarin.Mac' */ },
		{ NULL, 0x108016 /* #1540 'AVAudioMixingDestination' => 'AVFoundation.AVAudioMixingDestination, Xamarin.Mac' */ },
		{ NULL, 0x108116 /* #1541 'AVAudioMixInputParameters' => 'AVFoundation.AVAudioMixInputParameters, Xamarin.Mac' */ },
		{ NULL, 0x108316 /* #1542 'AVAudioOutputNode' => 'AVFoundation.AVAudioOutputNode, Xamarin.Mac' */ },
		{ NULL, 0x108416 /* #1543 'AVAudioPCMBuffer' => 'AVFoundation.AVAudioPcmBuffer, Xamarin.Mac' */ },
		{ NULL, 0x108516 /* #1544 'AVAudioPlayer' => 'AVFoundation.AVAudioPlayer, Xamarin.Mac' */ },
		{ NULL, 0x108916 /* #1545 'AVAudioPlayerDelegate' => 'AVFoundation.AVAudioPlayerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x108E16 /* #1546 'AVAudioRecorder' => 'AVFoundation.AVAudioRecorder, Xamarin.Mac' */ },
		{ NULL, 0x109216 /* #1547 'AVAudioRecorderDelegate' => 'AVFoundation.AVAudioRecorderDelegate, Xamarin.Mac' */ },
		{ NULL, 0x109316 /* #1548 'AVAudioSequencer' => 'AVFoundation.AVAudioSequencer, Xamarin.Mac' */ },
		{ NULL, 0x10A316 /* #1549 'AVAudioStereoMixing' => 'AVFoundation.AVAudioStereoMixing, Xamarin.Mac' */ },
		{ NULL, 0x10A416 /* #1550 'AVAudioTime' => 'AVFoundation.AVAudioTime, Xamarin.Mac' */ },
		{ NULL, 0x10A816 /* #1551 'AVAudioUnitComponentManager' => 'AVFoundation.AVAudioUnitComponentManager, Xamarin.Mac' */ },
		{ NULL, 0x10A616 /* #1552 'AVAudioUnit' => 'AVFoundation.AVAudioUnit, Xamarin.Mac' */ },
		{ NULL, 0x10AC16 /* #1553 'AVAudioUnitEffect' => 'AVFoundation.AVAudioUnitEffect, Xamarin.Mac' */ },
		{ NULL, 0x10A916 /* #1554 'AVAudioUnitDelay' => 'AVFoundation.AVAudioUnitDelay, Xamarin.Mac' */ },
		{ NULL, 0x10AA16 /* #1555 'AVAudioUnitDistortion' => 'AVFoundation.AVAudioUnitDistortion, Xamarin.Mac' */ },
		{ NULL, 0x10AD16 /* #1556 'AVAudioUnitEQ' => 'AVFoundation.AVAudioUnitEQ, Xamarin.Mac' */ },
		{ NULL, 0x10AE16 /* #1557 'AVAudioUnitEQFilterParameters' => 'AVFoundation.AVAudioUnitEQFilterParameters, Xamarin.Mac' */ },
		{ NULL, 0x10B016 /* #1558 'AVAudioUnitGenerator' => 'AVFoundation.AVAudioUnitGenerator, Xamarin.Mac' */ },
		{ NULL, 0x10B216 /* #1559 'AVAudioUnitMIDIInstrument' => 'AVFoundation.AVAudioUnitMidiInstrument, Xamarin.Mac' */ },
		{ NULL, 0x10B316 /* #1560 'AVAudioUnitReverb' => 'AVFoundation.AVAudioUnitReverb, Xamarin.Mac' */ },
		{ NULL, 0x10B516 /* #1561 'AVAudioUnitSampler' => 'AVFoundation.AVAudioUnitSampler, Xamarin.Mac' */ },
		{ NULL, 0x10B616 /* #1562 'AVAudioUnitTimeEffect' => 'AVFoundation.AVAudioUnitTimeEffect, Xamarin.Mac' */ },
		{ NULL, 0x10B716 /* #1563 'AVAudioUnitTimePitch' => 'AVFoundation.AVAudioUnitTimePitch, Xamarin.Mac' */ },
		{ NULL, 0x10B916 /* #1564 'AVAudioUnitVarispeed' => 'AVFoundation.AVAudioUnitVarispeed, Xamarin.Mac' */ },
		{ NULL, 0x10BC16 /* #1565 'AVCameraCalibrationData' => 'AVFoundation.AVCameraCalibrationData, Xamarin.Mac' */ },
		{ NULL, 0x10BD16 /* #1566 'AVCaptureAudioChannel' => 'AVFoundation.AVCaptureAudioChannel, Xamarin.Mac' */ },
		{ NULL, 0x10DE16 /* #1567 'AVCaptureOutput' => 'AVFoundation.AVCaptureOutput, Xamarin.Mac' */ },
		{ NULL, 0x10BE16 /* #1568 'AVCaptureAudioDataOutput' => 'AVFoundation.AVCaptureAudioDataOutput, Xamarin.Mac' */ },
		{ NULL, 0x10C216 /* #1569 'AVCaptureAudioDataOutputSampleBufferDelegate' => 'AVFoundation.AVCaptureAudioDataOutputSampleBufferDelegate, Xamarin.Mac' */ },
		{ NULL, 0x10CF16 /* #1570 'AVCaptureFileOutput' => 'AVFoundation.AVCaptureFileOutput, Xamarin.Mac' */ },
		{ NULL, 0x10C316 /* #1571 'AVCaptureAudioFileOutput' => 'AVFoundation.AVCaptureAudioFileOutput, Xamarin.Mac' */ },
		{ NULL, 0x10C416 /* #1572 'AVCaptureAudioPreviewOutput' => 'AVFoundation.AVCaptureAudioPreviewOutput, Xamarin.Mac' */ },
		{ NULL, 0x10C716 /* #1573 'AVCaptureConnection' => 'AVFoundation.AVCaptureConnection, Xamarin.Mac' */ },
		{ NULL, 0x10C916 /* #1574 'AVCaptureDeviceFormat' => 'AVFoundation.AVCaptureDeviceFormat, Xamarin.Mac' */ },
		{ NULL, 0x10DA16 /* #1575 'AVCaptureInput' => 'AVFoundation.AVCaptureInput, Xamarin.Mac' */ },
		{ NULL, 0x10CA16 /* #1576 'AVCaptureDeviceInput' => 'AVFoundation.AVCaptureDeviceInput, Xamarin.Mac' */ },
		{ NULL, 0x10CB16 /* #1577 'AVCaptureDeviceInputSource' => 'AVFoundation.AVCaptureDeviceInputSource, Xamarin.Mac' */ },
		{ NULL, 0x10D316 /* #1578 'AVCaptureFileOutputDelegate' => 'AVFoundation.AVCaptureFileOutputDelegate, Xamarin.Mac' */ },
		{ NULL, 0x10D716 /* #1579 'AVCaptureFileOutputRecordingDelegate' => 'AVFoundation.AVCaptureFileOutputRecordingDelegate, Xamarin.Mac' */ },
		{ NULL, 0x10DB16 /* #1580 'AVCaptureInputPort' => 'AVFoundation.AVCaptureInputPort, Xamarin.Mac' */ },
		{ NULL, 0x10DD16 /* #1581 'AVCaptureMovieFileOutput' => 'AVFoundation.AVCaptureMovieFileOutput, Xamarin.Mac' */ },
		{ NULL, 0x10E016 /* #1582 'AVCaptureScreenInput' => 'AVFoundation.AVCaptureScreenInput, Xamarin.Mac' */ },
		{ NULL, 0x10E316 /* #1583 'AVCaptureSynchronizedData' => 'AVFoundation.AVCaptureSynchronizedData, Xamarin.Mac' */ },
		{ NULL, 0x10E416 /* #1584 'AVCaptureSynchronizedDataCollection' => 'AVFoundation.AVCaptureSynchronizedDataCollection, Xamarin.Mac' */ },
		{ NULL, 0x10E616 /* #1585 'AVCaptureVideoDataOutput' => 'AVFoundation.AVCaptureVideoDataOutput, Xamarin.Mac' */ },
		{ NULL, 0x10EA16 /* #1586 'AVCaptureVideoDataOutputSampleBufferDelegate' => 'AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate, Xamarin.Mac' */ },
		{ NULL, 0x103316 /* #1587 'AVAsset' => 'AVFoundation.AVAsset, Xamarin.Mac' */ },
		{ NULL, 0x10F316 /* #1588 'AVComposition' => 'AVFoundation.AVComposition, Xamarin.Mac' */ },
		{ NULL, 0x104F16 /* #1589 'AVAssetTrack' => 'AVFoundation.AVAssetTrack, Xamarin.Mac' */ },
		{ NULL, 0x10F516 /* #1590 'AVCompositionTrack' => 'AVFoundation.AVCompositionTrack, Xamarin.Mac' */ },
		{ NULL, 0x10F616 /* #1591 'AVCompositionTrackSegment' => 'AVFoundation.AVCompositionTrackSegment, Xamarin.Mac' */ },
		{ NULL, 0x110116 /* #1592 'AVContentKeyResponse' => 'AVFoundation.AVContentKeyResponse, Xamarin.Mac' */ },
		{ NULL, 0x110216 /* #1593 'AVContentKeySession' => 'AVFoundation.AVContentKeySession, Xamarin.Mac' */ },
		{ NULL, 0x110716 /* #1594 'AVContentKeySessionDelegate' => 'AVFoundation.AVContentKeySessionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x112F16 /* #1595 'AVMetadataGroup' => 'AVFoundation.AVMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x110A16 /* #1596 'AVDateRangeMetadataGroup' => 'AVFoundation.AVDateRangeMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x110B16 /* #1597 'AVDepthData' => 'AVFoundation.AVDepthData, Xamarin.Mac' */ },
		{ NULL, 0x119416 /* #1598 'AVURLAsset' => 'AVFoundation.AVUrlAsset, Xamarin.Mac' */ },
		{ NULL, 0x111316 /* #1599 'AVFragmentedAsset' => 'AVFoundation.AVFragmentedAsset, Xamarin.Mac' */ },
		{ NULL, 0x111516 /* #1600 'AVFragmentedAssetMinder' => 'AVFoundation.AVFragmentedAssetMinder, Xamarin.Mac' */ },
		{ NULL, 0x111616 /* #1601 'AVFragmentedAssetTrack' => 'AVFoundation.AVFragmentedAssetTrack, Xamarin.Mac' */ },
		{ NULL, 0x111916 /* #1602 'AVFragmentedMovieMinder' => 'AVFoundation.AVFragmentedMovieMinder, Xamarin.Mac' */ },
		{ NULL, 0x111E16 /* #1603 'AVFrameRateRange' => 'AVFoundation.AVFrameRateRange, Xamarin.Mac' */ },
		{ NULL, 0x112316 /* #1604 'AVMediaDataStorage' => 'AVFoundation.AVMediaDataStorage, Xamarin.Mac' */ },
		{ NULL, 0x112416 /* #1605 'AVMediaSelection' => 'AVFoundation.AVMediaSelection, Xamarin.Mac' */ },
		{ NULL, 0x112616 /* #1606 'AVMediaSelectionOption' => 'AVFoundation.AVMediaSelectionOption, Xamarin.Mac' */ },
		{ NULL, 0x113316 /* #1607 'AVMetadataObject' => 'AVFoundation.AVMetadataObject, Xamarin.Mac' */ },
		{ NULL, 0x112C16 /* #1608 'AVMetadataFaceObject' => 'AVFoundation.AVMetadataFaceObject, Xamarin.Mac' */ },
		{ NULL, 0x113116 /* #1609 'AVMetadataItemFilter' => 'AVFoundation.AVMetadataItemFilter, Xamarin.Mac' */ },
		{ NULL, 0x113216 /* #1610 'AVMetadataItemValueRequest' => 'AVFoundation.AVMetadataItemValueRequest, Xamarin.Mac' */ },
		{ NULL, 0x113616 /* #1611 'AVMovie' => 'AVFoundation.AVMovie, Xamarin.Mac' */ },
		{ NULL, 0x113916 /* #1612 'AVMovieTrack' => 'AVFoundation.AVMovieTrack, Xamarin.Mac' */ },
		{ NULL, 0x113C16 /* #1613 'AVMusicTrack' => 'AVFoundation.AVMusicTrack, Xamarin.Mac' */ },
		{ NULL, 0x113E16 /* #1614 'AVMutableAudioMix' => 'AVFoundation.AVMutableAudioMix, Xamarin.Mac' */ },
		{ NULL, 0x113F16 /* #1615 'AVMutableAudioMixInputParameters' => 'AVFoundation.AVMutableAudioMixInputParameters, Xamarin.Mac' */ },
		{ NULL, 0x114016 /* #1616 'AVMutableComposition' => 'AVFoundation.AVMutableComposition, Xamarin.Mac' */ },
		{ NULL, 0x114216 /* #1617 'AVMutableCompositionTrack' => 'AVFoundation.AVMutableCompositionTrack, Xamarin.Mac' */ },
		{ NULL, 0x114316 /* #1618 'AVMutableDateRangeMetadataGroup' => 'AVFoundation.AVMutableDateRangeMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x114416 /* #1619 'AVMutableMediaSelection' => 'AVFoundation.AVMutableMediaSelection, Xamarin.Mac' */ },
		{ NULL, 0x113016 /* #1620 'AVMetadataItem' => 'AVFoundation.AVMetadataItem, Xamarin.Mac' */ },
		{ NULL, 0x114516 /* #1621 'AVMutableMetadataItem' => 'AVFoundation.AVMutableMetadataItem, Xamarin.Mac' */ },
		{ NULL, 0x114616 /* #1622 'AVMutableMovie' => 'AVFoundation.AVMutableMovie, Xamarin.Mac' */ },
		{ NULL, 0x114A16 /* #1623 'AVMutableMovieTrack' => 'AVFoundation.AVMutableMovieTrack, Xamarin.Mac' */ },
		{ NULL, 0x119316 /* #1624 'AVTimedMetadataGroup' => 'AVFoundation.AVTimedMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x114D16 /* #1625 'AVMutableTimedMetadataGroup' => 'AVFoundation.AVMutableTimedMetadataGroup, Xamarin.Mac' */ },
		{ NULL, 0x119F16 /* #1626 'AVVideoComposition' => 'AVFoundation.AVVideoComposition, Xamarin.Mac' */ },
		{ NULL, 0x114E16 /* #1627 'AVMutableVideoComposition' => 'AVFoundation.AVMutableVideoComposition, Xamarin.Mac' */ },
		{ NULL, 0x11A116 /* #1628 'AVVideoCompositionInstruction' => 'AVFoundation.AVVideoCompositionInstruction, Xamarin.Mac' */ },
		{ NULL, 0x114F16 /* #1629 'AVMutableVideoCompositionInstruction' => 'AVFoundation.AVMutableVideoCompositionInstruction, Xamarin.Mac' */ },
		{ NULL, 0x11A216 /* #1630 'AVVideoCompositionLayerInstruction' => 'AVFoundation.AVVideoCompositionLayerInstruction, Xamarin.Mac' */ },
		{ NULL, 0x115016 /* #1631 'AVMutableVideoCompositionLayerInstruction' => 'AVFoundation.AVMutableVideoCompositionLayerInstruction, Xamarin.Mac' */ },
		{ NULL, 0x115116 /* #1632 'AVOutputSettingsAssistant' => 'AVFoundation.AVOutputSettingsAssistant, Xamarin.Mac' */ },
		{ NULL, 0x10FC16 /* #1633 'AVContentKeyRequest' => 'AVFoundation.AVContentKeyRequest, Xamarin.Mac' */ },
		{ NULL, 0x115216 /* #1634 'AVPersistableContentKeyRequest' => 'AVFoundation.AVPersistableContentKeyRequest, Xamarin.Mac' */ },
		{ NULL, 0x115916 /* #1635 'AVPlayerItemAccessLog' => 'AVFoundation.AVPlayerItemAccessLog, Xamarin.Mac' */ },
		{ NULL, 0x115A16 /* #1636 'AVPlayerItemAccessLogEvent' => 'AVFoundation.AVPlayerItemAccessLogEvent, Xamarin.Mac' */ },
		{ NULL, 0x115B16 /* #1637 'AVPlayerItemErrorLog' => 'AVFoundation.AVPlayerItemErrorLog, Xamarin.Mac' */ },
		{ NULL, 0x115C16 /* #1638 'AVPlayerItemErrorLogEvent' => 'AVFoundation.AVPlayerItemErrorLogEvent, Xamarin.Mac' */ },
		{ NULL, 0x116C16 /* #1639 'AVPlayerItemOutput' => 'AVFoundation.AVPlayerItemOutput, Xamarin.Mac' */ },
		{ NULL, 0x115D16 /* #1640 'AVPlayerItemLegibleOutput' => 'AVFoundation.AVPlayerItemLegibleOutput, Xamarin.Mac' */ },
		{ NULL, 0x117416 /* #1641 'AVPlayerItemOutputPushDelegate' => 'AVFoundation.AVPlayerItemOutputPushDelegate, Xamarin.Mac' */ },
		{ NULL, 0x116116 /* #1642 'AVPlayerItemLegibleOutputPushDelegate' => 'AVFoundation.AVPlayerItemLegibleOutputPushDelegate, Xamarin.Mac' */ },
		{ NULL, 0x116216 /* #1643 'AVPlayerItemMediaDataCollector' => 'AVFoundation.AVPlayerItemMediaDataCollector, Xamarin.Mac' */ },
		{ NULL, 0x116316 /* #1644 'AVPlayerItemMetadataCollector' => 'AVFoundation.AVPlayerItemMetadataCollector, Xamarin.Mac' */ },
		{ NULL, 0x116616 /* #1645 'AVPlayerItemMetadataCollectorPushDelegate' => 'AVFoundation.AVPlayerItemMetadataCollectorPushDelegate, Xamarin.Mac' */ },
		{ NULL, 0x116716 /* #1646 'AVPlayerItemMetadataOutput' => 'AVFoundation.AVPlayerItemMetadataOutput, Xamarin.Mac' */ },
		{ NULL, 0x116B16 /* #1647 'AVPlayerItemMetadataOutputPushDelegate' => 'AVFoundation.AVPlayerItemMetadataOutputPushDelegate, Xamarin.Mac' */ },
		{ NULL, 0x117016 /* #1648 'AVPlayerItemOutputPullDelegate' => 'AVFoundation.AVPlayerItemOutputPullDelegate, Xamarin.Mac' */ },
		{ NULL, 0x117616 /* #1649 'AVPlayerItemTrack' => 'AVFoundation.AVPlayerItemTrack, Xamarin.Mac' */ },
		{ NULL, 0x117A16 /* #1650 'AVPlayerLayer' => 'AVFoundation.AVPlayerLayer, Xamarin.Mac' */ },
		{ NULL, 0x117B16 /* #1651 'AVPlayerLooper' => 'AVFoundation.AVPlayerLooper, Xamarin.Mac' */ },
		{ NULL, 0x117D16 /* #1652 'AVPlayerMediaSelectionCriteria' => 'AVFoundation.AVPlayerMediaSelectionCriteria, Xamarin.Mac' */ },
		{ NULL, 0x118016 /* #1653 'AVPortraitEffectsMatte' => 'AVFoundation.AVPortraitEffectsMatte, Xamarin.Mac' */ },
		{ NULL, 0x115516 /* #1654 'AVPlayer' => 'AVFoundation.AVPlayer, Xamarin.Mac' */ },
		{ NULL, 0x118416 /* #1655 'AVQueuePlayer' => 'AVFoundation.AVQueuePlayer, Xamarin.Mac' */ },
		{ NULL, 0x118A16 /* #1656 'AVSampleBufferRequest' => 'AVFoundation.AVSampleBufferRequest, Xamarin.Mac' */ },
		{ NULL, 0x118D16 /* #1657 'AVSampleCursor' => 'AVFoundation.AVSampleCursor, Xamarin.Mac' */ },
		{ NULL, 0x119116 /* #1658 'AVSynchronizedLayer' => 'AVFoundation.AVSynchronizedLayer, Xamarin.Mac' */ },
		{ NULL, 0x119216 /* #1659 'AVTextStyleRule' => 'AVFoundation.AVTextStyleRule, Xamarin.Mac' */ },
		{ NULL, 0x119E16 /* #1660 'AVVideoCompositing' => 'AVFoundation.AVVideoCompositing, Xamarin.Mac' */ },
		{ NULL, 0x11A016 /* #1661 'AVVideoCompositionCoreAnimationTool' => 'AVFoundation.AVVideoCompositionCoreAnimationTool, Xamarin.Mac' */ },
		{ NULL, 0x11A316 /* #1662 'AVVideoCompositionRenderContext' => 'AVFoundation.AVVideoCompositionRenderContext, Xamarin.Mac' */ },
		{ NULL, 0x11A716 /* #1663 'AVVideoCompositionValidationHandling' => 'AVFoundation.AVVideoCompositionValidationHandling, Xamarin.Mac' */ },
		{ NULL, 0x11B916 /* #1664 'AVFoundation_AVCaptureDataOutputSynchronizer' => 'AVFoundation.AVCaptureDataOutputSynchronizer, Xamarin.Mac' */ },
		{ NULL, 0x11BB16 /* #1665 'AVFoundation_AVCaptureDataOutputSynchronizerDelegate' => 'AVFoundation.AVCaptureDataOutputSynchronizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11BF16 /* #1666 'AVFoundation_InternalAVAudioPlayerDelegate' => 'AVFoundation.InternalAVAudioPlayerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11C016 /* #1667 'AVFoundation_InternalAVAudioRecorderDelegate' => 'AVFoundation.InternalAVAudioRecorderDelegate, Xamarin.Mac' */ },
		{ NULL, 0x11DE16 /* #1668 'AUAudioUnitBus' => 'AudioUnit.AUAudioUnitBus, Xamarin.Mac' */ },
		{ NULL, 0x11DF16 /* #1669 'AUAudioUnitBusArray' => 'AudioUnit.AUAudioUnitBusArray, Xamarin.Mac' */ },
		{ NULL, 0x11E216 /* #1670 'AUAudioUnitPreset' => 'AudioUnit.AUAudioUnitPreset, Xamarin.Mac' */ },
		{ NULL, 0x11E516 /* #1671 'AUParameterNode' => 'AudioUnit.AUParameterNode, Xamarin.Mac' */ },
		{ NULL, 0x11E316 /* #1672 'AUParameter' => 'AudioUnit.AUParameter, Xamarin.Mac' */ },
		{ NULL, 0x11E416 /* #1673 'AUParameterGroup' => 'AudioUnit.AUParameterGroup, Xamarin.Mac' */ },
		{ NULL, 0x11E616 /* #1674 'AUParameterTree' => 'AudioUnit.AUParameterTree, Xamarin.Mac' */ },
		{ NULL, 0x125416 /* #1675 'NSAccessibilityCustomAction' => 'AppKit.NSAccessibilityCustomAction, Xamarin.Mac' */ },
		{ NULL, 0x125516 /* #1676 'NSAccessibilityCustomRotor' => 'AppKit.NSAccessibilityCustomRotor, Xamarin.Mac' */ },
		{ NULL, 0x125616 /* #1677 'NSAccessibilityCustomRotorItemResult' => 'AppKit.NSAccessibilityCustomRotorItemResult, Xamarin.Mac' */ },
		{ NULL, 0x125916 /* #1678 'NSAccessibilityCustomRotorItemSearchDelegate' => 'AppKit.NSAccessibilityCustomRotorItemSearchDelegate, Xamarin.Mac' */ },
		{ NULL, 0x125A16 /* #1679 'NSAccessibilityCustomRotorSearchParameters' => 'AppKit.NSAccessibilityCustomRotorSearchParameters, Xamarin.Mac' */ },
		{ NULL, 0x12C016 /* #1680 'NSCell' => 'AppKit.NSCell, Xamarin.Mac' */ },
		{ NULL, 0x128716 /* #1681 'NSActionCell' => 'AppKit.NSActionCell, Xamarin.Mac' */ },
		{ NULL, 0x128C16 /* #1682 'NSAlertDelegate' => 'AppKit.NSAlertDelegate, Xamarin.Mac' */ },
		{ NULL, 0x128D16 /* #1683 'NSAlignmentFeedbackFilter' => 'AppKit.NSAlignmentFeedbackFilter, Xamarin.Mac' */ },
		{ NULL, 0x129016 /* #1684 'NSAlignmentFeedbackToken' => 'AppKit.NSAlignmentFeedbackToken, Xamarin.Mac' */ },
		{ NULL, 0x129316 /* #1685 'NSAnimationContext' => 'AppKit.NSAnimationContext, Xamarin.Mac' */ },
		{ NULL, 0x129716 /* #1686 'NSAnimationDelegate' => 'AppKit.NSAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x129816 /* #1687 'NSAppearance' => 'AppKit.NSAppearance, Xamarin.Mac' */ },
		{ NULL, 0x129C16 /* #1688 'NSAppearanceCustomization' => 'AppKit.NSAppearanceCustomization, Xamarin.Mac' */ },
		{ NULL, 0x12AB16 /* #1689 'NSApplicationDelegate' => 'AppKit.NSApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x130516 /* #1690 'NSController' => 'AppKit.NSController, Xamarin.Mac' */ },
		{ NULL, 0x139416 /* #1691 'NSObjectController' => 'AppKit.NSObjectController, Xamarin.Mac' */ },
		{ NULL, 0x12AC16 /* #1692 'NSArrayController' => 'AppKit.NSArrayController, Xamarin.Mac' */ },
		{ NULL, 0x14EC16 /* #1693 'NSTypesetter' => 'AppKit.NSTypesetter, Xamarin.Mac' */ },
		{ NULL, 0x12AD16 /* #1694 'NSATSTypesetter' => 'AppKit.NSATSTypesetter, Xamarin.Mac' */ },
		{ NULL, 0x12AF16 /* #1695 'NSBezierPath' => 'AppKit.NSBezierPath, Xamarin.Mac' */ },
		{ NULL, 0x136A16 /* #1696 'NSImageRep' => 'AppKit.NSImageRep, Xamarin.Mac' */ },
		{ NULL, 0x12B016 /* #1697 'NSBitmapImageRep' => 'AppKit.NSBitmapImageRep, Xamarin.Mac' */ },
		{ NULL, 0x12B116 /* #1698 'NSBox' => 'AppKit.NSBox, Xamarin.Mac' */ },
		{ NULL, 0x12B316 /* #1699 'NSBrowserCell' => 'AppKit.NSBrowserCell, Xamarin.Mac' */ },
		{ NULL, 0x12B716 /* #1700 'NSBrowserDelegate' => 'AppKit.NSBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12B816 /* #1701 'NSButton' => 'AppKit.NSButton, Xamarin.Mac' */ },
		{ NULL, 0x12B916 /* #1702 'NSButtonCell' => 'AppKit.NSButtonCell, Xamarin.Mac' */ },
		{ NULL, 0x12BA16 /* #1703 'NSCachedImageRep' => 'AppKit.NSCachedImageRep, Xamarin.Mac' */ },
		{ NULL, 0x14E416 /* #1704 'NSTouchBarItem' => 'AppKit.NSTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x12BB16 /* #1705 'NSCandidateListTouchBarItem' => 'AppKit.NSCandidateListTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x12BF16 /* #1706 'NSCandidateListTouchBarItemDelegate' => 'AppKit.NSCandidateListTouchBarItemDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12C116 /* #1707 'NSCIImageRep' => 'AppKit.NSCIImageRep, Xamarin.Mac' */ },
		{ NULL, 0x12C316 /* #1708 'NSClipView' => 'AppKit.NSClipView, Xamarin.Mac' */ },
		{ NULL, 0x142D16 /* #1709 'NSSharingServiceDelegate' => 'AppKit.NSSharingServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12C716 /* #1710 'NSCloudSharingServiceDelegate' => 'AppKit.NSCloudSharingServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12CC16 /* #1711 'NSCollectionView' => 'AppKit.NSCollectionView, Xamarin.Mac' */ },
		{ NULL, 0x12D016 /* #1712 'NSCollectionViewDataSource' => 'AppKit.NSCollectionViewDataSource, Xamarin.Mac' */ },
		{ NULL, 0x12D416 /* #1713 'NSCollectionViewDelegate' => 'AppKit.NSCollectionViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x12D816 /* #1714 'NSCollectionViewDelegateFlowLayout' => 'AppKit.NSCollectionViewDelegateFlowLayout, Xamarin.Mac' */ },
		{ NULL, 0x12DC16 /* #1715 'NSCollectionViewElement' => 'AppKit.NSCollectionViewElement, Xamarin.Mac' */ },
		{ NULL, 0x12E116 /* #1716 'NSCollectionViewLayout' => 'AppKit.NSCollectionViewLayout, Xamarin.Mac' */ },
		{ NULL, 0x12DD16 /* #1717 'NSCollectionViewFlowLayout' => 'AppKit.NSCollectionViewFlowLayout, Xamarin.Mac' */ },
		{ NULL, 0x12E316 /* #1718 'NSCollectionViewLayoutInvalidationContext' => 'AppKit.NSCollectionViewLayoutInvalidationContext, Xamarin.Mac' */ },
		{ NULL, 0x12DE16 /* #1719 'NSCollectionViewFlowLayoutInvalidationContext' => 'AppKit.NSCollectionViewFlowLayoutInvalidationContext, Xamarin.Mac' */ },
		{ NULL, 0x12DF16 /* #1720 'NSCollectionViewGridLayout' => 'AppKit.NSCollectionViewGridLayout, Xamarin.Mac' */ },
		{ NULL, 0x12E016 /* #1721 'NSCollectionViewItem' => 'AppKit.NSCollectionViewItem, Xamarin.Mac' */ },
		{ NULL, 0x12E216 /* #1722 'NSCollectionViewLayoutAttributes' => 'AppKit.NSCollectionViewLayoutAttributes, Xamarin.Mac' */ },
		{ NULL, 0x12EA16 /* #1723 'NSCollectionViewTransitionLayout' => 'AppKit.NSCollectionViewTransitionLayout, Xamarin.Mac' */ },
		{ NULL, 0x12EB16 /* #1724 'NSCollectionViewUpdateItem' => 'AppKit.NSCollectionViewUpdateItem, Xamarin.Mac' */ },
		{ NULL, 0x12EF16 /* #1725 'NSColorList' => 'AppKit.NSColorList, Xamarin.Mac' */ },
		{ NULL, 0x12F116 /* #1726 'NSColorPicker' => 'AppKit.NSColorPicker, Xamarin.Mac' */ },
		{ NULL, 0x12F216 /* #1727 'NSColorPickerTouchBarItem' => 'AppKit.NSColorPickerTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x12F316 /* #1728 'NSColorSpace' => 'AppKit.NSColorSpace, Xamarin.Mac' */ },
		{ NULL, 0x12F416 /* #1729 'NSColorWell' => 'AppKit.NSColorWell, Xamarin.Mac' */ },
		{ NULL, 0x149D16 /* #1730 'NSTextFieldCell' => 'AppKit.NSTextFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x12F616 /* #1731 'NSComboBoxCell' => 'AppKit.NSComboBoxCell, Xamarin.Mac' */ },
		{ NULL, 0x12FA16 /* #1732 'NSComboBoxCellDataSource' => 'AppKit.NSComboBoxCellDataSource, Xamarin.Mac' */ },
		{ NULL, 0x12FE16 /* #1733 'NSComboBoxDataSource' => 'AppKit.NSComboBoxDataSource, Xamarin.Mac' */ },
		{ NULL, 0x14A116 /* #1734 'NSTextFieldDelegate' => 'AppKit.NSTextFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x130216 /* #1735 'NSComboBoxDelegate' => 'AppKit.NSComboBoxDelegate, Xamarin.Mac' */ },
		{ NULL, 0x130916 /* #1736 'NSControlTextEditingDelegate' => 'AppKit.NSControlTextEditingDelegate, Xamarin.Mac' */ },
		{ NULL, 0x130A16 /* #1737 'NSCursor' => 'AppKit.NSCursor, Xamarin.Mac' */ },
		{ NULL, 0x130B16 /* #1738 'NSCustomImageRep' => 'AppKit.NSCustomImageRep, Xamarin.Mac' */ },
		{ NULL, 0x130C16 /* #1739 'NSCustomTouchBarItem' => 'AppKit.NSCustomTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x130D16 /* #1740 'NSDataAsset' => 'AppKit.NSDataAsset, Xamarin.Mac' */ },
		{ NULL, 0x131416 /* #1741 'NSDatePickerCellDelegate' => 'AppKit.NSDatePickerCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x131516 /* #1742 'NSDictionaryController' => 'AppKit.NSDictionaryController, Xamarin.Mac' */ },
		{ NULL, 0x131616 /* #1743 'NSDictionaryControllerKeyValuePair' => 'AppKit.NSDictionaryControllerKeyValuePair, Xamarin.Mac' */ },
		{ NULL, 0x131716 /* #1744 'NSDockTile' => 'AppKit.NSDockTile, Xamarin.Mac' */ },
		{ NULL, 0x131A16 /* #1745 'NSDockTilePlugIn' => 'AppKit.NSDockTilePlugIn, Xamarin.Mac' */ },
		{ NULL, 0x131C16 /* #1746 'NSDocumentController' => 'AppKit.NSDocumentController, Xamarin.Mac' */ },
		{ NULL, 0x132016 /* #1747 'NSDraggingDestination' => 'AppKit.NSDraggingDestination, Xamarin.Mac' */ },
		{ NULL, 0x132116 /* #1748 'NSDraggingImageComponent' => 'AppKit.NSDraggingImageComponent, Xamarin.Mac' */ },
		{ NULL, 0x132616 /* #1749 'NSDraggingItem' => 'AppKit.NSDraggingItem, Xamarin.Mac' */ },
		{ NULL, 0x132716 /* #1750 'NSDraggingSession' => 'AppKit.NSDraggingSession, Xamarin.Mac' */ },
		{ NULL, 0x132B16 /* #1751 'NSDraggingSource' => 'AppKit.NSDraggingSource, Xamarin.Mac' */ },
		{ NULL, 0x133016 /* #1752 'NSDrawerDelegate' => 'AppKit.NSDrawerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x133616 /* #1753 'NSEPSImageRep' => 'AppKit.NSEPSImageRep, Xamarin.Mac' */ },
		{ NULL, 0x133916 /* #1754 'NSFilePromiseProvider' => 'AppKit.NSFilePromiseProvider, Xamarin.Mac' */ },
		{ NULL, 0x133D16 /* #1755 'NSFilePromiseReceiver' => 'AppKit.NSFilePromiseReceiver, Xamarin.Mac' */ },
		{ NULL, 0x133F16 /* #1756 'NSFontAssetRequest' => 'AppKit.NSFontAssetRequest, Xamarin.Mac' */ },
		{ NULL, 0x134416 /* #1757 'NSFontDescriptor' => 'AppKit.NSFontDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x134516 /* #1758 'NSFontManager' => 'AppKit.NSFontManager, Xamarin.Mac' */ },
		{ NULL, 0x134616 /* #1759 'NSFontPanel' => 'AppKit.NSFontPanel, Xamarin.Mac' */ },
		{ NULL, 0x137D16 /* #1760 'NSMatrix' => 'AppKit.NSMatrix, Xamarin.Mac' */ },
		{ NULL, 0x134816 /* #1761 'NSForm' => 'AppKit.NSForm, Xamarin.Mac' */ },
		{ NULL, 0x134916 /* #1762 'NSFormCell' => 'AppKit.NSFormCell, Xamarin.Mac' */ },
		{ NULL, 0x134F16 /* #1763 'NSGestureRecognizerDelegate' => 'AppKit.NSGestureRecognizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x135016 /* #1764 'NSGlyphGenerator' => 'AppKit.NSGlyphGenerator, Xamarin.Mac' */ },
		{ NULL, 0x135116 /* #1765 'NSGlyphInfo' => 'AppKit.NSGlyphInfo, Xamarin.Mac' */ },
		{ NULL, 0x135316 /* #1766 'NSGraphicsContext' => 'AppKit.NSGraphicsContext, Xamarin.Mac' */ },
		{ NULL, 0x135416 /* #1767 'NSGridCell' => 'AppKit.NSGridCell, Xamarin.Mac' */ },
		{ NULL, 0x135516 /* #1768 'NSGridColumn' => 'AppKit.NSGridColumn, Xamarin.Mac' */ },
		{ NULL, 0x135616 /* #1769 'NSGridRow' => 'AppKit.NSGridRow, Xamarin.Mac' */ },
		{ NULL, 0x135716 /* #1770 'NSGridView' => 'AppKit.NSGridView, Xamarin.Mac' */ },
		{ NULL, 0x135816 /* #1771 'NSGroupTouchBarItem' => 'AppKit.NSGroupTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x135916 /* #1772 'NSHapticFeedbackManager' => 'AppKit.NSHapticFeedbackManager, Xamarin.Mac' */ },
		{ NULL, 0x135C16 /* #1773 'NSHapticFeedbackPerformer' => 'AppKit.NSHapticFeedbackPerformer, Xamarin.Mac' */ },
		{ NULL, 0x136216 /* #1774 'NSImageCell' => 'AppKit.NSImageCell, Xamarin.Mac' */ },
		{ NULL, 0x136616 /* #1775 'NSImageDelegate' => 'AppKit.NSImageDelegate, Xamarin.Mac' */ },
		{ NULL, 0x136B16 /* #1776 'NSImageView' => 'AppKit.NSImageView, Xamarin.Mac' */ },
		{ NULL, 0x136F16 /* #1777 'NSLayoutAnchor' => 'AppKit.NSLayoutAnchor`1, Xamarin.Mac' */ },
		{ NULL, 0x137016 /* #1778 'NSLayoutConstraint' => 'AppKit.NSLayoutConstraint, Xamarin.Mac' */ },
		{ NULL, 0x137116 /* #1779 'NSLayoutDimension' => 'AppKit.NSLayoutDimension, Xamarin.Mac' */ },
		{ NULL, 0x137216 /* #1780 'NSLayoutGuide' => 'AppKit.NSLayoutGuide, Xamarin.Mac' */ },
		{ NULL, 0x137316 /* #1781 'NSLayoutManager' => 'AppKit.NSLayoutManager, Xamarin.Mac' */ },
		{ NULL, 0x137716 /* #1782 'NSLayoutManagerDelegate' => 'AppKit.NSLayoutManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x137816 /* #1783 'NSLayoutXAxisAnchor' => 'AppKit.NSLayoutXAxisAnchor, Xamarin.Mac' */ },
		{ NULL, 0x137916 /* #1784 'NSLayoutYAxisAnchor' => 'AppKit.NSLayoutYAxisAnchor, Xamarin.Mac' */ },
		{ NULL, 0x137A16 /* #1785 'NSLevelIndicator' => 'AppKit.NSLevelIndicator, Xamarin.Mac' */ },
		{ NULL, 0x137B16 /* #1786 'NSLevelIndicatorCell' => 'AppKit.NSLevelIndicatorCell, Xamarin.Mac' */ },
		{ NULL, 0x138016 /* #1787 'NSMatrixDelegate' => 'AppKit.NSMatrixDelegate, Xamarin.Mac' */ },
		{ NULL, 0x138516 /* #1788 'NSMenuDelegate' => 'AppKit.NSMenuDelegate, Xamarin.Mac' */ },
		{ NULL, 0x138716 /* #1789 'NSMenuItemCell' => 'AppKit.NSMenuItemCell, Xamarin.Mac' */ },
		{ NULL, 0x138C16 /* #1790 'NSMenuView' => 'AppKit.NSMenuView, Xamarin.Mac' */ },
		{ NULL, 0x134316 /* #1791 'NSFontCollection' => 'AppKit.NSFontCollection, Xamarin.Mac' */ },
		{ NULL, 0x138E16 /* #1792 'NSMutableFontCollection' => 'AppKit.NSMutableFontCollection, Xamarin.Mac' */ },
		{ NULL, 0x13B216 /* #1793 'NSParagraphStyle' => 'AppKit.NSParagraphStyle, Xamarin.Mac' */ },
		{ NULL, 0x138F16 /* #1794 'NSMutableParagraphStyle' => 'AppKit.NSMutableParagraphStyle, Xamarin.Mac' */ },
		{ NULL, 0x139016 /* #1795 'NSNib' => 'AppKit.NSNib, Xamarin.Mac' */ },
		{ NULL, 0x139516 /* #1796 'NSOpenGLContext' => 'AppKit.NSOpenGLContext, Xamarin.Mac' */ },
		{ NULL, 0x139616 /* #1797 'NSOpenGLLayer' => 'AppKit.NSOpenGLLayer, Xamarin.Mac' */ },
		{ NULL, 0x139716 /* #1798 'NSOpenGLPixelBuffer' => 'AppKit.NSOpenGLPixelBuffer, Xamarin.Mac' */ },
		{ NULL, 0x139816 /* #1799 'NSOpenGLPixelFormat' => 'AppKit.NSOpenGLPixelFormat, Xamarin.Mac' */ },
		{ NULL, 0x139916 /* #1800 'NSOpenGLView' => 'AppKit.NSOpenGLView, Xamarin.Mac' */ },
		{ NULL, 0x13F716 /* #1801 'NSSavePanel' => 'AppKit.NSSavePanel, Xamarin.Mac' */ },
		{ NULL, 0x139A16 /* #1802 'NSOpenPanel' => 'AppKit.NSOpenPanel, Xamarin.Mac' */ },
		{ NULL, 0x139E16 /* #1803 'NSOpenSavePanelDelegate' => 'AppKit.NSOpenSavePanelDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13A316 /* #1804 'NSOutlineViewDataSource' => 'AppKit.NSOutlineViewDataSource, Xamarin.Mac' */ },
		{ NULL, 0x13A716 /* #1805 'NSOutlineViewDelegate' => 'AppKit.NSOutlineViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13AE16 /* #1806 'NSPageControllerDelegate' => 'AppKit.NSPageControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13AF16 /* #1807 'NSPageLayout' => 'AppKit.NSPageLayout, Xamarin.Mac' */ },
		{ NULL, 0x13B316 /* #1808 'NSPasteboard' => 'AppKit.NSPasteboard, Xamarin.Mac' */ },
		{ NULL, 0x13B416 /* #1809 'NSPasteboardItem' => 'AppKit.NSPasteboardItem, Xamarin.Mac' */ },
		{ NULL, 0x13B716 /* #1810 'NSPasteboardItemDataProvider' => 'AppKit.NSPasteboardItemDataProvider, Xamarin.Mac' */ },
		{ NULL, 0x13BA16 /* #1811 'NSPasteboardReading' => 'AppKit.NSPasteboardReading, Xamarin.Mac' */ },
		{ NULL, 0x13C116 /* #1812 'NSPasteboardWriting' => 'AppKit.NSPasteboardWriting, Xamarin.Mac' */ },
		{ NULL, 0x13C816 /* #1813 'NSPathCellDelegate' => 'AppKit.NSPathCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13C916 /* #1814 'NSPathComponentCell' => 'AppKit.NSPathComponentCell, Xamarin.Mac' */ },
		{ NULL, 0x13CA16 /* #1815 'NSPathControl' => 'AppKit.NSPathControl, Xamarin.Mac' */ },
		{ NULL, 0x13CE16 /* #1816 'NSPathControlDelegate' => 'AppKit.NSPathControlDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13CF16 /* #1817 'NSPathControlItem' => 'AppKit.NSPathControlItem, Xamarin.Mac' */ },
		{ NULL, 0x13D016 /* #1818 'NSPDFImageRep' => 'AppKit.NSPdfImageRep, Xamarin.Mac' */ },
		{ NULL, 0x13D516 /* #1819 'NSPopoverDelegate' => 'AppKit.NSPopoverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13D616 /* #1820 'NSPopoverTouchBarItem' => 'AppKit.NSPopoverTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x13EC16 /* #1821 'NSRuleEditor' => 'AppKit.NSRuleEditor, Xamarin.Mac' */ },
		{ NULL, 0x13D916 /* #1822 'NSPredicateEditor' => 'AppKit.NSPredicateEditor, Xamarin.Mac' */ },
		{ NULL, 0x13DC16 /* #1823 'NSPressureConfiguration' => 'AppKit.NSPressureConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x13DD16 /* #1824 'NSPrinter' => 'AppKit.NSPrinter, Xamarin.Mac' */ },
		{ NULL, 0x13DE16 /* #1825 'NSPrintInfo' => 'AppKit.NSPrintInfo, Xamarin.Mac' */ },
		{ NULL, 0x13DF16 /* #1826 'NSPrintOperation' => 'AppKit.NSPrintOperation, Xamarin.Mac' */ },
		{ NULL, 0x13E016 /* #1827 'NSPrintPanel' => 'AppKit.NSPrintPanel, Xamarin.Mac' */ },
		{ NULL, 0x13E316 /* #1828 'NSPrintPanelAccessorizing' => 'AppKit.NSPrintPanelAccessorizing, Xamarin.Mac' */ },
		{ NULL, 0x13E416 /* #1829 'NSPrintPreviewGraphicsContext' => 'AppKit.NSPrintPreviewGraphicsContext, Xamarin.Mac' */ },
		{ NULL, 0x13E516 /* #1830 'NSProgressIndicator' => 'AppKit.NSProgressIndicator, Xamarin.Mac' */ },
		{ NULL, 0x13E716 /* #1831 'NSRemoteOpenPanel' => 'AppKit.NSRemoteOpenPanel, Xamarin.Mac' */ },
		{ NULL, 0x13E816 /* #1832 'NSRemoteSavePanel' => 'AppKit.NSRemoteSavePanel, Xamarin.Mac' */ },
		{ NULL, 0x13F016 /* #1833 'NSRuleEditorDelegate' => 'AppKit.NSRuleEditorDelegate, Xamarin.Mac' */ },
		{ NULL, 0x13F116 /* #1834 'NSRulerMarker' => 'AppKit.NSRulerMarker, Xamarin.Mac' */ },
		{ NULL, 0x13F316 /* #1835 'NSRulerView' => 'AppKit.NSRulerView, Xamarin.Mac' */ },
		{ NULL, 0x13F616 /* #1836 'NSRunningApplication' => 'AppKit.NSRunningApplication, Xamarin.Mac' */ },
		{ NULL, 0x13FE16 /* #1837 'NSScrubber' => 'AppKit.NSScrubber, Xamarin.Mac' */ },
		{ NULL, 0x13FF16 /* #1838 'NSScrubberArrangedView' => 'AppKit.NSScrubberArrangedView, Xamarin.Mac' */ },
		{ NULL, 0x140216 /* #1839 'NSScrubberDataSource' => 'AppKit.NSScrubberDataSource, Xamarin.Mac' */ },
		{ NULL, 0x140616 /* #1840 'NSScrubberDelegate' => 'AppKit.NSScrubberDelegate, Xamarin.Mac' */ },
		{ NULL, 0x140E16 /* #1841 'NSScrubberLayout' => 'AppKit.NSScrubberLayout, Xamarin.Mac' */ },
		{ NULL, 0x140716 /* #1842 'NSScrubberFlowLayout' => 'AppKit.NSScrubberFlowLayout, Xamarin.Mac' */ },
		{ NULL, 0x140B16 /* #1843 'NSScrubberFlowLayoutDelegate' => 'AppKit.NSScrubberFlowLayoutDelegate, Xamarin.Mac' */ },
		{ NULL, 0x140D16 /* #1844 'NSScrubberItemView' => 'AppKit.NSScrubberItemView, Xamarin.Mac' */ },
		{ NULL, 0x140C16 /* #1845 'NSScrubberImageItemView' => 'AppKit.NSScrubberImageItemView, Xamarin.Mac' */ },
		{ NULL, 0x140F16 /* #1846 'NSScrubberLayoutAttributes' => 'AppKit.NSScrubberLayoutAttributes, Xamarin.Mac' */ },
		{ NULL, 0x141016 /* #1847 'NSScrubberProportionalLayout' => 'AppKit.NSScrubberProportionalLayout, Xamarin.Mac' */ },
		{ NULL, 0x141116 /* #1848 'NSScrubberSelectionStyle' => 'AppKit.NSScrubberSelectionStyle, Xamarin.Mac' */ },
		{ NULL, 0x141216 /* #1849 'NSScrubberSelectionView' => 'AppKit.NSScrubberSelectionView, Xamarin.Mac' */ },
		{ NULL, 0x141316 /* #1850 'NSScrubberTextItemView' => 'AppKit.NSScrubberTextItemView, Xamarin.Mac' */ },
		{ NULL, 0x141516 /* #1851 'NSSearchFieldCell' => 'AppKit.NSSearchFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x141916 /* #1852 'NSSearchFieldDelegate' => 'AppKit.NSSearchFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x149A16 /* #1853 'NSTextField' => 'AppKit.NSTextField, Xamarin.Mac' */ },
		{ NULL, 0x141A16 /* #1854 'NSSecureTextField' => 'AppKit.NSSecureTextField, Xamarin.Mac' */ },
		{ NULL, 0x141B16 /* #1855 'NSSecureTextFieldCell' => 'AppKit.NSSecureTextFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x141D16 /* #1856 'NSSegmentedCell' => 'AppKit.NSSegmentedCell, Xamarin.Mac' */ },
		{ NULL, 0x141E16 /* #1857 'NSSegmentedControl' => 'AppKit.NSSegmentedControl, Xamarin.Mac' */ },
		{ NULL, 0x142216 /* #1858 'NSSeguePerforming' => 'AppKit.NSSeguePerforming, Xamarin.Mac' */ },
		{ NULL, 0x142616 /* #1859 'NSShadow' => 'AppKit.NSShadow, Xamarin.Mac' */ },
		{ NULL, 0x143516 /* #1860 'NSSharingServicePickerDelegate' => 'AppKit.NSSharingServicePickerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x143616 /* #1861 'NSSharingServicePickerTouchBarItem' => 'AppKit.NSSharingServicePickerTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x143916 /* #1862 'NSSharingServicePickerTouchBarItemDelegate' => 'AppKit.NSSharingServicePickerTouchBarItemDelegate, Xamarin.Mac' */ },
		{ NULL, 0x143A16 /* #1863 'NSSlider' => 'AppKit.NSSlider, Xamarin.Mac' */ },
		{ NULL, 0x143C16 /* #1864 'NSSliderAccessoryBehavior' => 'AppKit.NSSliderAccessoryBehavior, Xamarin.Mac' */ },
		{ NULL, 0x143D16 /* #1865 'NSSliderCell' => 'AppKit.NSSliderCell, Xamarin.Mac' */ },
		{ NULL, 0x143E16 /* #1866 'NSSliderTouchBarItem' => 'AppKit.NSSliderTouchBarItem, Xamarin.Mac' */ },
		{ NULL, 0x144416 /* #1867 'NSSoundDelegate' => 'AppKit.NSSoundDelegate, Xamarin.Mac' */ },
		{ NULL, 0x144516 /* #1868 'NSSpeechRecognizer' => 'AppKit.NSSpeechRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x144916 /* #1869 'NSSpeechRecognizerDelegate' => 'AppKit.NSSpeechRecognizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x144A16 /* #1870 'NSSpeechSynthesizer' => 'AppKit.NSSpeechSynthesizer, Xamarin.Mac' */ },
		{ NULL, 0x144E16 /* #1871 'NSSpeechSynthesizerDelegate' => 'AppKit.NSSpeechSynthesizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x145216 /* #1872 'NSSplitViewController' => 'AppKit.NSSplitViewController, Xamarin.Mac' */ },
		{ NULL, 0x145616 /* #1873 'NSSplitViewDelegate' => 'AppKit.NSSplitViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x145716 /* #1874 'NSSplitViewItem' => 'AppKit.NSSplitViewItem, Xamarin.Mac' */ },
		{ NULL, 0x145B16 /* #1875 'NSSpringLoadingDestination' => 'AppKit.NSSpringLoadingDestination, Xamarin.Mac' */ },
		{ NULL, 0x145C16 /* #1876 'NSStackView' => 'AppKit.NSStackView, Xamarin.Mac' */ },
		{ NULL, 0x146016 /* #1877 'NSStackViewDelegate' => 'AppKit.NSStackViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x146516 /* #1878 'NSStatusBar' => 'AppKit.NSStatusBar, Xamarin.Mac' */ },
		{ NULL, 0x146616 /* #1879 'NSStatusBarButton' => 'AppKit.NSStatusBarButton, Xamarin.Mac' */ },
		{ NULL, 0x146716 /* #1880 'NSStatusItem' => 'AppKit.NSStatusItem, Xamarin.Mac' */ },
		{ NULL, 0x146816 /* #1881 'NSStepper' => 'AppKit.NSStepper, Xamarin.Mac' */ },
		{ NULL, 0x146916 /* #1882 'NSStepperCell' => 'AppKit.NSStepperCell, Xamarin.Mac' */ },
		{ NULL, 0x146A16 /* #1883 'NSStoryboard' => 'AppKit.NSStoryboard, Xamarin.Mac' */ },
		{ NULL, 0x146B16 /* #1884 'NSStoryboardSegue' => 'AppKit.NSStoryboardSegue, Xamarin.Mac' */ },
		{ NULL, 0x146F16 /* #1885 'NSStringDrawingContext' => 'AppKit.NSStringDrawingContext, Xamarin.Mac' */ },
		{ NULL, 0x147016 /* #1886 'NSTableCellView' => 'AppKit.NSTableCellView, Xamarin.Mac' */ },
		{ NULL, 0x147116 /* #1887 'NSTableColumn' => 'AppKit.NSTableColumn, Xamarin.Mac' */ },
		{ NULL, 0x147216 /* #1888 'NSTableHeaderCell' => 'AppKit.NSTableHeaderCell, Xamarin.Mac' */ },
		{ NULL, 0x147316 /* #1889 'NSTableHeaderView' => 'AppKit.NSTableHeaderView, Xamarin.Mac' */ },
		{ NULL, 0x147416 /* #1890 'NSTableRowView' => 'AppKit.NSTableRowView, Xamarin.Mac' */ },
		{ NULL, 0x147C16 /* #1891 'NSTableViewDataSource' => 'AppKit.NSTableViewDataSource, Xamarin.Mac' */ },
		{ NULL, 0x148016 /* #1892 'NSTableViewDelegate' => 'AppKit.NSTableViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x148116 /* #1893 'NSTableViewRowAction' => 'AppKit.NSTableViewRowAction, Xamarin.Mac' */ },
		{ NULL, 0x148216 /* #1894 'NSTableViewSource' => 'AppKit.NSTableViewSource, Xamarin.Mac' */ },
		{ NULL, 0x148516 /* #1895 'NSTabViewController' => 'AppKit.NSTabViewController, Xamarin.Mac' */ },
		{ NULL, 0x148916 /* #1896 'NSTabViewDelegate' => 'AppKit.NSTabViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x148A16 /* #1897 'NSTabViewItem' => 'AppKit.NSTabViewItem, Xamarin.Mac' */ },
		{ NULL, 0x148D16 /* #1898 'NSTextAttachment' => 'AppKit.NSTextAttachment, Xamarin.Mac' */ },
		{ NULL, 0x148E16 /* #1899 'NSTextAttachmentCell' => 'AppKit.NSTextAttachmentCell, Xamarin.Mac' */ },
		{ NULL, 0x149116 /* #1900 'NSTextAttachmentContainer' => 'AppKit.NSTextAttachmentContainer, Xamarin.Mac' */ },
		{ NULL, 0x149216 /* #1901 'NSTextBlock' => 'AppKit.NSTextBlock, Xamarin.Mac' */ },
		{ NULL, 0x149516 /* #1902 'NSTextContainer' => 'AppKit.NSTextContainer, Xamarin.Mac' */ },
		{ NULL, 0x149916 /* #1903 'NSTextDelegate' => 'AppKit.NSTextDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14A216 /* #1904 'NSTextFinder' => 'AppKit.NSTextFinder, Xamarin.Mac' */ },
		{ NULL, 0x14A616 /* #1905 'NSTextFinderBarContainer' => 'AppKit.NSTextFinderBarContainer, Xamarin.Mac' */ },
		{ NULL, 0x14A916 /* #1906 'NSTextFinderClient' => 'AppKit.NSTextFinderClient, Xamarin.Mac' */ },
		{ NULL, 0x14B016 /* #1907 'NSTextInputClient' => 'AppKit.NSTextInputClient, Xamarin.Mac' */ },
		{ NULL, 0x14B216 /* #1908 'NSTextList' => 'AppKit.NSTextList, Xamarin.Mac' */ },
		{ NULL, 0x14BA16 /* #1909 'NSTextStorageDelegate' => 'AppKit.NSTextStorageDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14BB16 /* #1910 'NSTextTab' => 'AppKit.NSTextTab, Xamarin.Mac' */ },
		{ NULL, 0x14BC16 /* #1911 'NSTextTable' => 'AppKit.NSTextTable, Xamarin.Mac' */ },
		{ NULL, 0x14BD16 /* #1912 'NSTextTableBlock' => 'AppKit.NSTextTableBlock, Xamarin.Mac' */ },
		{ NULL, 0x14C616 /* #1913 'NSTextViewDelegate' => 'AppKit.NSTextViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14C716 /* #1914 'NSTitlebarAccessoryViewController' => 'AppKit.NSTitlebarAccessoryViewController, Xamarin.Mac' */ },
		{ NULL, 0x14C816 /* #1915 'NSTokenField' => 'AppKit.NSTokenField, Xamarin.Mac' */ },
		{ NULL, 0x14C916 /* #1916 'NSTokenFieldCell' => 'AppKit.NSTokenFieldCell, Xamarin.Mac' */ },
		{ NULL, 0x14CD16 /* #1917 'NSTokenFieldCellDelegate' => 'AppKit.NSTokenFieldCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14D116 /* #1918 'NSTokenFieldDelegate' => 'AppKit.NSTokenFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14D616 /* #1919 'NSToolbarDelegate' => 'AppKit.NSToolbarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14D716 /* #1920 'NSToolbarItem' => 'AppKit.NSToolbarItem, Xamarin.Mac' */ },
		{ NULL, 0x14D816 /* #1921 'NSToolbarItemGroup' => 'AppKit.NSToolbarItemGroup, Xamarin.Mac' */ },
		{ NULL, 0x14DD16 /* #1922 'NSTouch' => 'AppKit.NSTouch, Xamarin.Mac' */ },
		{ NULL, 0x14E316 /* #1923 'NSTouchBarDelegate' => 'AppKit.NSTouchBarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x14E916 /* #1924 'NSTrackingArea' => 'AppKit.NSTrackingArea, Xamarin.Mac' */ },
		{ NULL, 0x14EA16 /* #1925 'NSTreeController' => 'AppKit.NSTreeController, Xamarin.Mac' */ },
		{ NULL, 0x14EB16 /* #1926 'NSTreeNode' => 'AppKit.NSTreeNode, Xamarin.Mac' */ },
		{ NULL, 0x14ED16 /* #1927 'NSUserDefaultsController' => 'AppKit.NSUserDefaultsController, Xamarin.Mac' */ },
		{ NULL, 0x14F016 /* #1928 'NSUserInterfaceCompressionOptions' => 'AppKit.NSUserInterfaceCompressionOptions, Xamarin.Mac' */ },
		{ NULL, 0x129116 /* #1929 'NSAnimation' => 'AppKit.NSAnimation, Xamarin.Mac' */ },
		{ NULL, 0x14FB16 /* #1930 'NSViewAnimation' => 'AppKit.NSViewAnimation, Xamarin.Mac' */ },
		{ NULL, 0x14FF16 /* #1931 'NSViewControllerPresentationAnimator' => 'AppKit.NSViewControllerPresentationAnimator, Xamarin.Mac' */ },
		{ NULL, 0x150216 /* #1932 'NSVisualEffectView' => 'AppKit.NSVisualEffectView, Xamarin.Mac' */ },
		{ NULL, 0x150A16 /* #1933 'NSWindowDelegate' => 'AppKit.NSWindowDelegate, Xamarin.Mac' */ },
		{ NULL, 0x150D16 /* #1934 'NSWindowRestoration' => 'AppKit.NSWindowRestoration, Xamarin.Mac' */ },
		{ NULL, 0x150E16 /* #1935 'NSWindowTab' => 'AppKit.NSWindowTab, Xamarin.Mac' */ },
		{ NULL, 0x150F16 /* #1936 'NSWindowTabGroup' => 'AppKit.NSWindowTabGroup, Xamarin.Mac' */ },
		{ NULL, 0x151216 /* #1937 'NSWorkspaceAuthorization' => 'AppKit.NSWorkspaceAuthorization, Xamarin.Mac' */ },
		{ NULL, 0x15AF16 /* #1938 '__monomac_internal_ActionDispatcher' => 'AppKit.ActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x15B516 /* #1939 '__MonoMac_NSAlertDidEndDispatcher' => 'AppKit.NSAlertDidEndDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x16C816 /* #1940 'ASIdentifierManager' => 'AdSupport.ASIdentifierManager, Xamarin.Mac' */ },
		{ NULL, 0x16C916 /* #1941 'ACAccount' => 'Accounts.ACAccount, Xamarin.Mac' */ },
		{ NULL, 0x16CA16 /* #1942 'ACAccountCredential' => 'Accounts.ACAccountCredential, Xamarin.Mac' */ },
		{ NULL, 0x16CD16 /* #1943 'ACAccountType' => 'Accounts.ACAccountType, Xamarin.Mac' */ },
		{ NULL, 0x16E216 /* #1944 'NSAffineTransform' => 'Foundation.NSAffineTransform, Xamarin.Mac' */ },
		{ NULL, 0x16E316 /* #1945 'NSAppleEventDescriptor' => 'Foundation.NSAppleEventDescriptor, Xamarin.Mac' */ },
		{ NULL, 0x16E416 /* #1946 'NSAppleEventManager' => 'Foundation.NSAppleEventManager, Xamarin.Mac' */ },
		{ NULL, 0x16E516 /* #1947 'NSAppleScript' => 'Foundation.NSAppleScript, Xamarin.Mac' */ },
		{ NULL, 0x16E716 /* #1948 'NSAttributedString' => 'Foundation.NSAttributedString, Xamarin.Mac' */ },
		{ NULL, 0x16E816 /* #1949 'NSBindingSelectionMarker' => 'Foundation.NSBindingSelectionMarker, Xamarin.Mac' */ },
		{ NULL, 0x16E916 /* #1950 'NSBlockOperation' => 'Foundation.NSBlockOperation, Xamarin.Mac' */ },
		{ NULL, 0x16EA16 /* #1951 'NSBundle' => 'Foundation.NSBundle, Xamarin.Mac' */ },
		{ NULL, 0x16EB16 /* #1952 'NSByteCountFormatter' => 'Foundation.NSByteCountFormatter, Xamarin.Mac' */ },
		{ NULL, 0x16F116 /* #1953 'NSCacheDelegate' => 'Foundation.NSCacheDelegate, Xamarin.Mac' */ },
		{ NULL, 0x16F216 /* #1954 'NSCachedURLResponse' => 'Foundation.NSCachedUrlResponse, Xamarin.Mac' */ },
		{ NULL, 0x170816 /* #1955 'NSDate' => 'Foundation.NSDate, Xamarin.Mac' */ },
		{ NULL, 0x16F416 /* #1956 'NSCalendarDate' => 'Foundation.NSCalendarDate, Xamarin.Mac' */ },
		{ NULL, 0x16F516 /* #1957 'NSCharacterSet' => 'Foundation.NSCharacterSet, Xamarin.Mac' */ },
		{ NULL, 0x16F616 /* #1958 'NSCoder' => 'Foundation.NSCoder, Xamarin.Mac' */ },
		{ NULL, 0x16F916 /* #1959 'NSCoding' => 'Foundation.NSCoding, Xamarin.Mac' */ },
		{ NULL, 0x17A616 /* #1960 'NSPredicate' => 'Foundation.NSPredicate, Xamarin.Mac' */ },
		{ NULL, 0x16FA16 /* #1961 'NSComparisonPredicate' => 'Foundation.NSComparisonPredicate, Xamarin.Mac' */ },
		{ NULL, 0x16FB16 /* #1962 'NSCompoundPredicate' => 'Foundation.NSCompoundPredicate, Xamarin.Mac' */ },
		{ NULL, 0x16FC16 /* #1963 'NSCondition' => 'Foundation.NSCondition, Xamarin.Mac' */ },
		{ NULL, 0x16FD16 /* #1964 'NSConditionLock' => 'Foundation.NSConditionLock, Xamarin.Mac' */ },
		{ NULL, 0x16FE16 /* #1965 'NSConnection' => 'Foundation.NSConnection, Xamarin.Mac' */ },
		{ NULL, 0x170216 /* #1966 'NSConnectionDelegate' => 'Foundation.NSConnectionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x170516 /* #1967 'NSCopying' => 'Foundation.NSCopying, Xamarin.Mac' */ },
		{ NULL, 0x17B616 /* #1968 'NSRegularExpression' => 'Foundation.NSRegularExpression, Xamarin.Mac' */ },
		{ NULL, 0x170716 /* #1969 'NSDataDetector' => 'Foundation.NSDataDetector, Xamarin.Mac' */ },
		{ NULL, 0x170916 /* #1970 'NSDateComponents' => 'Foundation.NSDateComponents, Xamarin.Mac' */ },
		{ NULL, 0x170A16 /* #1971 'NSDateComponentsFormatter' => 'Foundation.NSDateComponentsFormatter, Xamarin.Mac' */ },
		{ NULL, 0x170B16 /* #1972 'NSDateFormatter' => 'Foundation.NSDateFormatter, Xamarin.Mac' */ },
		{ NULL, 0x170C16 /* #1973 'NSDateInterval' => 'Foundation.NSDateInterval, Xamarin.Mac' */ },
		{ NULL, 0x170D16 /* #1974 'NSDateIntervalFormatter' => 'Foundation.NSDateIntervalFormatter, Xamarin.Mac' */ },
		{ NULL, 0x184C16 /* #1975 'NSValue' => 'Foundation.NSValue, Xamarin.Mac' */ },
		{ NULL, 0x179016 /* #1976 'NSNumber' => 'Foundation.NSNumber, Xamarin.Mac' */ },
		{ NULL, 0x170E16 /* #1977 'NSDecimalNumber' => 'Foundation.NSDecimalNumber, Xamarin.Mac' */ },
		{ NULL, 0x17D716 /* #1978 'NSUnit' => 'Foundation.NSUnit, Xamarin.Mac' */ },
		{ NULL, 0x171016 /* #1979 'NSDimension' => 'Foundation.NSDimension, Xamarin.Mac' */ },
		{ NULL, 0x171816 /* #1980 'NSEnumerator' => 'Foundation.NSEnumerator, Xamarin.Mac' */ },
		{ NULL, 0x171116 /* #1981 'NSDirectoryEnumerator' => 'Foundation.NSDirectoryEnumerator, Xamarin.Mac' */ },
		{ NULL, 0x171416 /* #1982 'NSDistantObjectRequest' => 'Foundation.NSDistantObjectRequest, Xamarin.Mac' */ },
		{ NULL, 0x171516 /* #1983 'NSDistributedLock' => 'Foundation.NSDistributedLock, Xamarin.Mac' */ },
		{ NULL, 0x178D16 /* #1984 'NSNotificationCenter' => 'Foundation.NSNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x171616 /* #1985 'NSDistributedNotificationCenter' => 'Foundation.NSDistributedNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x171716 /* #1986 'NSEnergyFormatter' => 'Foundation.NSEnergyFormatter, Xamarin.Mac' */ },
		{ NULL, 0x171916 /* #1987 'NSError' => 'Foundation.NSError, Xamarin.Mac' */ },
		{ NULL, 0x171A16 /* #1988 'NSException' => 'Foundation.NSException, Xamarin.Mac' */ },
		{ NULL, 0x171D16 /* #1989 'NSExtensionItem' => 'Foundation.NSExtensionItem, Xamarin.Mac' */ },
		{ NULL, 0x172016 /* #1990 'NSExtensionRequestHandling' => 'Foundation.NSExtensionRequestHandling, Xamarin.Mac' */ },
		{ NULL, 0x172116 /* #1991 'NSFileAccessIntent' => 'Foundation.NSFileAccessIntent, Xamarin.Mac' */ },
		{ NULL, 0x172216 /* #1992 'NSFileCoordinator' => 'Foundation.NSFileCoordinator, Xamarin.Mac' */ },
		{ NULL, 0x172916 /* #1993 'NSFileManagerDelegate' => 'Foundation.NSFileManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x172D16 /* #1994 'NSFilePresenter' => 'Foundation.NSFilePresenter, Xamarin.Mac' */ },
		{ NULL, 0x172E16 /* #1995 'NSFileProviderService' => 'Foundation.NSFileProviderService, Xamarin.Mac' */ },
		{ NULL, 0x173016 /* #1996 'NSFileWrapper' => 'Foundation.NSFileWrapper, Xamarin.Mac' */ },
		{ NULL, 0x173316 /* #1997 'NSHTTPCookie' => 'Foundation.NSHttpCookie, Xamarin.Mac' */ },
		{ NULL, 0x181316 /* #1998 'NSURLResponse' => 'Foundation.NSUrlResponse, Xamarin.Mac' */ },
		{ NULL, 0x173516 /* #1999 'NSHTTPURLResponse' => 'Foundation.NSHttpUrlResponse, Xamarin.Mac' */ },
		{ NULL, 0x17C416 /* #2000 'NSStream' => 'Foundation.NSStream, Xamarin.Mac' */ },
		{ NULL, 0x173816 /* #2001 'NSInputStream' => 'Foundation.NSInputStream, Xamarin.Mac' */ },
		{ NULL, 0x173916 /* #2002 'NSInvocation' => 'Foundation.NSInvocation, Xamarin.Mac' */ },
		{ NULL, 0x173A16 /* #2003 'NSISO8601DateFormatter' => 'Foundation.NSIso8601DateFormatter, Xamarin.Mac' */ },
		{ NULL, 0x174516 /* #2004 'NSJSONSerialization' => 'Foundation.NSJsonSerialization, Xamarin.Mac' */ },
		{ NULL, 0x174B16 /* #2005 'NSKeyedArchiverDelegate' => 'Foundation.NSKeyedArchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x175016 /* #2006 'NSKeyedUnarchiverDelegate' => 'Foundation.NSKeyedUnarchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x175316 /* #2007 'NSLengthFormatter' => 'Foundation.NSLengthFormatter, Xamarin.Mac' */ },
		{ NULL, 0x175616 /* #2008 'NSLinguisticTagger' => 'Foundation.NSLinguisticTagger, Xamarin.Mac' */ },
		{ NULL, 0x175C16 /* #2009 'NSLock' => 'Foundation.NSLock, Xamarin.Mac' */ },
		{ NULL, 0x179F16 /* #2010 'NSPort' => 'Foundation.NSPort, Xamarin.Mac' */ },
		{ NULL, 0x175F16 /* #2011 'NSMachPort' => 'Foundation.NSMachPort, Xamarin.Mac' */ },
		{ NULL, 0x17A316 /* #2012 'NSPortDelegate' => 'Foundation.NSPortDelegate, Xamarin.Mac' */ },
		{ NULL, 0x176316 /* #2013 'NSMachPortDelegate' => 'Foundation.NSMachPortDelegate, Xamarin.Mac' */ },
		{ NULL, 0x176416 /* #2014 'NSMassFormatter' => 'Foundation.NSMassFormatter, Xamarin.Mac' */ },
		{ NULL, 0x176516 /* #2015 'NSMeasurement' => 'Foundation.NSMeasurement`1, Xamarin.Mac' */ },
		{ NULL, 0x176616 /* #2016 'NSMeasurementFormatter' => 'Foundation.NSMeasurementFormatter, Xamarin.Mac' */ },
		{ NULL, 0x176716 /* #2017 'NSMetadataItem' => 'Foundation.NSMetadataItem, Xamarin.Mac' */ },
		{ NULL, 0x176916 /* #2018 'NSMetadataQueryAttributeValueTuple' => 'Foundation.NSMetadataQueryAttributeValueTuple, Xamarin.Mac' */ },
		{ NULL, 0x176D16 /* #2019 'NSMetadataQueryDelegate' => 'Foundation.NSMetadataQueryDelegate, Xamarin.Mac' */ },
		{ NULL, 0x176E16 /* #2020 'NSMetadataQueryResultGroup' => 'Foundation.NSMetadataQueryResultGroup, Xamarin.Mac' */ },
		{ NULL, 0x176F16 /* #2021 'NSMethodSignature' => 'Foundation.NSMethodSignature, Xamarin.Mac' */ },
		{ NULL, 0x177116 /* #2022 'NSMutableAttributedString' => 'Foundation.NSMutableAttributedString, Xamarin.Mac' */ },
		{ NULL, 0x177216 /* #2023 'NSMutableCharacterSet' => 'Foundation.NSMutableCharacterSet, Xamarin.Mac' */ },
		{ NULL, 0x177516 /* #2024 'NSMutableCopying' => 'Foundation.NSMutableCopying, Xamarin.Mac' */ },
		{ NULL, 0x173716 /* #2025 'NSIndexSet' => 'Foundation.NSIndexSet, Xamarin.Mac' */ },
		{ NULL, 0x177816 /* #2026 'NSMutableIndexSet' => 'Foundation.NSMutableIndexSet, Xamarin.Mac' */ },
		{ NULL, 0x179816 /* #2027 'NSOrderedSet' => 'Foundation.NSOrderedSet, Xamarin.Mac' */ },
		{ NULL, 0x177916 /* #2028 'NSMutableOrderedSet' => 'Foundation.NSMutableOrderedSet, Xamarin.Mac' */ },
		{ NULL, 0x17C116 /* #2029 'NSSet' => 'Foundation.NSSet, Xamarin.Mac' */ },
		{ NULL, 0x177A16 /* #2030 'NSMutableSet' => 'Foundation.NSMutableSet, Xamarin.Mac' */ },
		{ NULL, 0x177B16 /* #2031 'NSMutableString' => 'Foundation.NSMutableString, Xamarin.Mac' */ },
		{ NULL, 0x181216 /* #2032 'NSURLRequest' => 'Foundation.NSUrlRequest, Xamarin.Mac' */ },
		{ NULL, 0x177C16 /* #2033 'NSMutableURLRequest' => 'Foundation.NSMutableUrlRequest, Xamarin.Mac' */ },
		{ NULL, 0x178716 /* #2034 'NSNetServiceBrowserDelegate' => 'Foundation.NSNetServiceBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x178B16 /* #2035 'NSNetServiceDelegate' => 'Foundation.NSNetServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x178C16 /* #2036 'NSNotification' => 'Foundation.NSNotification, Xamarin.Mac' */ },
		{ NULL, 0x178E16 /* #2037 'NSNotificationQueue' => 'Foundation.NSNotificationQueue, Xamarin.Mac' */ },
		{ NULL, 0x178F16 /* #2038 'NSNull' => 'Foundation.NSNull, Xamarin.Mac' */ },
		{ NULL, 0x179116 /* #2039 'NSNumberFormatter' => 'Foundation.NSNumberFormatter, Xamarin.Mac' */ },
		{ NULL, 0x179716 /* #2040 'NSOperationQueue' => 'Foundation.NSOperationQueue, Xamarin.Mac' */ },
		{ NULL, 0x179916 /* #2041 'NSOrthography' => 'Foundation.NSOrthography, Xamarin.Mac' */ },
		{ NULL, 0x179A16 /* #2042 'NSOutputStream' => 'Foundation.NSOutputStream, Xamarin.Mac' */ },
		{ NULL, 0x179C16 /* #2043 'NSPersonNameComponents' => 'Foundation.NSPersonNameComponents, Xamarin.Mac' */ },
		{ NULL, 0x179D16 /* #2044 'NSPersonNameComponentsFormatter' => 'Foundation.NSPersonNameComponentsFormatter, Xamarin.Mac' */ },
		{ NULL, 0x179E16 /* #2045 'NSPipe' => 'Foundation.NSPipe, Xamarin.Mac' */ },
		{ NULL, 0x17A416 /* #2046 'NSPortMessage' => 'Foundation.NSPortMessage, Xamarin.Mac' */ },
		{ NULL, 0x17A516 /* #2047 'NSPortNameServer' => 'Foundation.NSPortNameServer, Xamarin.Mac' */ },
		{ NULL, 0x17B316 /* #2048 'NSPropertyListSerialization' => 'Foundation.NSPropertyListSerialization, Xamarin.Mac' */ },
		{ NULL, 0x170616 /* #2049 'NSData' => 'Foundation.NSData, Xamarin.Mac' */ },
		{ NULL, 0x177616 /* #2050 'NSMutableData' => 'Foundation.NSMutableData, Xamarin.Mac' */ },
		{ NULL, 0x17B416 /* #2051 'NSPurgeableData' => 'Foundation.NSPurgeableData, Xamarin.Mac' */ },
		{ NULL, 0x17B516 /* #2052 'NSRecursiveLock' => 'Foundation.NSRecursiveLock, Xamarin.Mac' */ },
		{ NULL, 0x17B716 /* #2053 'NSRunLoop' => 'Foundation.NSRunLoop, Xamarin.Mac' */ },
		{ NULL, 0x17BA16 /* #2054 'NSScriptCommand' => 'Foundation.NSScriptCommand, Xamarin.Mac' */ },
		{ NULL, 0x17BC16 /* #2055 'NSScriptCommandDescription' => 'Foundation.NSScriptCommandDescription, Xamarin.Mac' */ },
		{ NULL, 0x17C916 /* #2056 'NSStreamDelegate' => 'Foundation.NSStreamDelegate, Xamarin.Mac' */ },
		{ NULL, 0x17D016 /* #2057 'NSTextCheckingResult' => 'Foundation.NSTextCheckingResult, Xamarin.Mac' */ },
		{ NULL, 0x17D316 /* #2058 'NSTimer' => 'Foundation.NSTimer, Xamarin.Mac' */ },
		{ NULL, 0x17D416 /* #2059 'NSTimeZone' => 'Foundation.NSTimeZone, Xamarin.Mac' */ },
		{ NULL, 0x17D816 /* #2060 'NSUnitAcceleration' => 'Foundation.NSUnitAcceleration, Xamarin.Mac' */ },
		{ NULL, 0x17D916 /* #2061 'NSUnitAngle' => 'Foundation.NSUnitAngle, Xamarin.Mac' */ },
		{ NULL, 0x17DA16 /* #2062 'NSUnitArea' => 'Foundation.NSUnitArea, Xamarin.Mac' */ },
		{ NULL, 0x17DB16 /* #2063 'NSUnitConcentrationMass' => 'Foundation.NSUnitConcentrationMass, Xamarin.Mac' */ },
		{ NULL, 0x17DC16 /* #2064 'NSUnitConverter' => 'Foundation.NSUnitConverter, Xamarin.Mac' */ },
		{ NULL, 0x17DD16 /* #2065 'NSUnitConverterLinear' => 'Foundation.NSUnitConverterLinear, Xamarin.Mac' */ },
		{ NULL, 0x17DE16 /* #2066 'NSUnitDispersion' => 'Foundation.NSUnitDispersion, Xamarin.Mac' */ },
		{ NULL, 0x17DF16 /* #2067 'NSUnitDuration' => 'Foundation.NSUnitDuration, Xamarin.Mac' */ },
		{ NULL, 0x17E016 /* #2068 'NSUnitElectricCharge' => 'Foundation.NSUnitElectricCharge, Xamarin.Mac' */ },
		{ NULL, 0x17E116 /* #2069 'NSUnitElectricCurrent' => 'Foundation.NSUnitElectricCurrent, Xamarin.Mac' */ },
		{ NULL, 0x17E216 /* #2070 'NSUnitElectricPotentialDifference' => 'Foundation.NSUnitElectricPotentialDifference, Xamarin.Mac' */ },
		{ NULL, 0x17E316 /* #2071 'NSUnitElectricResistance' => 'Foundation.NSUnitElectricResistance, Xamarin.Mac' */ },
		{ NULL, 0x17E416 /* #2072 'NSUnitEnergy' => 'Foundation.NSUnitEnergy, Xamarin.Mac' */ },
		{ NULL, 0x17E516 /* #2073 'NSUnitFrequency' => 'Foundation.NSUnitFrequency, Xamarin.Mac' */ },
		{ NULL, 0x17E616 /* #2074 'NSUnitFuelEfficiency' => 'Foundation.NSUnitFuelEfficiency, Xamarin.Mac' */ },
		{ NULL, 0x17E716 /* #2075 'NSUnitIlluminance' => 'Foundation.NSUnitIlluminance, Xamarin.Mac' */ },
		{ NULL, 0x17E816 /* #2076 'NSUnitLength' => 'Foundation.NSUnitLength, Xamarin.Mac' */ },
		{ NULL, 0x17E916 /* #2077 'NSUnitMass' => 'Foundation.NSUnitMass, Xamarin.Mac' */ },
		{ NULL, 0x17EA16 /* #2078 'NSUnitPower' => 'Foundation.NSUnitPower, Xamarin.Mac' */ },
		{ NULL, 0x17EB16 /* #2079 'NSUnitPressure' => 'Foundation.NSUnitPressure, Xamarin.Mac' */ },
		{ NULL, 0x17EC16 /* #2080 'NSUnitSpeed' => 'Foundation.NSUnitSpeed, Xamarin.Mac' */ },
		{ NULL, 0x17ED16 /* #2081 'NSUnitTemperature' => 'Foundation.NSUnitTemperature, Xamarin.Mac' */ },
		{ NULL, 0x17EE16 /* #2082 'NSUnitVolume' => 'Foundation.NSUnitVolume, Xamarin.Mac' */ },
		{ NULL, 0x17F116 /* #2083 'NSURLAuthenticationChallenge' => 'Foundation.NSUrlAuthenticationChallenge, Xamarin.Mac' */ },
		{ NULL, 0x17F516 /* #2084 'NSURLAuthenticationChallengeSender' => 'Foundation.NSURLAuthenticationChallengeSender, Xamarin.Mac' */ },
		{ NULL, 0x17F716 /* #2085 'NSURLComponents' => 'Foundation.NSUrlComponents, Xamarin.Mac' */ },
		{ NULL, 0x180116 /* #2086 'NSURLConnectionDelegate' => 'Foundation.NSUrlConnectionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x17FD16 /* #2087 'NSURLConnectionDataDelegate' => 'Foundation.NSUrlConnectionDataDelegate, Xamarin.Mac' */ },
		{ NULL, 0x180516 /* #2088 'NSURLConnectionDownloadDelegate' => 'Foundation.NSUrlConnectionDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x180616 /* #2089 'NSURLCredential' => 'Foundation.NSUrlCredential, Xamarin.Mac' */ },
		{ NULL, 0x180C16 /* #2090 'NSUrlDownloadDelegate' => 'Foundation.NSUrlDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x180D16 /* #2091 'NSURLProtectionSpace' => 'Foundation.NSUrlProtectionSpace, Xamarin.Mac' */ },
		{ NULL, 0x180E16 /* #2092 'NSURLProtocol' => 'Foundation.NSUrlProtocol, Xamarin.Mac' */ },
		{ NULL, 0x181116 /* #2093 'NSURLQueryItem' => 'Foundation.NSUrlQueryItem, Xamarin.Mac' */ },
		{ NULL, 0x181A16 /* #2094 'NSURLSessionConfiguration' => 'Foundation.NSUrlSessionConfiguration, Xamarin.Mac' */ },
		{ NULL, 0x182316 /* #2095 'NSURLSessionDelegate' => 'Foundation.NSUrlSessionDelegate, Xamarin.Mac' */ },
		{ NULL, 0x183316 /* #2096 'NSURLSessionTaskDelegate' => 'Foundation.NSUrlSessionTaskDelegate, Xamarin.Mac' */ },
		{ NULL, 0x181E16 /* #2097 'NSURLSessionDataDelegate' => 'Foundation.NSUrlSessionDataDelegate, Xamarin.Mac' */ },
		{ NULL, 0x182F16 /* #2098 'NSURLSessionTask' => 'Foundation.NSUrlSessionTask, Xamarin.Mac' */ },
		{ NULL, 0x181F16 /* #2099 'NSURLSessionDataTask' => 'Foundation.NSUrlSessionDataTask, Xamarin.Mac' */ },
		{ NULL, 0x182716 /* #2100 'NSURLSessionDownloadDelegate' => 'Foundation.NSUrlSessionDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x182816 /* #2101 'NSURLSessionDownloadTask' => 'Foundation.NSUrlSessionDownloadTask, Xamarin.Mac' */ },
		{ NULL, 0x182C16 /* #2102 'NSURLSessionStreamDelegate' => 'Foundation.NSUrlSessionStreamDelegate, Xamarin.Mac' */ },
		{ NULL, 0x183416 /* #2103 'NSURLSessionTaskMetrics' => 'Foundation.NSUrlSessionTaskMetrics, Xamarin.Mac' */ },
		{ NULL, 0x183616 /* #2104 'NSURLSessionTaskTransactionMetrics' => 'Foundation.NSUrlSessionTaskTransactionMetrics, Xamarin.Mac' */ },
		{ NULL, 0x183716 /* #2105 'NSURLSessionUploadTask' => 'Foundation.NSUrlSessionUploadTask, Xamarin.Mac' */ },
		{ NULL, 0x183F16 /* #2106 'NSUserActivityDelegate' => 'Foundation.NSUserActivityDelegate, Xamarin.Mac' */ },
		{ NULL, 0x184216 /* #2107 'NSUserNotification' => 'Foundation.NSUserNotification, Xamarin.Mac' */ },
		{ NULL, 0x184316 /* #2108 'NSUserNotificationAction' => 'Foundation.NSUserNotificationAction, Xamarin.Mac' */ },
		{ NULL, 0x184A16 /* #2109 'NSUserNotificationCenterDelegate' => 'Foundation.NSUserNotificationCenterDelegate, Xamarin.Mac' */ },
		{ NULL, 0x184B16 /* #2110 'NSUUID' => 'Foundation.NSUuid, Xamarin.Mac' */ },
		{ NULL, 0x184D16 /* #2111 'NSValueTransformer' => 'Foundation.NSValueTransformer, Xamarin.Mac' */ },
		{ NULL, 0x184E16 /* #2112 'NSXPCListenerEndpoint' => 'Foundation.NSXpcListenerEndpoint, Xamarin.Mac' */ },
		{ NULL, 0x188F16 /* #2113 'Foundation_InternalNSNotificationHandler' => 'Foundation.InternalNSNotificationHandler, Xamarin.Mac' */ },
		{ NULL, 0x189216 /* #2114 'NSProxy' => 'Foundation.NSProxy, Xamarin.Mac' */ },
		{ NULL, 0x189C16 /* #2115 'Foundation_NSUrlProtocolClient' => 'Foundation.NSUrlProtocolClient, Xamarin.Mac' */ },
		{ NULL, 0x191B16 /* #2116 'Foundation_NSDispatcher' => 'Foundation.NSDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x191C16 /* #2117 '__MonoMac_NSActionDispatcher' => 'Foundation.NSActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x191D16 /* #2118 '__MonoMac_NSSynchronizationContextDispatcher' => 'Foundation.NSSynchronizationContextDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x191E16 /* #2119 '__Xamarin_NSTimerActionDispatcher' => 'Foundation.NSTimerActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x191F16 /* #2120 'Foundation_NSAsyncDispatcher' => 'Foundation.NSAsyncDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x192016 /* #2121 '__MonoMac_NSAsyncActionDispatcher' => 'Foundation.NSAsyncActionDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x192116 /* #2122 '__MonoMac_NSAsyncSynchronizationContextDispatcher' => 'Foundation.NSAsyncSynchronizationContextDispatcher, Xamarin.Mac' */ },
		{ NULL, 0x192216 /* #2123 'NSAutoreleasePool' => 'Foundation.NSAutoreleasePool, Xamarin.Mac' */ },
		{ NULL, 0x15016 /* #2124 'UNUserNotificationCenter' => 'UserNotifications.UNUserNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x1EF16 /* #2125 'WebHistoryItem' => 'WebKit.WebHistoryItem, Xamarin.Mac' */ },
		{ NULL, 0x20716 /* #2126 'WebView' => 'WebKit.WebView, Xamarin.Mac' */ },
		{ NULL, 0x22F16 /* #2127 'WKContentRuleListStore' => 'WebKit.WKContentRuleListStore, Xamarin.Mac' */ },
		{ NULL, 0x23316 /* #2128 'WKHTTPCookieStore' => 'WebKit.WKHttpCookieStore, Xamarin.Mac' */ },
		{ NULL, 0x25716 /* #2129 'WKWebsiteDataStore' => 'WebKit.WKWebsiteDataStore, Xamarin.Mac' */ },
		{ NULL, 0x25916 /* #2130 'WKWebView' => 'WebKit.WKWebView, Xamarin.Mac' */ },
		{ NULL, 0x2C616 /* #2131 'SKProductsRequest' => 'StoreKit.SKProductsRequest, Xamarin.Mac' */ },
		{ NULL, 0x2FA16 /* #2132 'SKPhysicsWorld' => 'SpriteKit.SKPhysicsWorld, Xamarin.Mac' */ },
		{ NULL, 0x30B16 /* #2133 'SKTextureAtlas' => 'SpriteKit.SKTextureAtlas, Xamarin.Mac' */ },
		{ NULL, 0x32F16 /* #2134 'SLRequest' => 'Social.SLRequest, Xamarin.Mac' */ },
		{ NULL, 0x39516 /* #2135 'SBApplication' => 'ScriptingBridge.SBApplication, Xamarin.Mac' */ },
		{ NULL, 0x3AB16 /* #2136 'SCNAnimationEvent' => 'SceneKit.SCNAnimationEvent, Xamarin.Mac' */ },
		{ NULL, 0x3E616 /* #2137 'SCNLayer' => 'SceneKit.SCNLayer, Xamarin.Mac' */ },
		{ NULL, 0x41C16 /* #2138 'SCNPhysicsWorld' => 'SceneKit.SCNPhysicsWorld, Xamarin.Mac' */ },
		{ NULL, 0x42816 /* #2139 'SCNRenderer' => 'SceneKit.SCNRenderer, Xamarin.Mac' */ },
		{ NULL, 0x45716 /* #2140 'SCNView' => 'SceneKit.SCNView, Xamarin.Mac' */ },
		{ NULL, 0x47116 /* #2141 'SFContentBlockerManager' => 'SafariServices.SFContentBlockerManager, Xamarin.Mac' */ },
		{ NULL, 0x47516 /* #2142 'SFSafariApplication' => 'SafariServices.SFSafariApplication, Xamarin.Mac' */ },
		{ NULL, 0x47616 /* #2143 'SFSafariExtensionHandler' => 'SafariServices.SFSafariExtensionHandler, Xamarin.Mac' */ },
		{ NULL, 0x47D16 /* #2144 'SFSafariPage' => 'SafariServices.SFSafariPage, Xamarin.Mac' */ },
		{ NULL, 0x48016 /* #2145 'SFSafariTab' => 'SafariServices.SFSafariTab, Xamarin.Mac' */ },
		{ NULL, 0x48216 /* #2146 'SFSafariWindow' => 'SafariServices.SFSafariWindow, Xamarin.Mac' */ },
		{ NULL, 0x51616 /* #2147 'PHLivePhotoEditingContext' => 'Photos.PHLivePhotoEditingContext, Xamarin.Mac' */ },
		{ NULL, 0x52016 /* #2148 'PHPhotoLibrary' => 'Photos.PHPhotoLibrary, Xamarin.Mac' */ },
		{ NULL, 0x5AE16 /* #2149 'PDFDocument' => 'PdfKit.PdfDocument, Xamarin.Mac' */ },
		{ NULL, 0x5C016 /* #2150 'PDFThumbnailView' => 'PdfKit.PdfThumbnailView, Xamarin.Mac' */ },
		{ NULL, 0x5C116 /* #2151 'PDFView' => 'PdfKit.PdfView, Xamarin.Mac' */ },
		{ NULL, 0x5D016 /* #2152 'NCWidgetListViewController' => 'NotificationCenter.NCWidgetListViewController, Xamarin.Mac' */ },
		{ NULL, 0x5DB16 /* #2153 'NCWidgetSearchViewController' => 'NotificationCenter.NCWidgetSearchViewController, Xamarin.Mac' */ },
		{ NULL, 0x5E416 /* #2154 'NEAppProxyFlow' => 'NetworkExtension.NEAppProxyFlow, Xamarin.Mac' */ },
		{ NULL, 0x60616 /* #2155 'NEProvider' => 'NetworkExtension.NEProvider, Xamarin.Mac' */ },
		{ NULL, 0x60B16 /* #2156 'NETunnelProvider' => 'NetworkExtension.NETunnelProvider, Xamarin.Mac' */ },
		{ NULL, 0x5E716 /* #2157 'NEAppProxyProvider' => 'NetworkExtension.NEAppProxyProvider, Xamarin.Mac' */ },
		{ NULL, 0x61E16 /* #2158 'NEVPNManager' => 'NetworkExtension.NEVpnManager, Xamarin.Mac' */ },
		{ NULL, 0x60E16 /* #2159 'NETunnelProviderManager' => 'NetworkExtension.NETunnelProviderManager, Xamarin.Mac' */ },
		{ NULL, 0x5E816 /* #2160 'NEAppProxyProviderManager' => 'NetworkExtension.NEAppProxyProviderManager, Xamarin.Mac' */ },
		{ NULL, 0x5E916 /* #2161 'NEAppProxyTCPFlow' => 'NetworkExtension.NEAppProxyTcpFlow, Xamarin.Mac' */ },
		{ NULL, 0x5EA16 /* #2162 'NEAppProxyUDPFlow' => 'NetworkExtension.NEAppProxyUdpFlow, Xamarin.Mac' */ },
		{ NULL, 0x5F116 /* #2163 'NEFilterManager' => 'NetworkExtension.NEFilterManager, Xamarin.Mac' */ },
		{ NULL, 0x5F416 /* #2164 'NEFilterProvider' => 'NetworkExtension.NEFilterProvider, Xamarin.Mac' */ },
		{ NULL, 0x60316 /* #2165 'NEPacketTunnelFlow' => 'NetworkExtension.NEPacketTunnelFlow, Xamarin.Mac' */ },
		{ NULL, 0x60516 /* #2166 'NEPacketTunnelProvider' => 'NetworkExtension.NEPacketTunnelProvider, Xamarin.Mac' */ },
		{ NULL, 0x62816 /* #2167 'NWTCPConnection' => 'NetworkExtension.NWTcpConnection, Xamarin.Mac' */ },
		{ NULL, 0x62F16 /* #2168 'NWUDPSession' => 'NetworkExtension.NWUdpSession, Xamarin.Mac' */ },
		{ NULL, 0x65516 /* #2169 'NLLanguageRecognizer' => 'NaturalLanguage.NLLanguageRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x65A16 /* #2170 'NLTagger' => 'NaturalLanguage.NLTagger, Xamarin.Mac' */ },
		{ NULL, 0x67B16 /* #2171 'MCSession' => 'MultipeerConnectivity.MCSession, Xamarin.Mac' */ },
		{ NULL, 0x6A816 /* #2172 'MDLMesh' => 'ModelIO.MDLMesh, Xamarin.Mac' */ },
		{ NULL, 0x79116 /* #2173 'MPSNNGraph' => 'MetalPerformanceShaders.MPSNNGraph, Xamarin.Mac' */ },
		{ NULL, 0x7C516 /* #2174 'MTKTextureLoader' => 'MetalKit.MTKTextureLoader, Xamarin.Mac' */ },
		{ NULL, 0x8BE16 /* #2175 'MPSkipIntervalCommand' => 'MediaPlayer.MPSkipIntervalCommand, Xamarin.Mac' */ },
		{ NULL, 0x8DB16 /* #2176 'MKDirections' => 'MapKit.MKDirections, Xamarin.Mac' */ },
		{ NULL, 0x8E716 /* #2177 'MKLocalSearch' => 'MapKit.MKLocalSearch, Xamarin.Mac' */ },
		{ NULL, 0x8F416 /* #2178 'MKMapSnapshotter' => 'MapKit.MKMapSnapshotter, Xamarin.Mac' */ },
		{ NULL, 0x8F616 /* #2179 'MKMapView' => 'MapKit.MKMapView, Xamarin.Mac' */ },
		{ NULL, 0x93116 /* #2180 'LAContext' => 'LocalAuthentication.LAContext, Xamarin.Mac' */ },
		{ NULL, 0x97716 /* #2181 'INInteraction' => 'Intents.INInteraction, Xamarin.Mac' */ },
		{ NULL, 0x9B516 /* #2182 'IKCameraDeviceView' => 'ImageKit.IKCameraDeviceView, Xamarin.Mac' */ },
		{ NULL, 0x9BB16 /* #2183 'IKDeviceBrowserView' => 'ImageKit.IKDeviceBrowserView, Xamarin.Mac' */ },
		{ NULL, 0x9C116 /* #2184 'IKFilterBrowserPanel' => 'ImageKit.IKFilterBrowserPanel, Xamarin.Mac' */ },
		{ NULL, 0x9D416 /* #2185 'IKImageBrowserView' => 'ImageKit.IKImageBrowserView, Xamarin.Mac' */ },
		{ NULL, 0x9E116 /* #2186 'IKSaveOptions' => 'ImageKit.IKSaveOptions, Xamarin.Mac' */ },
		{ NULL, 0x9E616 /* #2187 'IKScannerDeviceView' => 'ImageKit.IKScannerDeviceView, Xamarin.Mac' */ },
		{ NULL, 0xA2B16 /* #2188 'GLKTextureLoader' => 'GLKit.GLKTextureLoader, Xamarin.Mac' */ },
		{ NULL, 0xA9116 /* #2189 'GKAchievement' => 'GameKit.GKAchievement, Xamarin.Mac' */ },
		{ NULL, 0xA9416 /* #2190 'GKAchievementDescription' => 'GameKit.GKAchievementDescription, Xamarin.Mac' */ },
		{ NULL, 0xAB616 /* #2191 'GKGameCenterViewController' => 'GameKit.GKGameCenterViewController, Xamarin.Mac' */ },
		{ NULL, 0xA9516 /* #2192 'GKAchievementViewController' => 'GameKit.GKAchievementViewController, Xamarin.Mac' */ },
		{ NULL, 0xA9C16 /* #2193 'GKChallengeEventHandler' => 'GameKit.GKChallengeEventHandler, Xamarin.Mac' */ },
		{ NULL, 0xAAF16 /* #2194 'GKFriendRequestComposeViewController' => 'GameKit.GKFriendRequestComposeViewController, Xamarin.Mac' */ },
		{ NULL, 0xAB816 /* #2195 'GKGameSession' => 'GameKit.GKGameSession, Xamarin.Mac' */ },
		{ NULL, 0xAC516 /* #2196 'GKLeaderboard' => 'GameKit.GKLeaderboard, Xamarin.Mac' */ },
		{ NULL, 0xAC816 /* #2197 'GKLeaderboardSet' => 'GameKit.GKLeaderboardSet, Xamarin.Mac' */ },
		{ NULL, 0xACA16 /* #2198 'GKLeaderboardViewController' => 'GameKit.GKLeaderboardViewController, Xamarin.Mac' */ },
		{ NULL, 0xAF016 /* #2199 'GKPlayer' => 'GameKit.GKPlayer, Xamarin.Mac' */ },
		{ NULL, 0xACE16 /* #2200 'GKLocalPlayer' => 'GameKit.GKLocalPlayer, Xamarin.Mac' */ },
		{ NULL, 0xAD316 /* #2201 'GKMatch' => 'GameKit.GKMatch, Xamarin.Mac' */ },
		{ NULL, 0xADF16 /* #2202 'GKMatchmaker' => 'GameKit.GKMatchmaker, Xamarin.Mac' */ },
		{ NULL, 0xAE016 /* #2203 'GKMatchmakerViewController' => 'GameKit.GKMatchmakerViewController, Xamarin.Mac' */ },
		{ NULL, 0xAED16 /* #2204 'GKNotificationBanner' => 'GameKit.GKNotificationBanner, Xamarin.Mac' */ },
		{ NULL, 0xAF216 /* #2205 'GKSavedGame' => 'GameKit.GKSavedGame, Xamarin.Mac' */ },
		{ NULL, 0xAF716 /* #2206 'GKScore' => 'GameKit.GKScore, Xamarin.Mac' */ },
		{ NULL, 0xB0A16 /* #2207 'GKTurnBasedExchange' => 'GameKit.GKTurnBasedExchange, Xamarin.Mac' */ },
		{ NULL, 0xB0D16 /* #2208 'GKTurnBasedMatch' => 'GameKit.GKTurnBasedMatch, Xamarin.Mac' */ },
		{ NULL, 0xB3016 /* #2209 'GCController' => 'GameController.GCController, Xamarin.Mac' */ },
		{ NULL, 0xB4716 /* #2210 'FIFinderSync' => 'FinderSync.FIFinderSync, Xamarin.Mac' */ },
		{ NULL, 0xB4816 /* #2211 'FIFinderSyncController' => 'FinderSync.FIFinderSyncController, Xamarin.Mac' */ },
		{ NULL, 0xB4E16 /* #2212 'EAAccessory' => 'ExternalAccessory.EAAccessory, Xamarin.Mac' */ },
		{ NULL, 0xB5316 /* #2213 'EAAccessoryManager' => 'ExternalAccessory.EAAccessoryManager, Xamarin.Mac' */ },
		{ NULL, 0xB6816 /* #2214 'EKEventStore' => 'EventKit.EKEventStore, Xamarin.Mac' */ },
		{ NULL, 0xB8216 /* #2215 'CWInterface' => 'CoreWlan.CWInterface, Xamarin.Mac' */ },
		{ NULL, 0xC3B16 /* #2216 'CSSearchableIndex' => 'CoreSpotlight.CSSearchableIndex, Xamarin.Mac' */ },
		{ NULL, 0xC7216 /* #2217 'MLMultiArray' => 'CoreML.MLMultiArray, Xamarin.Mac' */ },
		{ NULL, 0xCD016 /* #2218 'CLGeocoder' => 'CoreLocation.CLGeocoder, Xamarin.Mac' */ },
		{ NULL, 0xCD416 /* #2219 'CLLocationManager' => 'CoreLocation.CLLocationManager, Xamarin.Mac' */ },
		{ NULL, 0xED416 /* #2220 'NSManagedObjectContext' => 'CoreData.NSManagedObjectContext, Xamarin.Mac' */ },
		{ NULL, 0xEDD16 /* #2221 'NSPersistentContainer' => 'CoreData.NSPersistentContainer, Xamarin.Mac' */ },
		{ NULL, 0xEE716 /* #2222 'NSPersistentStoreCoordinator' => 'CoreData.NSPersistentStoreCoordinator, Xamarin.Mac' */ },
		{ NULL, 0xF0416 /* #2223 'CBCentralManager' => 'CoreBluetooth.CBCentralManager, Xamarin.Mac' */ },
		{ NULL, 0xF1C16 /* #2224 'CBPeripheral' => 'CoreBluetooth.CBPeripheral, Xamarin.Mac' */ },
		{ NULL, 0xF2716 /* #2225 'CBPeripheralManager' => 'CoreBluetooth.CBPeripheralManager, Xamarin.Mac' */ },
		{ NULL, 0xF9616 /* #2226 'CNContactStore' => 'Contacts.CNContactStore, Xamarin.Mac' */ },
		{ NULL, 0xFC916 /* #2227 'CKContainer' => 'CloudKit.CKContainer, Xamarin.Mac' */ },
		{ NULL, 0xFCA16 /* #2228 'CKDatabase' => 'CloudKit.CKDatabase, Xamarin.Mac' */ },
		{ NULL, 0x103616 /* #2229 'AVAssetExportSession' => 'AVFoundation.AVAssetExportSession, Xamarin.Mac' */ },
		{ NULL, 0x105316 /* #2230 'AVAssetWriter' => 'AVFoundation.AVAssetWriter, Xamarin.Mac' */ },
		{ NULL, 0x106F16 /* #2231 'AVAudioEngine' => 'AVFoundation.AVAudioEngine, Xamarin.Mac' */ },
		{ NULL, 0x108A16 /* #2232 'AVAudioPlayerNode' => 'AVFoundation.AVAudioPlayerNode, Xamarin.Mac' */ },
		{ NULL, 0x10A716 /* #2233 'AVAudioUnitComponent' => 'AVFoundation.AVAudioUnitComponent, Xamarin.Mac' */ },
		{ NULL, 0x10C816 /* #2234 'AVCaptureDevice' => 'AVFoundation.AVCaptureDevice, Xamarin.Mac' */ },
		{ NULL, 0x10E116 /* #2235 'AVCaptureSession' => 'AVFoundation.AVCaptureSession, Xamarin.Mac' */ },
		{ NULL, 0x10E216 /* #2236 'AVCaptureStillImageOutput' => 'AVFoundation.AVCaptureStillImageOutput, Xamarin.Mac' */ },
		{ NULL, 0x10EC16 /* #2237 'AVCaptureVideoPreviewLayer' => 'AVFoundation.AVCaptureVideoPreviewLayer, Xamarin.Mac' */ },
		{ NULL, 0x111716 /* #2238 'AVFragmentedMovie' => 'AVFoundation.AVFragmentedMovie, Xamarin.Mac' */ },
		{ NULL, 0x111A16 /* #2239 'AVFragmentedMovieTrack' => 'AVFoundation.AVFragmentedMovieTrack, Xamarin.Mac' */ },
		{ NULL, 0x113516 /* #2240 'AVMIDIPlayer' => 'AVFoundation.AVMidiPlayer, Xamarin.Mac' */ },
		{ NULL, 0x115716 /* #2241 'AVPlayerItem' => 'AVFoundation.AVPlayerItem, Xamarin.Mac' */ },
		{ NULL, 0x117716 /* #2242 'AVPlayerItemVideoOutput' => 'AVFoundation.AVPlayerItemVideoOutput, Xamarin.Mac' */ },
		{ NULL, 0x118516 /* #2243 'AVRouteDetector' => 'AVFoundation.AVRouteDetector, Xamarin.Mac' */ },
		{ NULL, 0x118616 /* #2244 'AVSampleBufferAudioRenderer' => 'AVFoundation.AVSampleBufferAudioRenderer, Xamarin.Mac' */ },
		{ NULL, 0x118716 /* #2245 'AVSampleBufferDisplayLayer' => 'AVFoundation.AVSampleBufferDisplayLayer, Xamarin.Mac' */ },
		{ NULL, 0x118816 /* #2246 'AVSampleBufferGenerator' => 'AVFoundation.AVSampleBufferGenerator, Xamarin.Mac' */ },
		{ NULL, 0x118916 /* #2247 'AVSampleBufferRenderSynchronizer' => 'AVFoundation.AVSampleBufferRenderSynchronizer, Xamarin.Mac' */ },
		{ NULL, 0x11DC16 /* #2248 'AUAudioUnit' => 'AudioUnit.AUAudioUnit, Xamarin.Mac' */ },
		{ NULL, 0x125B16 /* #2249 'NSAccessibilityElement' => 'AppKit.NSAccessibilityElement, Xamarin.Mac' */ },
		{ NULL, 0x128816 /* #2250 'NSAlert' => 'AppKit.NSAlert, Xamarin.Mac' */ },
		{ NULL, 0x129D16 /* #2251 'NSApplication' => 'AppKit.NSApplication, Xamarin.Mac' */ },
		{ NULL, 0x12B216 /* #2252 'NSBrowser' => 'AppKit.NSBrowser, Xamarin.Mac' */ },
		{ NULL, 0x134A16 /* #2253 'NSGestureRecognizer' => 'AppKit.NSGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x12C216 /* #2254 'NSClickGestureRecognizer' => 'AppKit.NSClickGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x12EC16 /* #2255 'NSColor' => 'AppKit.NSColor, Xamarin.Mac' */ },
		{ NULL, 0x12F016 /* #2256 'NSColorPanel' => 'AppKit.NSColorPanel, Xamarin.Mac' */ },
		{ NULL, 0x12F516 /* #2257 'NSComboBox' => 'AppKit.NSComboBox, Xamarin.Mac' */ },
		{ NULL, 0x130E16 /* #2258 'NSDatePicker' => 'AppKit.NSDatePicker, Xamarin.Mac' */ },
		{ NULL, 0x131016 /* #2259 'NSDatePickerCell' => 'AppKit.NSDatePickerCell, Xamarin.Mac' */ },
		{ NULL, 0x131B16 /* #2260 'NSDocument' => 'AppKit.NSDocument, Xamarin.Mac' */ },
		{ NULL, 0x132C16 /* #2261 'NSDrawer' => 'AppKit.NSDrawer, Xamarin.Mac' */ },
		{ NULL, 0x133716 /* #2262 'NSEvent' => 'AppKit.NSEvent, Xamarin.Mac' */ },
		{ NULL, 0x133E16 /* #2263 'NSFont' => 'AppKit.NSFont, Xamarin.Mac' */ },
		{ NULL, 0x135216 /* #2264 'NSGradient' => 'AppKit.NSGradient, Xamarin.Mac' */ },
		{ NULL, 0x135D16 /* #2265 'NSHelpManager' => 'AppKit.NSHelpManager, Xamarin.Mac' */ },
		{ NULL, 0x135E16 /* #2266 'NSImage' => 'AppKit.NSImage, Xamarin.Mac' */ },
		{ NULL, 0x137C16 /* #2267 'NSMagnificationGestureRecognizer' => 'AppKit.NSMagnificationGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x138116 /* #2268 'NSMenu' => 'AppKit.NSMenu, Xamarin.Mac' */ },
		{ NULL, 0x138616 /* #2269 'NSMenuItem' => 'AppKit.NSMenuItem, Xamarin.Mac' */ },
		{ NULL, 0x147516 /* #2270 'NSTableView' => 'AppKit.NSTableView, Xamarin.Mac' */ },
		{ NULL, 0x139F16 /* #2271 'NSOutlineView' => 'AppKit.NSOutlineView, Xamarin.Mac' */ },
		{ NULL, 0x13A816 /* #2272 'NSPageController' => 'AppKit.NSPageController, Xamarin.Mac' */ },
		{ NULL, 0x13B116 /* #2273 'NSPanGestureRecognizer' => 'AppKit.NSPanGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x13C216 /* #2274 'NSPathCell' => 'AppKit.NSPathCell, Xamarin.Mac' */ },
		{ NULL, 0x13D116 /* #2275 'NSPopover' => 'AppKit.NSPopover, Xamarin.Mac' */ },
		{ NULL, 0x13D716 /* #2276 'NSPopUpButton' => 'AppKit.NSPopUpButton, Xamarin.Mac' */ },
		{ NULL, 0x13D816 /* #2277 'NSPopUpButtonCell' => 'AppKit.NSPopUpButtonCell, Xamarin.Mac' */ },
		{ NULL, 0x13DA16 /* #2278 'NSPredicateEditorRowTemplate' => 'AppKit.NSPredicateEditorRowTemplate, Xamarin.Mac' */ },
		{ NULL, 0x13DB16 /* #2279 'NSPressGestureRecognizer' => 'AppKit.NSPressGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x13EB16 /* #2280 'NSRotationGestureRecognizer' => 'AppKit.NSRotationGestureRecognizer, Xamarin.Mac' */ },
		{ NULL, 0x13FB16 /* #2281 'NSScreen' => 'AppKit.NSScreen, Xamarin.Mac' */ },
		{ NULL, 0x13FC16 /* #2282 'NSScroller' => 'AppKit.NSScroller, Xamarin.Mac' */ },
		{ NULL, 0x13FD16 /* #2283 'NSScrollView' => 'AppKit.NSScrollView, Xamarin.Mac' */ },
		{ NULL, 0x141416 /* #2284 'NSSearchField' => 'AppKit.NSSearchField, Xamarin.Mac' */ },
		{ NULL, 0x142716 /* #2285 'NSSharingService' => 'AppKit.NSSharingService, Xamarin.Mac' */ },
		{ NULL, 0x143016 /* #2286 'NSSharingServicePicker' => 'AppKit.NSSharingServicePicker, Xamarin.Mac' */ },
		{ NULL, 0x143B16 /* #2287 'NSSliderAccessory' => 'AppKit.NSSliderAccessory, Xamarin.Mac' */ },
		{ NULL, 0x143F16 /* #2288 'NSSound' => 'AppKit.NSSound, Xamarin.Mac' */ },
		{ NULL, 0x144F16 /* #2289 'NSSpellChecker' => 'AppKit.NSSpellChecker, Xamarin.Mac' */ },
		{ NULL, 0x145116 /* #2290 'NSSplitView' => 'AppKit.NSSplitView, Xamarin.Mac' */ },
		{ NULL, 0x148316 /* #2291 'NSTabView' => 'AppKit.NSTabView, Xamarin.Mac' */ },
		{ NULL, 0x148B16 /* #2292 'NSText' => 'AppKit.NSText, Xamarin.Mac' */ },
		{ NULL, 0x148C16 /* #2293 'NSTextAlternatives' => 'AppKit.NSTextAlternatives, Xamarin.Mac' */ },
		{ NULL, 0x14B116 /* #2294 'NSTextInputContext' => 'AppKit.NSTextInputContext, Xamarin.Mac' */ },
		{ NULL, 0x14B516 /* #2295 'NSTextStorage' => 'AppKit.NSTextStorage, Xamarin.Mac' */ },
		{ NULL, 0x14BE16 /* #2296 'NSTextView' => 'AppKit.NSTextView, Xamarin.Mac' */ },
		{ NULL, 0x14D216 /* #2297 'NSToolbar' => 'AppKit.NSToolbar, Xamarin.Mac' */ },
		{ NULL, 0x14DF16 /* #2298 'NSTouchBar' => 'AppKit.NSTouchBar, Xamarin.Mac' */ },
		{ NULL, 0x151016 /* #2299 'NSWorkspace' => 'AppKit.NSWorkspace, Xamarin.Mac' */ },
		{ NULL, 0x16CC16 /* #2300 'ACAccountStore' => 'Accounts.ACAccountStore, Xamarin.Mac' */ },
		{ NULL, 0x16EC16 /* #2301 'NSCache' => 'Foundation.NSCache, Xamarin.Mac' */ },
		{ NULL, 0x16F316 /* #2302 'NSCalendar' => 'Foundation.NSCalendar, Xamarin.Mac' */ },
		{ NULL, 0x170F16 /* #2303 'NSDictionary' => 'Foundation.NSDictionary, Xamarin.Mac' */ },
		{ NULL, 0x172316 /* #2304 'NSFileHandle' => 'Foundation.NSFileHandle, Xamarin.Mac' */ },
		{ NULL, 0x172416 /* #2305 'NSFileManager' => 'Foundation.NSFileManager, Xamarin.Mac' */ },
		{ NULL, 0x172F16 /* #2306 'NSFileVersion' => 'Foundation.NSFileVersion, Xamarin.Mac' */ },
		{ NULL, 0x173216 /* #2307 'NSHost' => 'Foundation.NSHost, Xamarin.Mac' */ },
		{ NULL, 0x173416 /* #2308 'NSHTTPCookieStorage' => 'Foundation.NSHttpCookieStorage, Xamarin.Mac' */ },
		{ NULL, 0x173616 /* #2309 'NSIndexPath' => 'Foundation.NSIndexPath, Xamarin.Mac' */ },
		{ NULL, 0x173D16 /* #2310 'NSItemProvider' => 'Foundation.NSItemProvider, Xamarin.Mac' */ },
		{ NULL, 0x174616 /* #2311 'NSKeyedArchiver' => 'Foundation.NSKeyedArchiver, Xamarin.Mac' */ },
		{ NULL, 0x174C16 /* #2312 'NSKeyedUnarchiver' => 'Foundation.NSKeyedUnarchiver, Xamarin.Mac' */ },
		{ NULL, 0x175B16 /* #2313 'NSLocale' => 'Foundation.NSLocale, Xamarin.Mac' */ },
		{ NULL, 0x176816 /* #2314 'NSMetadataQuery' => 'Foundation.NSMetadataQuery, Xamarin.Mac' */ },
		{ NULL, 0x177716 /* #2315 'NSMutableDictionary' => 'Foundation.NSMutableDictionary, Xamarin.Mac' */ },
		{ NULL, 0x177D16 /* #2316 'NSNetService' => 'Foundation.NSNetService, Xamarin.Mac' */ },
		{ NULL, 0x178116 /* #2317 'NSNetServiceBrowser' => 'Foundation.NSNetServiceBrowser, Xamarin.Mac' */ },
		{ NULL, 0x17AD16 /* #2318 'NSProcessInfo' => 'Foundation.NSProcessInfo, Xamarin.Mac' */ },
		{ NULL, 0x17AF16 /* #2319 'NSProgress' => 'Foundation.NSProgress, Xamarin.Mac' */ },
		{ NULL, 0x17C016 /* #2320 'NSSecureUnarchiveFromDataTransformer' => 'Foundation.NSSecureUnarchiveFromDataTransformer, Xamarin.Mac' */ },
		{ NULL, 0x17CD16 /* #2321 'NSTask' => 'Foundation.NSTask, Xamarin.Mac' */ },
		{ NULL, 0x17D216 /* #2322 'NSThread' => 'Foundation.NSThread, Xamarin.Mac' */ },
		{ NULL, 0x17D516 /* #2323 'NSUbiquitousKeyValueStore' => 'Foundation.NSUbiquitousKeyValueStore, Xamarin.Mac' */ },
		{ NULL, 0x17D616 /* #2324 'NSUndoManager' => 'Foundation.NSUndoManager, Xamarin.Mac' */ },
		{ NULL, 0x17EF16 /* #2325 'NSURL' => 'Foundation.NSUrl, Xamarin.Mac' */ },
		{ NULL, 0x17F616 /* #2326 'NSURLCache' => 'Foundation.NSUrlCache, Xamarin.Mac' */ },
		{ NULL, 0x17F816 /* #2327 'NSURLConnection' => 'Foundation.NSUrlConnection, Xamarin.Mac' */ },
		{ NULL, 0x180716 /* #2328 'NSURLCredentialStorage' => 'Foundation.NSUrlCredentialStorage, Xamarin.Mac' */ },
		{ NULL, 0x181416 /* #2329 'NSURLSession' => 'Foundation.NSUrlSession, Xamarin.Mac' */ },
		{ NULL, 0x182D16 /* #2330 'NSURLSessionStreamTask' => 'Foundation.NSUrlSessionStreamTask, Xamarin.Mac' */ },
		{ NULL, 0x183A16 /* #2331 'NSUserActivity' => 'Foundation.NSUserActivity, Xamarin.Mac' */ },
		{ NULL, 0x184116 /* #2332 'NSUserDefaults' => 'Foundation.NSUserDefaults, Xamarin.Mac' */ },
		{ NULL, 0x184416 /* #2333 'NSUserNotificationCenter' => 'Foundation.NSUserNotificationCenter, Xamarin.Mac' */ },
		{ NULL, 0x196F16 /* #2334 'WebKit_DomNode_DomNodeEventProxy' => 'WebKit.DomNode+DomNodeEventProxy, Xamarin.Mac' */ },
		{ NULL, 0x197016 /* #2335 'WebKit_DomNode_DomNodeEventProxy2' => 'WebKit.DomNode+DomNodeEventProxy2, Xamarin.Mac' */ },
		{ NULL, 0x197216 /* #2336 'WebKit_WebView__WebFrameLoadDelegate' => 'WebKit.WebView+_WebFrameLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x197316 /* #2337 'WebKit_WebView__WebDownloadDelegate' => 'WebKit.WebView+_WebDownloadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x197416 /* #2338 'WebKit_WebView__WebResourceLoadDelegate' => 'WebKit.WebView+_WebResourceLoadDelegate, Xamarin.Mac' */ },
		{ NULL, 0x197516 /* #2339 'WebKit_WebView__WebUIDelegate' => 'WebKit.WebView+_WebUIDelegate, Xamarin.Mac' */ },
		{ NULL, 0x197616 /* #2340 'WebKit_WebView__WebPolicyDelegate' => 'WebKit.WebView+_WebPolicyDelegate, Xamarin.Mac' */ },
		{ NULL, 0x198516 /* #2341 'StoreKit_SKRequest__SKRequestDelegate' => 'StoreKit.SKRequest+_SKRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x198416 /* #2342 'StoreKit_SKProductsRequest__SKProductsRequestDelegate' => 'StoreKit.SKProductsRequest+_SKProductsRequestDelegate, Xamarin.Mac' */ },
		{ NULL, 0x198816 /* #2343 'SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate' => 'SpriteKit.SKPhysicsWorld+_SKPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x199516 /* #2344 'ScriptingBridge_SBApplication__SBApplicationDelegate' => 'ScriptingBridge.SBApplication+_SBApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x199B16 /* #2345 'SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate' => 'SceneKit.SCNPhysicsWorld+_SCNPhysicsContactDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1EBA16 /* #2346 'PdfKit_PdfDocument__PdfDocumentDelegate' => 'PdfKit.PdfDocument+_PdfDocumentDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1EBE16 /* #2347 'PdfKit_PdfView__PdfViewDelegate' => 'PdfKit.PdfView+_PdfViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1EC016 /* #2348 'NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate' => 'NotificationCenter.NCWidgetListViewController+_NCWidgetListViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1EC116 /* #2349 'NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate' => 'NotificationCenter.NCWidgetSearchViewController+_NCWidgetSearchViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F1616 /* #2350 'MapKit_MKMapView__MKMapViewDelegate' => 'MapKit.MKMapView+_MKMapViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F1C16 /* #2351 'ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate' => 'ImageKit.IKCameraDeviceView+_IKCameraDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F1D16 /* #2352 'ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate' => 'ImageKit.IKDeviceBrowserView+_IKDeviceBrowserViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F1F16 /* #2353 'ImageKit_IKImageBrowserView__IKImageBrowserDelegate' => 'ImageKit.IKImageBrowserView+_IKImageBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F2016 /* #2354 'ImageKit_IKSaveOptions__IKSaveOptionsDelegate' => 'ImageKit.IKSaveOptions+_IKSaveOptionsDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F2116 /* #2355 'ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate' => 'ImageKit.IKScannerDeviceView+_IKScannerDeviceViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F3916 /* #2356 'GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate' => 'GameKit.GKGameCenterViewController+_GKGameCenterControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F3516 /* #2357 'GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate' => 'GameKit.GKAchievementViewController+_GKAchievementViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F3716 /* #2358 'GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate' => 'GameKit.GKChallengeEventHandler+_GKChallengeEventHandlerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F3816 /* #2359 'GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate' => 'GameKit.GKFriendRequestComposeViewController+_GKFriendRequestComposeViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F4C16 /* #2360 'GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate' => 'GameKit.GKLeaderboardViewController+_GKLeaderboardViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F5716 /* #2361 'GameKit_GKMatch__GKMatchDelegate' => 'GameKit.GKMatch+_GKMatchDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F6216 /* #2362 'GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate' => 'GameKit.GKMatchmakerViewController+_GKMatchmakerViewControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1F8916 /* #2363 'ExternalAccessory_EAAccessory__EAAccessoryDelegate' => 'ExternalAccessory.EAAccessory+_EAAccessoryDelegate, Xamarin.Mac' */ },
		{ NULL, 0x1FE916 /* #2364 'CoreLocation_CLLocationManager__CLLocationManagerDelegate' => 'CoreLocation.CLLocationManager+_CLLocationManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x202C16 /* #2365 'CoreBluetooth_CBCentralManager__CBCentralManagerDelegate' => 'CoreBluetooth.CBCentralManager+_CBCentralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x202D16 /* #2366 'CoreBluetooth_CBPeripheral__CBPeripheralDelegate' => 'CoreBluetooth.CBPeripheral+_CBPeripheralDelegate, Xamarin.Mac' */ },
		{ NULL, 0x202E16 /* #2367 'CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate' => 'CoreBluetooth.CBPeripheralManager+_CBPeripheralManagerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x202F16 /* #2368 'CoreAnimation_CAAnimation__CAAnimationDelegate' => 'CoreAnimation.CAAnimation+_CAAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x206916 /* #2369 'AVFoundation_AVCaptureFileOutput_recordingProxy' => 'AVFoundation.AVCaptureFileOutput+recordingProxy, Xamarin.Mac' */ },
		{ NULL, 0x209616 /* #2370 'AppKit_NSAlert__NSAlertDelegate' => 'AppKit.NSAlert+_NSAlertDelegate, Xamarin.Mac' */ },
		{ NULL, 0x209A16 /* #2371 'AppKit_NSAnimation__NSAnimationDelegate' => 'AppKit.NSAnimation+_NSAnimationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x209C16 /* #2372 'AppKit_NSApplication__NSApplicationDelegate' => 'AppKit.NSApplication+_NSApplicationDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20B216 /* #2373 '__NSGestureRecognizerToken' => 'AppKit.NSGestureRecognizer+Token, Xamarin.Mac' */ },
		{ NULL, 0x20A016 /* #2374 '__NSClickGestureRecognizer' => 'AppKit.NSClickGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20DD16 /* #2375 'AppKit_NSTextField__NSTextFieldDelegate' => 'AppKit.NSTextField+_NSTextFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20A316 /* #2376 'AppKit_NSComboBox__NSComboBoxDelegate' => 'AppKit.NSComboBox+_NSComboBoxDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20A616 /* #2377 'AppKit_NSDatePicker__NSDatePickerCellDelegate' => 'AppKit.NSDatePicker+_NSDatePickerCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20A716 /* #2378 'AppKit_NSDatePickerCell__NSDatePickerCellDelegate' => 'AppKit.NSDatePickerCell+_NSDatePickerCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20A916 /* #2379 '__NSDocumentDuplicateCallback' => 'AppKit.NSDocument+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20AC16 /* #2380 'AppKit_NSDrawer__NSDrawerDelegate' => 'AppKit.NSDrawer+_NSDrawerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20B116 /* #2381 'AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate' => 'AppKit.NSGestureRecognizer+_NSGestureRecognizerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20B316 /* #2382 '__NSGestureRecognizerParameterlessToken' => 'AppKit.NSGestureRecognizer+ParameterlessDispatch, Xamarin.Mac' */ },
		{ NULL, 0x20B416 /* #2383 '__NSGestureRecognizerParametrizedToken' => 'AppKit.NSGestureRecognizer+ParametrizedDispatch, Xamarin.Mac' */ },
		{ NULL, 0x20B716 /* #2384 'AppKit_NSImage__NSImageDelegate' => 'AppKit.NSImage+_NSImageDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20B916 /* #2385 '__NSMagnificationGestureRecognizer' => 'AppKit.NSMagnificationGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20BA16 /* #2386 'AppKit_NSMatrix__NSMatrixDelegate' => 'AppKit.NSMatrix+_NSMatrixDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20BE16 /* #2387 'AppKit_NSPageController__NSPageControllerDelegate' => 'AppKit.NSPageController+_NSPageControllerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20BF16 /* #2388 '__NSPanGestureRecognizer' => 'AppKit.NSPanGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20C016 /* #2389 'AppKit_NSPathCell__NSPathCellDelegate' => 'AppKit.NSPathCell+_NSPathCellDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20C516 /* #2390 '__NSPressGestureRecognizer' => 'AppKit.NSPressGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20C616 /* #2391 '__NSRotationGestureRecognizer' => 'AppKit.NSRotationGestureRecognizer+Callback, Xamarin.Mac' */ },
		{ NULL, 0x20C716 /* #2392 'AppKit_NSRuleEditor__NSRuleEditorDelegate' => 'AppKit.NSRuleEditor+_NSRuleEditorDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20C916 /* #2393 'AppKit_NSSavePanel__NSOpenSavePanelDelegate' => 'AppKit.NSSavePanel+_NSOpenSavePanelDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20CD16 /* #2394 'AppKit_NSSearchField__NSSearchFieldDelegate' => 'AppKit.NSSearchField+_NSSearchFieldDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20CE16 /* #2395 'AppKit_NSSharingService__NSSharingServiceDelegate' => 'AppKit.NSSharingService+_NSSharingServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20CF16 /* #2396 'AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate' => 'AppKit.NSSharingServicePicker+_NSSharingServicePickerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20D116 /* #2397 'AppKit_NSSound__NSSoundDelegate' => 'AppKit.NSSound+_NSSoundDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20D616 /* #2398 'AppKit_NSTableView__NSTableViewDelegate' => 'AppKit.NSTableView+_NSTableViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20D816 /* #2399 'AppKit_NSTabView__NSTabViewDelegate' => 'AppKit.NSTabView+_NSTabViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20D916 /* #2400 'AppKit_NSText__NSTextDelegate' => 'AppKit.NSText+_NSTextDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20DF16 /* #2401 'AppKit_NSTextStorage__NSTextStorageDelegate' => 'AppKit.NSTextStorage+_NSTextStorageDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20E116 /* #2402 'AppKit_NSTextView__NSTextViewDelegate' => 'AppKit.NSTextView+_NSTextViewDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20E316 /* #2403 'AppKit_NSToolbar__NSToolbarDelegate' => 'AppKit.NSToolbar+_NSToolbarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20E516 /* #2404 'AppKit_NSTouchBar__NSTouchBarDelegate' => 'AppKit.NSTouchBar+_NSTouchBarDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20E716 /* #2405 'AppKit_NSWindow__NSWindowDelegate' => 'AppKit.NSWindow+_NSWindowDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20FB16 /* #2406 'Foundation_NSUrlSessionHandler_WrappedNSInputStream' => 'Foundation.NSUrlSessionHandler+WrappedNSInputStream, Xamarin.Mac' */ },
		{ NULL, 0x210016 /* #2407 'Foundation_NSCache__NSCacheDelegate' => 'Foundation.NSCache+_NSCacheDelegate, Xamarin.Mac' */ },
		{ NULL, 0x212516 /* #2408 'Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate' => 'Foundation.NSKeyedArchiver+_NSKeyedArchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x212616 /* #2409 'Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate' => 'Foundation.NSKeyedUnarchiver+_NSKeyedUnarchiverDelegate, Xamarin.Mac' */ },
		{ NULL, 0x212A16 /* #2410 'Foundation_NSMetadataQuery__NSMetadataQueryDelegate' => 'Foundation.NSMetadataQuery+_NSMetadataQueryDelegate, Xamarin.Mac' */ },
		{ NULL, 0x212F16 /* #2411 'Foundation_NSNetService__NSNetServiceDelegate' => 'Foundation.NSNetService+_NSNetServiceDelegate, Xamarin.Mac' */ },
		{ NULL, 0x213016 /* #2412 'Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate' => 'Foundation.NSNetServiceBrowser+_NSNetServiceBrowserDelegate, Xamarin.Mac' */ },
		{ NULL, 0x213316 /* #2413 '__NSObject_Disposer' => 'Foundation.NSObject+NSObject_Disposer, Xamarin.Mac' */ },
		{ NULL, 0x213416 /* #2414 '__XamarinObjectObserver' => 'Foundation.NSObject+Observer, Xamarin.Mac' */ },
		{ NULL, 0x213B16 /* #2415 'Foundation_NSStream__NSStreamDelegate' => 'Foundation.NSStream+_NSStreamDelegate, Xamarin.Mac' */ },
		{ NULL, 0x213F16 /* #2416 'Foundation_NSThread_ActionThread' => 'Foundation.NSThread+ActionThread, Xamarin.Mac' */ },
		{ NULL, 0x216016 /* #2417 'Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate' => 'Foundation.NSUserNotificationCenter+_NSUserNotificationCenterDelegate, Xamarin.Mac' */ },
		{ NULL, 0x20F716 /* #2418 'Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate' => 'Foundation.NSUrlSessionHandler+NSUrlSessionHandlerDelegate, Xamarin.Mac' */ },
		{ NULL, 0x31A /* #2419 'AppDelegate' => 'RayTracerWindow.AppDelegate, RayTracerWindow' */ },
		{ NULL, 0x41A /* #2420 'ViewController' => 'RayTracerWindow.ViewController, RayTracerWindow' */ },
		{ NULL, 0 },
	};

	static const MTManagedClassMap __xamarin_skipped_map [] = {
		{ 0x9B416, 838 /* 'Intents.INIntentResolutionResult`1' => 'Intents.INIntentResolutionResult' */ },
		{ 0xA8C16, 942 /* 'GameplayKit.GKObstacleGraph`1' => 'GameplayKit.GKObstacleGraph' */ },
		{ 0x188016, 275 /* 'Foundation.NSArray`1' => 'Foundation.NSArray' */ },
		{ 0x188316, 2303 /* 'Foundation.NSDictionary`2' => 'Foundation.NSDictionary' */ },
		{ 0x188B16, 276 /* 'Foundation.NSMutableArray`1' => 'Foundation.NSMutableArray' */ },
		{ 0x188C16, 2315 /* 'Foundation.NSMutableDictionary`2' => 'Foundation.NSMutableDictionary' */ },
		{ 0x188D16, 2028 /* 'Foundation.NSMutableOrderedSet`1' => 'Foundation.NSMutableOrderedSet' */ },
		{ 0x188E16, 2030 /* 'Foundation.NSMutableSet`1' => 'Foundation.NSMutableSet' */ },
		{ 0x189116, 2027 /* 'Foundation.NSOrderedSet`1' => 'Foundation.NSOrderedSet' */ },
		{ 0x189816, 2029 /* 'Foundation.NSSet`1' => 'Foundation.NSSet' */ },
	};

	static const char *__xamarin_registration_assemblies []= {
		"mscorlib", 
		"RayTracerLogic", 
		"RayTracerMain", 
		"System.Core", 
		"System", 
		"Mono.Security", 
		"System.Configuration", 
		"System.Xml", 
		"System.Security", 
		"System.Numerics", 
		"Mono.Posix", 
		"Xamarin.Mac", 
		"System.Net.Http", 
		"RayTracerWindow"
	};

	static const MTProtocolWrapperMap __xamarin_protocol_wrapper_map [] = {
		{ 0x12016 /* VideoSubscriberAccount.IVSAccountManagerDelegate */, 0x12216 /* VSAccountManagerDelegateWrapper */ },
		{ 0x15116 /* UserNotifications.IUNUserNotificationCenterDelegate */, 0x15316 /* UNUserNotificationCenterDelegateWrapper */ },
		{ 0x18816 /* WebKit.IDomEventListener */, 0x18916 /* DomEventListenerWrapper */ },
		{ 0x18B16 /* WebKit.IDomEventTarget */, 0x18C16 /* DomEventTargetWrapper */ },
		{ 0x1CE16 /* WebKit.IDomNodeFilter */, 0x1CF16 /* DomNodeFilterWrapper */ },
		{ 0x1E016 /* WebKit.IWebDocumentRepresentation */, 0x1E116 /* WebDocumentRepresentationWrapper */ },
		{ 0x1E416 /* WebKit.IWebDownloadDelegate */, 0x1E616 /* WebDownloadDelegateWrapper */ },
		{ 0x1E916 /* WebKit.IWebFrameLoadDelegate */, 0x1EB16 /* WebFrameLoadDelegateWrapper */ },
		{ 0x1F016 /* WebKit.IWebOpenPanelResultListener */, 0x1F216 /* WebOpenPanelResultListenerWrapper */ },
		{ 0x1F416 /* WebKit.IWebPolicyDecisionListener */, 0x1F616 /* WebPolicyDecisionListenerWrapper */ },
		{ 0x1F816 /* WebKit.IWebPolicyDelegate */, 0x1FA16 /* WebPolicyDelegateWrapper */ },
		{ 0x1FE16 /* WebKit.IWebResourceLoadDelegate */, 0x20016 /* WebResourceLoadDelegateWrapper */ },
		{ 0x20316 /* WebKit.IWebUIDelegate */, 0x20516 /* WebUIDelegateWrapper */ },
		{ 0x23416 /* WebKit.IWKHttpCookieStoreObserver */, 0x23616 /* WKHttpCookieStoreObserverWrapper */ },
		{ 0x23A16 /* WebKit.IWKNavigationDelegate */, 0x23C16 /* WKNavigationDelegateWrapper */ },
		{ 0x24516 /* WebKit.IWKScriptMessageHandler */, 0x24616 /* WKScriptMessageHandlerWrapper */ },
		{ 0x24B16 /* WebKit.IWKUIDelegate */, 0x24D16 /* WKUIDelegateWrapper */ },
		{ 0x24F16 /* WebKit.IWKUrlSchemeHandler */, 0x25016 /* WKUrlSchemeHandlerWrapper */ },
		{ 0x25116 /* WebKit.IWKUrlSchemeTask */, 0x25216 /* WKUrlSchemeTaskWrapper */ },
		{ 0x28C16 /* Vision.IVNFaceObservationAccepting */, 0x28D16 /* VNFaceObservationAcceptingWrapper */ },
		{ 0x2A316 /* Vision.IVNRequestRevisionProviding */, 0x2A416 /* VNRequestRevisionProvidingWrapper */ },
		{ 0x2BD16 /* StoreKit.ISKPaymentTransactionObserver */, 0x2BF16 /* SKPaymentTransactionObserverWrapper */ },
		{ 0x2C816 /* StoreKit.ISKProductsRequestDelegate */, 0x2C916 /* SKProductsRequestDelegateWrapper */ },
		{ 0x2D016 /* StoreKit.ISKRequestDelegate */, 0x2D216 /* SKRequestDelegateWrapper */ },
		{ 0x2F016 /* SpriteKit.ISKPhysicsContactDelegate */, 0x2F216 /* SKPhysicsContactDelegateWrapper */ },
		{ 0x30216 /* SpriteKit.ISKSceneDelegate */, 0x30416 /* SKSceneDelegateWrapper */ },
		{ 0x31D16 /* SpriteKit.ISKViewDelegate */, 0x31F16 /* SKViewDelegateWrapper */ },
		{ 0x32116 /* SpriteKit.ISKWarpable */, 0x32216 /* SKWarpableWrapper */ },
		{ 0x39616 /* ScriptingBridge.ISBApplicationDelegate */, 0x39716 /* SBApplicationDelegateWrapper */ },
		{ 0x3A116 /* SceneKit.ISCNActionable */, 0x3A316 /* SCNActionableWrapper */ },
		{ 0x3A616 /* SceneKit.ISCNAnimatable */, 0x3A816 /* SCNAnimatableWrapper */ },
		{ 0x3AE16 /* SceneKit.ISCNAnimationProtocol */, 0x3AF16 /* SCNAnimationProtocolWrapper */ },
		{ 0x3B416 /* SceneKit.ISCNAvoidOccluderConstraintDelegate */, 0x3B616 /* SCNAvoidOccluderConstraintDelegateWrapper */ },
		{ 0x3BB16 /* SceneKit.ISCNBoundingVolume */, 0x3BC16 /* SCNBoundingVolumeWrapper */ },
		{ 0x3C016 /* SceneKit.ISCNBufferStream */, 0x3C116 /* SCNBufferStreamWrapper */ },
		{ 0x3C316 /* SceneKit.ISCNCameraControlConfiguration */, 0x3C416 /* SCNCameraControlConfigurationWrapper */ },
		{ 0x3C616 /* SceneKit.ISCNCameraControllerDelegate */, 0x3C816 /* SCNCameraControllerDelegateWrapper */ },
		{ 0x3F416 /* SceneKit.ISCNNodeRendererDelegate */, 0x3F616 /* SCNNodeRendererDelegateWrapper */ },
		{ 0x40B16 /* SceneKit.ISCNPhysicsContactDelegate */, 0x40D16 /* SCNPhysicsContactDelegateWrapper */ },
		{ 0x42016 /* SceneKit.ISCNProgramDelegate */, 0x42216 /* SCNProgramDelegateWrapper */ },
		{ 0x42F16 /* SceneKit.ISCNSceneExportDelegate */, 0x43116 /* SCNSceneExportDelegateWrapper */ },
		{ 0x43416 /* SceneKit.ISCNSceneRenderer */, 0x43616 /* SCNSceneRendererWrapper */ },
		{ 0x43816 /* SceneKit.ISCNSceneRendererDelegate */, 0x43A16 /* SCNSceneRendererDelegateWrapper */ },
		{ 0x44116 /* SceneKit.ISCNShadable */, 0x44316 /* SCNShadableWrapper */ },
		{ 0x44C16 /* SceneKit.ISCNTechniqueSupport */, 0x44D16 /* SCNTechniqueSupportWrapper */ },
		{ 0x47916 /* SafariServices.ISFSafariExtensionHandling */, 0x47B16 /* SFSafariExtensionHandlingWrapper */ },
		{ 0x48416 /* QuickLookUI.IQLPreviewingController */, 0x48516 /* QLPreviewingControllerWrapper */ },
		{ 0x48616 /* QuickLookUI.IQLPreviewItem */, 0x48816 /* QLPreviewItemWrapper */ },
		{ 0x48C16 /* QuickLookUI.IQLPreviewPanelDataSource */, 0x48D16 /* QLPreviewPanelDataSourceWrapper */ },
		{ 0x48F16 /* QuickLookUI.IQLPreviewPanelDelegate */, 0x49116 /* QLPreviewPanelDelegateWrapper */ },
		{ 0x4D416 /* PhotosUI.IPHContentEditingController */, 0x4D516 /* PHContentEditingControllerWrapper */ },
		{ 0x4D816 /* PhotosUI.IPHLivePhotoViewDelegate */, 0x4DA16 /* PHLivePhotoViewDelegateWrapper */ },
		{ 0x4E216 /* PhotosUI.IPHProjectExtensionController */, 0x4E416 /* PHProjectExtensionControllerWrapper */ },
		{ 0x4EE16 /* PhotosUI.IPHProjectTypeDescriptionDataSource */, 0x4F016 /* PHProjectTypeDescriptionDataSourceWrapper */ },
		{ 0x4F216 /* PhotosUI.IPHProjectTypeDescriptionInvalidator */, 0x4F316 /* PHProjectTypeDescriptionInvalidatorWrapper */ },
		{ 0x51B16 /* Photos.IPHLivePhotoFrame */, 0x51C16 /* PHLivePhotoFrameWrapper */ },
		{ 0x52216 /* Photos.IPHPhotoLibraryChangeObserver */, 0x52316 /* PHPhotoLibraryChangeObserverWrapper */ },
		{ 0x5B116 /* PdfKit.IPdfDocumentDelegate */, 0x5B316 /* PdfDocumentDelegateWrapper */ },
		{ 0x5C416 /* PdfKit.IPdfViewDelegate */, 0x5C616 /* PdfViewDelegateWrapper */ },
		{ 0x5D316 /* NotificationCenter.INCWidgetListViewDelegate */, 0x5D516 /* NCWidgetListViewDelegateWrapper */ },
		{ 0x5D716 /* NotificationCenter.INCWidgetProviding */, 0x5D916 /* NCWidgetProvidingWrapper */ },
		{ 0x5DE16 /* NotificationCenter.INCWidgetSearchViewDelegate */, 0x5DF16 /* NCWidgetSearchViewDelegateWrapper */ },
		{ 0x62916 /* NetworkExtension.INWTcpConnectionAuthenticationDelegate */, 0x62B16 /* NWTcpConnectionAuthenticationDelegateWrapper */ },
		{ 0x66416 /* MultipeerConnectivity.IMCAdvertiserAssistantDelegate */, 0x66616 /* MCAdvertiserAssistantDelegateWrapper */ },
		{ 0x66916 /* MultipeerConnectivity.IMCBrowserViewControllerDelegate */, 0x66B16 /* MCBrowserViewControllerDelegateWrapper */ },
		{ 0x67116 /* MultipeerConnectivity.IMCNearbyServiceAdvertiserDelegate */, 0x67316 /* MCNearbyServiceAdvertiserDelegateWrapper */ },
		{ 0x67616 /* MultipeerConnectivity.IMCNearbyServiceBrowserDelegate */, 0x67816 /* MCNearbyServiceBrowserDelegateWrapper */ },
		{ 0x67C16 /* MultipeerConnectivity.IMCSessionDelegate */, 0x67E16 /* MCSessionDelegateWrapper */ },
		{ 0x69116 /* ModelIO.IMDLAssetResolver */, 0x69216 /* MDLAssetResolverWrapper */ },
		{ 0x69716 /* ModelIO.IMDLComponent */, 0x69816 /* MDLComponentWrapper */ },
		{ 0x69A16 /* ModelIO.IMDLJointAnimation */, 0x69B16 /* MDLJointAnimationWrapper */ },
		{ 0x69E16 /* ModelIO.IMDLLightProbeIrradianceDataSource */, 0x6A016 /* MDLLightProbeIrradianceDataSourceWrapper */ },
		{ 0x6A916 /* ModelIO.IMDLMeshBuffer */, 0x6AB16 /* MDLMeshBufferWrapper */ },
		{ 0x6AC16 /* ModelIO.IMDLMeshBufferAllocator */, 0x6AD16 /* MDLMeshBufferAllocatorWrapper */ },
		{ 0x6B116 /* ModelIO.IMDLMeshBufferZone */, 0x6B316 /* MDLMeshBufferZoneWrapper */ },
		{ 0x6B516 /* ModelIO.IMDLNamed */, 0x6B616 /* MDLNamedWrapper */ },
		{ 0x6BB16 /* ModelIO.IMDLObjectContainerComponent */, 0x6BD16 /* MDLObjectContainerComponentWrapper */ },
		{ 0x6CE16 /* ModelIO.IMDLTransformComponent */, 0x6D016 /* MDLTransformComponentWrapper */ },
		{ 0x6D216 /* ModelIO.IMDLTransformOp */, 0x6D316 /* MDLTransformOpWrapper */ },
		{ 0x70016 /* MetalPerformanceShaders.IMPSCnnConvolutionDataSource */, 0x70216 /* MPSCnnConvolutionDataSourceWrapper */ },
		{ 0x74216 /* MetalPerformanceShaders.IMPSDeviceProvider */, 0x74316 /* MPSDeviceProviderWrapper */ },
		{ 0x74516 /* MetalPerformanceShaders.IMPSHandle */, 0x74616 /* MPSHandleWrapper */ },
		{ 0x74916 /* MetalPerformanceShaders.IMPSImageAllocator */, 0x74A16 /* MPSImageAllocatorWrapper */ },
		{ 0x76516 /* MetalPerformanceShaders.IMPSImageSizeEncodingState */, 0x76616 /* MPSImageSizeEncodingStateWrapper */ },
		{ 0x77216 /* MetalPerformanceShaders.IMPSImageTransformProvider */, 0x77316 /* MPSImageTransformProviderWrapper */ },
		{ 0x79516 /* MetalPerformanceShaders.IMPSNNPadding */, 0x79716 /* MPSNNPaddingWrapper */ },
		{ 0x7CE16 /* MetalKit.IMTKViewDelegate */, 0x7CF16 /* MTKViewDelegateWrapper */ },
		{ 0x7D716 /* Metal.IMTLArgumentEncoder */, 0x7D916 /* MTLArgumentEncoderWrapper */ },
		{ 0x7E316 /* Metal.IMTLBlitCommandEncoder */, 0x7E516 /* MTLBlitCommandEncoderWrapper */ },
		{ 0x7E716 /* Metal.IMTLBuffer */, 0x7E916 /* MTLBufferWrapper */ },
		{ 0x7ED16 /* Metal.IMTLCaptureScope */, 0x7EE16 /* MTLCaptureScopeWrapper */ },
		{ 0x7F116 /* Metal.IMTLCommandBuffer */, 0x7F316 /* MTLCommandBufferWrapper */ },
		{ 0x7F716 /* Metal.IMTLCommandEncoder */, 0x7F816 /* MTLCommandEncoderWrapper */ },
		{ 0x7F916 /* Metal.IMTLCommandQueue */, 0x7FA16 /* MTLCommandQueueWrapper */ },
		{ 0x7FD16 /* Metal.IMTLComputeCommandEncoder */, 0x7FF16 /* MTLComputeCommandEncoderWrapper */ },
		{ 0x80216 /* Metal.IMTLComputePipelineState */, 0x80416 /* MTLComputePipelineStateWrapper */ },
		{ 0x80A16 /* Metal.IMTLDepthStencilState */, 0x80B16 /* MTLDepthStencilStateWrapper */ },
		{ 0x80C16 /* Metal.IMTLDevice */, 0x80E16 /* MTLDeviceWrapper */ },
		{ 0x81016 /* Metal.IMTLDrawable */, 0x81116 /* MTLDrawableWrapper */ },
		{ 0x81316 /* Metal.IMTLEvent */, 0x81416 /* MTLEventWrapper */ },
		{ 0x81616 /* Metal.IMTLFence */, 0x81716 /* MTLFenceWrapper */ },
		{ 0x81816 /* Metal.IMTLFunction */, 0x81A16 /* MTLFunctionWrapper */ },
		{ 0x81E16 /* Metal.IMTLHeap */, 0x82016 /* MTLHeapWrapper */ },
		{ 0x82316 /* Metal.IMTLIndirectCommandBuffer */, 0x82416 /* MTLIndirectCommandBufferWrapper */ },
		{ 0x82716 /* Metal.IMTLIndirectRenderCommand */, 0x82816 /* MTLIndirectRenderCommandWrapper */ },
		{ 0x82A16 /* Metal.IMTLLibrary */, 0x82C16 /* MTLLibraryWrapper */ },
		{ 0x83316 /* Metal.IMTLParallelRenderCommandEncoder */, 0x83516 /* MTLParallelRenderCommandEncoderWrapper */ },
		{ 0x84016 /* Metal.IMTLRenderCommandEncoder */, 0x84216 /* MTLRenderCommandEncoderWrapper */ },
		{ 0x84F16 /* Metal.IMTLRenderPipelineState */, 0x85116 /* MTLRenderPipelineStateWrapper */ },
		{ 0x85316 /* Metal.IMTLResource */, 0x85516 /* MTLResourceWrapper */ },
		{ 0x85D16 /* Metal.IMTLSamplerState */, 0x85E16 /* MTLSamplerStateWrapper */ },
		{ 0x85F16 /* Metal.IMTLSharedEvent */, 0x86016 /* MTLSharedEventWrapper */ },
		{ 0x87116 /* Metal.IMTLTexture */, 0x87316 /* MTLTextureWrapper */ },
		{ 0x8D116 /* MapKit.IMKAnnotation */, 0x8D316 /* MKAnnotationWrapper */ },
		{ 0x8E916 /* MapKit.IMKLocalSearchCompleterDelegate */, 0x8EB16 /* MKLocalSearchCompleterDelegateWrapper */ },
		{ 0x8FF16 /* MapKit.IMKMapViewDelegate */, 0x90116 /* MKMapViewDelegateWrapper */ },
		{ 0x90416 /* MapKit.IMKOverlay */, 0x90616 /* MKOverlayWrapper */ },
		{ 0x93816 /* JavaScriptCore.IJSExport */, 0x93916 /* JSExportWrapper */ },
		{ 0x96A16 /* Intents.IINCallsDomainHandling */, 0x96B16 /* INCallsDomainHandlingWrapper */ },
		{ 0x98D16 /* Intents.IINSearchCallHistoryIntentHandling */, 0x98F16 /* INSearchCallHistoryIntentHandlingWrapper */ },
		{ 0x99316 /* Intents.IINSearchForMessagesIntentHandling */, 0x99516 /* INSearchForMessagesIntentHandlingWrapper */ },
		{ 0x99916 /* Intents.IINSendMessageIntentHandling */, 0x99B16 /* INSendMessageIntentHandlingWrapper */ },
		{ 0x9A116 /* Intents.IINSpeakable */, 0x9A316 /* INSpeakableWrapper */ },
		{ 0x9A716 /* Intents.IINStartAudioCallIntentHandling */, 0x9A916 /* INStartAudioCallIntentHandlingWrapper */ },
		{ 0x9AD16 /* Intents.IINStartVideoCallIntentHandling */, 0x9AF16 /* INStartVideoCallIntentHandlingWrapper */ },
		{ 0x9B716 /* ImageKit.IIKCameraDeviceViewDelegate */, 0x9B916 /* IKCameraDeviceViewDelegateWrapper */ },
		{ 0x9BD16 /* ImageKit.IIKDeviceBrowserViewDelegate */, 0x9BF16 /* IKDeviceBrowserViewDelegateWrapper */ },
		{ 0x9C316 /* ImageKit.IIKFilterCustomUIProvider */, 0x9C416 /* IKFilterCustomUIProviderWrapper */ },
		{ 0x9D916 /* ImageKit.IIKImageEditPanelDataSource */, 0x9DB16 /* IKImageEditPanelDataSourceWrapper */ },
		{ 0x9EA16 /* ImageKit.IIKScannerDeviceViewDelegate */, 0x9EC16 /* IKScannerDeviceViewDelegateWrapper */ },
		{ 0x9EF16 /* ImageKit.IIKSlideshowDataSource */, 0x9F116 /* IKSlideshowDataSourceWrapper */ },
		{ 0xA2416 /* GLKit.IGLKNamedEffect */, 0xA2516 /* GLKNamedEffectWrapper */ },
		{ 0xA3E16 /* GameplayKit.IGKAgentDelegate */, 0xA4016 /* GKAgentDelegateWrapper */ },
		{ 0xA5016 /* GameplayKit.IGKGameModel */, 0xA5216 /* GKGameModelWrapper */ },
		{ 0xA5316 /* GameplayKit.IGKGameModelPlayer */, 0xA5516 /* GKGameModelPlayerWrapper */ },
		{ 0xA5616 /* GameplayKit.IGKGameModelUpdate */, 0xA5716 /* GKGameModelUpdateWrapper */ },
		{ 0xA7316 /* GameplayKit.IGKRandom */, 0xA7416 /* GKRandomWrapper */ },
		{ 0xA7D16 /* GameplayKit.IGKSceneRootNodeType */, 0xA7E16 /* GKSceneRootNodeTypeWrapper */ },
		{ 0xA8616 /* GameplayKit.IGKStrategist */, 0xA8716 /* GKStrategistWrapper */ },
		{ 0xA9616 /* GameKit.IGKAchievementViewControllerDelegate */, 0xA9716 /* GKAchievementViewControllerDelegateWrapper */ },
		{ 0xA9D16 /* GameKit.IGKChallengeEventHandlerDelegate */, 0xA9F16 /* GKChallengeEventHandlerDelegateWrapper */ },
		{ 0xAA116 /* GameKit.IGKChallengeListener */, 0xAA316 /* GKChallengeListenerWrapper */ },
		{ 0xAA716 /* GameKit.IGKChallengesViewControllerDelegate */, 0xAA816 /* GKChallengesViewControllerDelegateWrapper */ },
		{ 0xAB016 /* GameKit.IGKFriendRequestComposeViewControllerDelegate */, 0xAB116 /* GKFriendRequestComposeViewControllerDelegateWrapper */ },
		{ 0xAB316 /* GameKit.IGKGameCenterControllerDelegate */, 0xAB416 /* GKGameCenterControllerDelegateWrapper */ },
		{ 0xABB16 /* GameKit.IGKGameSessionEventListener */, 0xABD16 /* GKGameSessionEventListenerWrapper */ },
		{ 0xAC016 /* GameKit.IGKInviteEventListener */, 0xAC216 /* GKInviteEventListenerWrapper */ },
		{ 0xACB16 /* GameKit.IGKLeaderboardViewControllerDelegate */, 0xACC16 /* GKLeaderboardViewControllerDelegateWrapper */ },
		{ 0xAD016 /* GameKit.IGKLocalPlayerListener */, 0xAD116 /* GKLocalPlayerListenerWrapper */ },
		{ 0xADB16 /* GameKit.IGKMatchDelegate */, 0xADD16 /* GKMatchDelegateWrapper */ },
		{ 0xAE616 /* GameKit.IGKMatchmakerViewControllerDelegate */, 0xAE816 /* GKMatchmakerViewControllerDelegateWrapper */ },
		{ 0xAF316 /* GameKit.IGKSavedGameListener */, 0xAF516 /* GKSavedGameListenerWrapper */ },
		{ 0xAFB16 /* GameKit.IGKSessionDelegate */, 0xAFD16 /* GKSessionDelegateWrapper */ },
		{ 0xB0216 /* GameKit.IGKTurnBasedEventHandlerDelegate */, 0xB0416 /* GKTurnBasedEventHandlerDelegateWrapper */ },
		{ 0xB0616 /* GameKit.IGKTurnBasedEventListener */, 0xB0816 /* GKTurnBasedEventListenerWrapper */ },
		{ 0xB0F16 /* GameKit.IGKTurnBasedMatchmakerViewControllerDelegate */, 0xB1016 /* GKTurnBasedMatchmakerViewControllerDelegateWrapper */ },
		{ 0xB1616 /* GameKit.IGKViewController */, 0xB1716 /* GKViewControllerWrapper */ },
		{ 0xB4916 /* FinderSync.IFIFinderSyncProtocol */, 0xB4B16 /* FIFinderSyncProtocolWrapper */ },
		{ 0xB4F16 /* ExternalAccessory.IEAAccessoryDelegate */, 0xB5116 /* EAAccessoryDelegateWrapper */ },
		{ 0xB7E16 /* CoreWlan.ICWEventDelegate */, 0xB8016 /* CWEventDelegateWrapper */ },
		{ 0xC3D16 /* CoreSpotlight.ICSSearchableIndexDelegate */, 0xC3F16 /* CSSearchableIndexDelegateWrapper */ },
		{ 0xC5616 /* CoreML.IMLBatchProvider */, 0xC5716 /* MLBatchProviderWrapper */ },
		{ 0xC5916 /* CoreML.IMLCustomLayer */, 0xC5B16 /* MLCustomLayerWrapper */ },
		{ 0xC5C16 /* CoreML.IMLCustomModel */, 0xC5E16 /* MLCustomModelWrapper */ },
		{ 0xC6316 /* CoreML.IMLFeatureProvider */, 0xC6416 /* MLFeatureProviderWrapper */ },
		{ 0xCDB16 /* CoreLocation.ICLLocationManagerDelegate */, 0xCDD16 /* CLLocationManagerDelegateWrapper */ },
		{ 0xD5716 /* CoreImage.ICIFilterConstructor */, 0xD5816 /* CIFilterConstructorWrapper */ },
		{ 0xD7816 /* CoreImage.ICIImageProcessorInput */, 0xD7A16 /* CIImageProcessorInputWrapper */ },
		{ 0xD7C16 /* CoreImage.ICIImageProcessorOutput */, 0xD7E16 /* CIImageProcessorOutputWrapper */ },
		{ 0xECE16 /* CoreData.INSFetchRequestResult */, 0xECF16 /* NSFetchRequestResultWrapper */ },
		{ 0xF0A16 /* CoreBluetooth.ICBCentralManagerDelegate */, 0xF0C16 /* CBCentralManagerDelegateWrapper */ },
		{ 0xF2316 /* CoreBluetooth.ICBPeripheralDelegate */, 0xF2516 /* CBPeripheralDelegateWrapper */ },
		{ 0xF3016 /* CoreBluetooth.ICBPeripheralManagerDelegate */, 0xF3216 /* CBPeripheralManagerDelegateWrapper */ },
		{ 0xF4016 /* CoreAudioKit.IAUCustomViewPersistentData */, 0xF4116 /* AUCustomViewPersistentDataWrapper */ },
		{ 0xF4916 /* CoreAnimation.ICAAction */, 0xF4A16 /* CAActionWrapper */ },
		{ 0xF4D16 /* CoreAnimation.ICAAnimationDelegate */, 0xF4F16 /* CAAnimationDelegateWrapper */ },
		{ 0xF6016 /* CoreAnimation.ICALayerDelegate */, 0xF6216 /* CALayerDelegateWrapper */ },
		{ 0xF6416 /* CoreAnimation.ICAMediaTiming */, 0xF6516 /* CAMediaTimingWrapper */ },
		{ 0xF6816 /* CoreAnimation.ICAMetalDrawable */, 0xF6916 /* CAMetalDrawableWrapper */ },
		{ 0xF8716 /* ContactsUI.ICNContactPickerDelegate */, 0xF8916 /* CNContactPickerDelegateWrapper */ },
		{ 0xFA816 /* Contacts.ICNKeyDescriptor */, 0xFA916 /* CNKeyDescriptorWrapper */ },
		{ 0xFFB16 /* CloudKit.ICKRecordValue */, 0xFFC16 /* CKRecordValueWrapper */ },
		{ 0x102B16 /* AVKit.IAVCaptureViewDelegate */, 0x102C16 /* AVCaptureViewDelegateWrapper */ },
		{ 0x104616 /* AVFoundation.IAVAssetResourceLoaderDelegate */, 0x104816 /* AVAssetResourceLoaderDelegateWrapper */ },
		{ 0x105D16 /* AVFoundation.IAVAsynchronousKeyValueLoading */, 0x105E16 /* AVAsynchronousKeyValueLoadingWrapper */ },
		{ 0x106116 /* AVFoundation.IAVAudio3DMixing */, 0x106216 /* AVAudio3DMixingWrapper */ },
		{ 0x107D16 /* AVFoundation.IAVAudioMixing */, 0x107F16 /* AVAudioMixingWrapper */ },
		{ 0x108616 /* AVFoundation.IAVAudioPlayerDelegate */, 0x108816 /* AVAudioPlayerDelegateWrapper */ },
		{ 0x108F16 /* AVFoundation.IAVAudioRecorderDelegate */, 0x109116 /* AVAudioRecorderDelegateWrapper */ },
		{ 0x10A116 /* AVFoundation.IAVAudioStereoMixing */, 0x10A216 /* AVAudioStereoMixingWrapper */ },
		{ 0x10BF16 /* AVFoundation.IAVCaptureAudioDataOutputSampleBufferDelegate */, 0x10C116 /* AVCaptureAudioDataOutputSampleBufferDelegateWrapper */ },
		{ 0x10D016 /* AVFoundation.IAVCaptureFileOutputDelegate */, 0x10D216 /* AVCaptureFileOutputDelegateWrapper */ },
		{ 0x10D416 /* AVFoundation.IAVCaptureFileOutputRecordingDelegate */, 0x10D616 /* AVCaptureFileOutputRecordingDelegateWrapper */ },
		{ 0x10E716 /* AVFoundation.IAVCaptureVideoDataOutputSampleBufferDelegate */, 0x10E916 /* AVCaptureVideoDataOutputSampleBufferDelegateWrapper */ },
		{ 0x10FA16 /* AVFoundation.IAVContentKeyRecipient */, 0x10FB16 /* AVContentKeyRecipientWrapper */ },
		{ 0x110416 /* AVFoundation.IAVContentKeySessionDelegate */, 0x110616 /* AVContentKeySessionDelegateWrapper */ },
		{ 0x111B16 /* AVFoundation.IAVFragmentMinding */, 0x111D16 /* AVFragmentMindingWrapper */ },
		{ 0x115E16 /* AVFoundation.IAVPlayerItemLegibleOutputPushDelegate */, 0x116016 /* AVPlayerItemLegibleOutputPushDelegateWrapper */ },
		{ 0x116416 /* AVFoundation.IAVPlayerItemMetadataCollectorPushDelegate */, 0x116516 /* AVPlayerItemMetadataCollectorPushDelegateWrapper */ },
		{ 0x116816 /* AVFoundation.IAVPlayerItemMetadataOutputPushDelegate */, 0x116A16 /* AVPlayerItemMetadataOutputPushDelegateWrapper */ },
		{ 0x116D16 /* AVFoundation.IAVPlayerItemOutputPullDelegate */, 0x116F16 /* AVPlayerItemOutputPullDelegateWrapper */ },
		{ 0x117116 /* AVFoundation.IAVPlayerItemOutputPushDelegate */, 0x117316 /* AVPlayerItemOutputPushDelegateWrapper */ },
		{ 0x118116 /* AVFoundation.IAVQueuedSampleBufferRendering */, 0x118216 /* AVQueuedSampleBufferRenderingWrapper */ },
		{ 0x119B16 /* AVFoundation.IAVVideoCompositing */, 0x119D16 /* AVVideoCompositingWrapper */ },
		{ 0x11A416 /* AVFoundation.IAVVideoCompositionValidationHandling */, 0x11A616 /* AVVideoCompositionValidationHandlingWrapper */ },
		{ 0x11E016 /* AudioUnit.IAUAudioUnitFactory */, 0x11E116 /* AUAudioUnitFactoryWrapper */ },
		{ 0x124A16 /* AppKit.INSAccessibility */, 0x124C16 /* NSAccessibilityWrapper */ },
		{ 0x125016 /* AppKit.INSAccessibilityButton */, 0x125116 /* NSAccessibilityButtonWrapper */ },
		{ 0x125216 /* AppKit.INSAccessibilityContainsTransientUI */, 0x125316 /* NSAccessibilityContainsTransientUIWrapper */ },
		{ 0x125716 /* AppKit.INSAccessibilityCustomRotorItemSearchDelegate */, 0x125816 /* NSAccessibilityCustomRotorItemSearchDelegateWrapper */ },
		{ 0x125C16 /* AppKit.INSAccessibilityElementLoading */, 0x125E16 /* NSAccessibilityElementLoadingWrapper */ },
		{ 0x125F16 /* AppKit.INSAccessibilityElementProtocol */, 0x126116 /* NSAccessibilityElementProtocolWrapper */ },
		{ 0x126316 /* AppKit.INSAccessibilityGroup */, 0x126416 /* NSAccessibilityGroupWrapper */ },
		{ 0x126516 /* AppKit.INSAccessibilityImage */, 0x126616 /* NSAccessibilityImageWrapper */ },
		{ 0x126716 /* AppKit.INSAccessibilityLayoutArea */, 0x126816 /* NSAccessibilityLayoutAreaWrapper */ },
		{ 0x126916 /* AppKit.INSAccessibilityLayoutItem */, 0x126B16 /* NSAccessibilityLayoutItemWrapper */ },
		{ 0x126C16 /* AppKit.INSAccessibilityNavigableStaticText */, 0x126D16 /* NSAccessibilityNavigableStaticTextWrapper */ },
		{ 0x127016 /* AppKit.INSAccessibilityProgressIndicator */, 0x127116 /* NSAccessibilityProgressIndicatorWrapper */ },
		{ 0x127216 /* AppKit.INSAccessibilityRadioButton */, 0x127316 /* NSAccessibilityRadioButtonWrapper */ },
		{ 0x127516 /* AppKit.INSAccessibilityRow */, 0x127716 /* NSAccessibilityRowWrapper */ },
		{ 0x127816 /* AppKit.INSAccessibilitySlider */, 0x127916 /* NSAccessibilitySliderWrapper */ },
		{ 0x127A16 /* AppKit.INSAccessibilityStaticText */, 0x127C16 /* NSAccessibilityStaticTextWrapper */ },
		{ 0x127D16 /* AppKit.INSAccessibilityStepper */, 0x127F16 /* NSAccessibilityStepperWrapper */ },
		{ 0x128116 /* AppKit.INSAccessibilitySwitch */, 0x128316 /* NSAccessibilitySwitchWrapper */ },
		{ 0x128416 /* AppKit.INSAccessibilityTable */, 0x128616 /* NSAccessibilityTableWrapper */ },
		{ 0x128916 /* AppKit.INSAlertDelegate */, 0x128B16 /* NSAlertDelegateWrapper */ },
		{ 0x128E16 /* AppKit.INSAlignmentFeedbackToken */, 0x128F16 /* NSAlignmentFeedbackTokenWrapper */ },
		{ 0x129416 /* AppKit.INSAnimationDelegate */, 0x129616 /* NSAnimationDelegateWrapper */ },
		{ 0x129916 /* AppKit.INSAppearanceCustomization */, 0x129B16 /* NSAppearanceCustomizationWrapper */ },
		{ 0x12A816 /* AppKit.INSApplicationDelegate */, 0x12AA16 /* NSApplicationDelegateWrapper */ },
		{ 0x12B416 /* AppKit.INSBrowserDelegate */, 0x12B616 /* NSBrowserDelegateWrapper */ },
		{ 0x12BC16 /* AppKit.INSCandidateListTouchBarItemDelegate */, 0x12BE16 /* NSCandidateListTouchBarItemDelegateWrapper */ },
		{ 0x12C416 /* AppKit.INSCloudSharingServiceDelegate */, 0x12C616 /* NSCloudSharingServiceDelegateWrapper */ },
		{ 0x12C816 /* AppKit.INSCloudSharingValidation */, 0x12C916 /* NSCloudSharingValidationWrapper */ },
		{ 0x12CD16 /* AppKit.INSCollectionViewDataSource */, 0x12CF16 /* NSCollectionViewDataSourceWrapper */ },
		{ 0x12D116 /* AppKit.INSCollectionViewDelegate */, 0x12D316 /* NSCollectionViewDelegateWrapper */ },
		{ 0x12D516 /* AppKit.INSCollectionViewDelegateFlowLayout */, 0x12D716 /* NSCollectionViewDelegateFlowLayoutWrapper */ },
		{ 0x12D916 /* AppKit.INSCollectionViewElement */, 0x12DB16 /* NSCollectionViewElementWrapper */ },
		{ 0x12E416 /* AppKit.INSCollectionViewPrefetching */, 0x12E616 /* NSCollectionViewPrefetchingWrapper */ },
		{ 0x12E716 /* AppKit.INSCollectionViewSectionHeaderView */, 0x12E916 /* NSCollectionViewSectionHeaderViewWrapper */ },
		{ 0x12ED16 /* AppKit.INSColorChanging */, 0x12EE16 /* NSColorChangingWrapper */ },
		{ 0x12F716 /* AppKit.INSComboBoxCellDataSource */, 0x12F916 /* NSComboBoxCellDataSourceWrapper */ },
		{ 0x12FB16 /* AppKit.INSComboBoxDataSource */, 0x12FD16 /* NSComboBoxDataSourceWrapper */ },
		{ 0x12FF16 /* AppKit.INSComboBoxDelegate */, 0x130116 /* NSComboBoxDelegateWrapper */ },
		{ 0x130616 /* AppKit.INSControlTextEditingDelegate */, 0x130816 /* NSControlTextEditingDelegateWrapper */ },
		{ 0x131116 /* AppKit.INSDatePickerCellDelegate */, 0x131316 /* NSDatePickerCellDelegateWrapper */ },
		{ 0x131816 /* AppKit.INSDockTilePlugIn */, 0x131916 /* NSDockTilePlugInWrapper */ },
		{ 0x131D16 /* AppKit.INSDraggingDestination */, 0x131F16 /* NSDraggingDestinationWrapper */ },
		{ 0x132216 /* AppKit.INSDraggingInfo */, 0x132416 /* NSDraggingInfoWrapper */ },
		{ 0x132816 /* AppKit.INSDraggingSource */, 0x132A16 /* NSDraggingSourceWrapper */ },
		{ 0x132D16 /* AppKit.INSDrawerDelegate */, 0x132F16 /* NSDrawerDelegateWrapper */ },
		{ 0x133116 /* AppKit.INSEditor */, 0x133216 /* NSEditorWrapper */ },
		{ 0x133316 /* AppKit.INSEditorRegistration */, 0x133516 /* NSEditorRegistrationWrapper */ },
		{ 0x133A16 /* AppKit.INSFilePromiseProviderDelegate */, 0x133C16 /* NSFilePromiseProviderDelegateWrapper */ },
		{ 0x134016 /* AppKit.INSFontChanging */, 0x134216 /* NSFontChangingWrapper */ },
		{ 0x134C16 /* AppKit.INSGestureRecognizerDelegate */, 0x134E16 /* NSGestureRecognizerDelegateWrapper */ },
		{ 0x135A16 /* AppKit.INSHapticFeedbackPerformer */, 0x135B16 /* NSHapticFeedbackPerformerWrapper */ },
		{ 0x136316 /* AppKit.INSImageDelegate */, 0x136516 /* NSImageDelegateWrapper */ },
		{ 0x137416 /* AppKit.INSLayoutManagerDelegate */, 0x137616 /* NSLayoutManagerDelegateWrapper */ },
		{ 0x137E16 /* AppKit.INSMatrixDelegate */, 0x137F16 /* NSMatrixDelegateWrapper */ },
		{ 0x138216 /* AppKit.INSMenuDelegate */, 0x138416 /* NSMenuDelegateWrapper */ },
		{ 0x138816 /* AppKit.INSMenuItemValidation */, 0x138916 /* NSMenuItemValidationWrapper */ },
		{ 0x139B16 /* AppKit.INSOpenSavePanelDelegate */, 0x139D16 /* NSOpenSavePanelDelegateWrapper */ },
		{ 0x13A016 /* AppKit.INSOutlineViewDataSource */, 0x13A216 /* NSOutlineViewDataSourceWrapper */ },
		{ 0x13A416 /* AppKit.INSOutlineViewDelegate */, 0x13A616 /* NSOutlineViewDelegateWrapper */ },
		{ 0x13AB16 /* AppKit.INSPageControllerDelegate */, 0x13AD16 /* NSPageControllerDelegateWrapper */ },
		{ 0x13B516 /* AppKit.INSPasteboardItemDataProvider */, 0x13B616 /* NSPasteboardItemDataProviderWrapper */ },
		{ 0x13B816 /* AppKit.INSPasteboardReading */, 0x13B916 /* NSPasteboardReadingWrapper */ },
		{ 0x13BB16 /* AppKit.INSPasteboardTypeOwner */, 0x13BD16 /* NSPasteboardTypeOwnerWrapper */ },
		{ 0x13BE16 /* AppKit.INSPasteboardWriting */, 0x13C016 /* NSPasteboardWritingWrapper */ },
		{ 0x13C516 /* AppKit.INSPathCellDelegate */, 0x13C716 /* NSPathCellDelegateWrapper */ },
		{ 0x13CB16 /* AppKit.INSPathControlDelegate */, 0x13CD16 /* NSPathControlDelegateWrapper */ },
		{ 0x13D216 /* AppKit.INSPopoverDelegate */, 0x13D416 /* NSPopoverDelegateWrapper */ },
		{ 0x13E116 /* AppKit.INSPrintPanelAccessorizing */, 0x13E216 /* NSPrintPanelAccessorizingWrapper */ },
		{ 0x13ED16 /* AppKit.INSRuleEditorDelegate */, 0x13EF16 /* NSRuleEditorDelegateWrapper */ },
		{ 0x140016 /* AppKit.INSScrubberDataSource */, 0x140116 /* NSScrubberDataSourceWrapper */ },
		{ 0x140316 /* AppKit.INSScrubberDelegate */, 0x140516 /* NSScrubberDelegateWrapper */ },
		{ 0x140816 /* AppKit.INSScrubberFlowLayoutDelegate */, 0x140A16 /* NSScrubberFlowLayoutDelegateWrapper */ },
		{ 0x141616 /* AppKit.INSSearchFieldDelegate */, 0x141816 /* NSSearchFieldDelegateWrapper */ },
		{ 0x141F16 /* AppKit.INSSeguePerforming */, 0x142116 /* NSSeguePerformingWrapper */ },
		{ 0x142316 /* AppKit.INSServicesMenuRequestor */, 0x142516 /* NSServicesMenuRequestorWrapper */ },
		{ 0x142A16 /* AppKit.INSSharingServiceDelegate */, 0x142C16 /* NSSharingServiceDelegateWrapper */ },
		{ 0x143216 /* AppKit.INSSharingServicePickerDelegate */, 0x143416 /* NSSharingServicePickerDelegateWrapper */ },
		{ 0x143716 /* AppKit.INSSharingServicePickerTouchBarItemDelegate */, 0x143816 /* NSSharingServicePickerTouchBarItemDelegateWrapper */ },
		{ 0x144116 /* AppKit.INSSoundDelegate */, 0x144316 /* NSSoundDelegateWrapper */ },
		{ 0x144616 /* AppKit.INSSpeechRecognizerDelegate */, 0x144816 /* NSSpeechRecognizerDelegateWrapper */ },
		{ 0x144B16 /* AppKit.INSSpeechSynthesizerDelegate */, 0x144D16 /* NSSpeechSynthesizerDelegateWrapper */ },
		{ 0x145316 /* AppKit.INSSplitViewDelegate */, 0x145516 /* NSSplitViewDelegateWrapper */ },
		{ 0x145816 /* AppKit.INSSpringLoadingDestination */, 0x145A16 /* NSSpringLoadingDestinationWrapper */ },
		{ 0x145D16 /* AppKit.INSStackViewDelegate */, 0x145F16 /* NSStackViewDelegateWrapper */ },
		{ 0x146216 /* AppKit.INSStandardKeyBindingResponding */, 0x146416 /* NSStandardKeyBindingRespondingWrapper */ },
		{ 0x147916 /* AppKit.INSTableViewDataSource */, 0x147B16 /* NSTableViewDataSourceWrapper */ },
		{ 0x147D16 /* AppKit.INSTableViewDelegate */, 0x147F16 /* NSTableViewDelegateWrapper */ },
		{ 0x148616 /* AppKit.INSTabViewDelegate */, 0x148816 /* NSTabViewDelegateWrapper */ },
		{ 0x148F16 /* AppKit.INSTextAttachmentContainer */, 0x149016 /* NSTextAttachmentContainerWrapper */ },
		{ 0x149616 /* AppKit.INSTextDelegate */, 0x149816 /* NSTextDelegateWrapper */ },
		{ 0x149E16 /* AppKit.INSTextFieldDelegate */, 0x14A016 /* NSTextFieldDelegateWrapper */ },
		{ 0x14A316 /* AppKit.INSTextFinderBarContainer */, 0x14A516 /* NSTextFinderBarContainerWrapper */ },
		{ 0x14A716 /* AppKit.INSTextFinderClient */, 0x14A816 /* NSTextFinderClientWrapper */ },
		{ 0x14AB16 /* AppKit.INSTextInput */, 0x14AC16 /* NSTextInputWrapper */ },
		{ 0x14AD16 /* AppKit.INSTextInputClient */, 0x14AF16 /* NSTextInputClientWrapper */ },
		{ 0x14B716 /* AppKit.INSTextStorageDelegate */, 0x14B916 /* NSTextStorageDelegateWrapper */ },
		{ 0x14C316 /* AppKit.INSTextViewDelegate */, 0x14C516 /* NSTextViewDelegateWrapper */ },
		{ 0x14CA16 /* AppKit.INSTokenFieldCellDelegate */, 0x14CC16 /* NSTokenFieldCellDelegateWrapper */ },
		{ 0x14CE16 /* AppKit.INSTokenFieldDelegate */, 0x14D016 /* NSTokenFieldDelegateWrapper */ },
		{ 0x14D316 /* AppKit.INSToolbarDelegate */, 0x14D516 /* NSToolbarDelegateWrapper */ },
		{ 0x14D916 /* AppKit.INSToolbarItemValidation */, 0x14DA16 /* NSToolbarItemValidationWrapper */ },
		{ 0x14E016 /* AppKit.INSTouchBarDelegate */, 0x14E216 /* NSTouchBarDelegateWrapper */ },
		{ 0x14E716 /* AppKit.INSTouchBarProvider */, 0x14E816 /* NSTouchBarProviderWrapper */ },
		{ 0x14EE16 /* AppKit.INSUserInterfaceCompression */, 0x14EF16 /* NSUserInterfaceCompressionWrapper */ },
		{ 0x14F116 /* AppKit.INSUserInterfaceItemIdentification */, 0x14F316 /* NSUserInterfaceItemIdentificationWrapper */ },
		{ 0x14F416 /* AppKit.INSUserInterfaceValidations */, 0x14F516 /* NSUserInterfaceValidationsWrapper */ },
		{ 0x14F616 /* AppKit.INSValidatedUserInterfaceItem */, 0x14F716 /* NSValidatedUserInterfaceItemWrapper */ },
		{ 0x14FD16 /* AppKit.INSViewControllerPresentationAnimator */, 0x14FE16 /* NSViewControllerPresentationAnimatorWrapper */ },
		{ 0x150016 /* AppKit.INSViewToolTipOwner */, 0x150116 /* NSViewToolTipOwnerWrapper */ },
		{ 0x150716 /* AppKit.INSWindowDelegate */, 0x150916 /* NSWindowDelegateWrapper */ },
		{ 0x150B16 /* AppKit.INSWindowRestoration */, 0x150C16 /* NSWindowRestorationWrapper */ },
		{ 0x16EE16 /* Foundation.INSCacheDelegate */, 0x16F016 /* NSCacheDelegateWrapper */ },
		{ 0x16F716 /* Foundation.INSCoding */, 0x16F816 /* NSCodingWrapper */ },
		{ 0x16FF16 /* Foundation.INSConnectionDelegate */, 0x170116 /* NSConnectionDelegateWrapper */ },
		{ 0x170316 /* Foundation.INSCopying */, 0x170416 /* NSCopyingWrapper */ },
		{ 0x171216 /* Foundation.INSDiscardableContent */, 0x171316 /* NSDiscardableContentWrapper */ },
		{ 0x171E16 /* Foundation.INSExtensionRequestHandling */, 0x171F16 /* NSExtensionRequestHandlingWrapper */ },
		{ 0x172616 /* Foundation.INSFileManagerDelegate */, 0x172816 /* NSFileManagerDelegateWrapper */ },
		{ 0x172A16 /* Foundation.INSFilePresenter */, 0x172C16 /* NSFilePresenterWrapper */ },
		{ 0x173F16 /* Foundation.INSItemProviderReading */, 0x174016 /* NSItemProviderReadingWrapper */ },
		{ 0x174116 /* Foundation.INSItemProviderWriting */, 0x174316 /* NSItemProviderWritingWrapper */ },
		{ 0x174816 /* Foundation.INSKeyedArchiverDelegate */, 0x174A16 /* NSKeyedArchiverDelegateWrapper */ },
		{ 0x174D16 /* Foundation.INSKeyedUnarchiverDelegate */, 0x174F16 /* NSKeyedUnarchiverDelegateWrapper */ },
		{ 0x175D16 /* Foundation.INSLocking */, 0x175E16 /* NSLockingWrapper */ },
		{ 0x176016 /* Foundation.INSMachPortDelegate */, 0x176216 /* NSMachPortDelegateWrapper */ },
		{ 0x176A16 /* Foundation.INSMetadataQueryDelegate */, 0x176C16 /* NSMetadataQueryDelegateWrapper */ },
		{ 0x177316 /* Foundation.INSMutableCopying */, 0x177416 /* NSMutableCopyingWrapper */ },
		{ 0x178416 /* Foundation.INSNetServiceBrowserDelegate */, 0x178616 /* NSNetServiceBrowserDelegateWrapper */ },
		{ 0x178816 /* Foundation.INSNetServiceDelegate */, 0x178A16 /* NSNetServiceDelegateWrapper */ },
		{ 0x179316 /* Foundation.INSObjectProtocol */, 0x179516 /* NSObjectProtocolWrapper */ },
		{ 0x17A016 /* Foundation.INSPortDelegate */, 0x17A216 /* NSPortDelegateWrapper */ },
		{ 0x17B016 /* Foundation.INSProgressReporting */, 0x17B216 /* NSProgressReportingWrapper */ },
		{ 0x17BE16 /* Foundation.INSSecureCoding */, 0x17BF16 /* NSSecureCodingWrapper */ },
		{ 0x17C616 /* Foundation.INSStreamDelegate */, 0x17C816 /* NSStreamDelegateWrapper */ },
		{ 0x17F216 /* Foundation.INSURLAuthenticationChallengeSender */, 0x17F416 /* NSURLAuthenticationChallengeSenderWrapper */ },
		{ 0x17FA16 /* Foundation.INSUrlConnectionDataDelegate */, 0x17FC16 /* NSUrlConnectionDataDelegateWrapper */ },
		{ 0x17FE16 /* Foundation.INSUrlConnectionDelegate */, 0x180016 /* NSUrlConnectionDelegateWrapper */ },
		{ 0x180216 /* Foundation.INSUrlConnectionDownloadDelegate */, 0x180416 /* NSUrlConnectionDownloadDelegateWrapper */ },
		{ 0x180916 /* Foundation.INSUrlDownloadDelegate */, 0x180B16 /* NSUrlDownloadDelegateWrapper */ },
		{ 0x180F16 /* Foundation.INSUrlProtocolClient */, 0x181016 /* NSUrlProtocolClientWrapper */ },
		{ 0x181B16 /* Foundation.INSUrlSessionDataDelegate */, 0x181D16 /* NSUrlSessionDataDelegateWrapper */ },
		{ 0x182016 /* Foundation.INSUrlSessionDelegate */, 0x182216 /* NSUrlSessionDelegateWrapper */ },
		{ 0x182416 /* Foundation.INSUrlSessionDownloadDelegate */, 0x182616 /* NSUrlSessionDownloadDelegateWrapper */ },
		{ 0x182916 /* Foundation.INSUrlSessionStreamDelegate */, 0x182B16 /* NSUrlSessionStreamDelegateWrapper */ },
		{ 0x183016 /* Foundation.INSUrlSessionTaskDelegate */, 0x183216 /* NSUrlSessionTaskDelegateWrapper */ },
		{ 0x183C16 /* Foundation.INSUserActivityDelegate */, 0x183E16 /* NSUserActivityDelegateWrapper */ },
		{ 0x184716 /* Foundation.INSUserNotificationCenterDelegate */, 0x184916 /* NSUserNotificationCenterDelegateWrapper */ },
	};

	static struct MTRegistrationMap __xamarin_registration_map = {
		__xamarin_registration_assemblies,
		__xamarin_class_map,
		NULL,
		__xamarin_skipped_map,
		__xamarin_protocol_wrapper_map,
		{ NULL, NULL },
		14,
		2421,
		87,
		0,
		10,
		353,
		0
	};

void xamarin_create_classes () {
	__xamarin_class_map [0].handle = objc_getClass ("NSObject");
	__xamarin_class_map [1].handle = objc_getClass ("VSAccountManager");
	__xamarin_class_map [2].handle = objc_getClass ("VSAccountManagerDelegate");
	__xamarin_class_map [3].handle = objc_getClass ("VSAccountManagerResult");
	__xamarin_class_map [4].handle = objc_getClass ("VSAccountMetadata");
	__xamarin_class_map [5].handle = objc_getClass ("VSAccountMetadataRequest");
	__xamarin_class_map [6].handle = objc_getClass ("VSAccountProviderResponse");
	__xamarin_class_map [7].handle = objc_getClass ("VSSubscription");
	__xamarin_class_map [8].handle = objc_getClass ("VSSubscriptionRegistrationCenter");
	__xamarin_class_map [9].handle = objc_getClass ("UNNotificationTrigger");
	__xamarin_class_map [10].handle = objc_getClass ("UNCalendarNotificationTrigger");
	__xamarin_class_map [11].handle = objc_getClass ("UNNotificationContent");
	__xamarin_class_map [12].handle = objc_getClass ("UNMutableNotificationContent");
	__xamarin_class_map [13].handle = objc_getClass ("UNNotification");
	__xamarin_class_map [14].handle = objc_getClass ("UNNotificationAction");
	__xamarin_class_map [15].handle = objc_getClass ("UNNotificationAttachment");
	__xamarin_class_map [16].handle = objc_getClass ("UNNotificationCategory");
	__xamarin_class_map [17].handle = objc_getClass ("UNNotificationRequest");
	__xamarin_class_map [18].handle = objc_getClass ("UNNotificationResponse");
	__xamarin_class_map [19].handle = objc_getClass ("UNNotificationServiceExtension");
	__xamarin_class_map [20].handle = objc_getClass ("UNNotificationSettings");
	__xamarin_class_map [21].handle = objc_getClass ("UNNotificationSound");
	__xamarin_class_map [22].handle = objc_getClass ("UNPushNotificationTrigger");
	__xamarin_class_map [23].handle = objc_getClass ("UNTextInputNotificationAction");
	__xamarin_class_map [24].handle = objc_getClass ("UNTextInputNotificationResponse");
	__xamarin_class_map [25].handle = objc_getClass ("UNTimeIntervalNotificationTrigger");
	__xamarin_class_map [26].handle = objc_getClass ("UNUserNotificationCenterDelegate");
	__xamarin_class_map [27].handle = objc_getClass ("WebScriptObject");
	__xamarin_class_map [28].handle = objc_getClass ("DOMObject");
	__xamarin_class_map [29].handle = objc_getClass ("DOMAbstractView");
	__xamarin_class_map [30].handle = objc_getClass ("DOMNode");
	__xamarin_class_map [31].handle = objc_getClass ("DOMAttr");
	__xamarin_class_map [32].handle = objc_getClass ("DOMBlob");
	__xamarin_class_map [33].handle = objc_getClass ("DOMCharacterData");
	__xamarin_class_map [34].handle = objc_getClass ("DOMText");
	__xamarin_class_map [35].handle = objc_getClass ("DOMCDATASection");
	__xamarin_class_map [36].handle = objc_getClass ("DOMComment");
	__xamarin_class_map [37].handle = objc_getClass ("DOMCSSRule");
	__xamarin_class_map [38].handle = objc_getClass ("DOMCSSCharsetRule");
	__xamarin_class_map [39].handle = objc_getClass ("DOMCSSFontFaceRule");
	__xamarin_class_map [40].handle = objc_getClass ("DOMCSSMediaRule");
	__xamarin_class_map [41].handle = objc_getClass ("DOMCSSPageRule");
	__xamarin_class_map [42].handle = objc_getClass ("DOMCSSRuleList");
	__xamarin_class_map [43].handle = objc_getClass ("DOMCSSStyleDeclaration");
	__xamarin_class_map [44].handle = objc_getClass ("DOMCSSStyleRule");
	__xamarin_class_map [45].handle = objc_getClass ("DOMStyleSheet");
	__xamarin_class_map [46].handle = objc_getClass ("DOMCSSStyleSheet");
	__xamarin_class_map [47].handle = objc_getClass ("DOMCSSUnknownRule");
	__xamarin_class_map [48].handle = objc_getClass ("DOMCSSValue");
	__xamarin_class_map [49].handle = objc_getClass ("DOMDocument");
	__xamarin_class_map [50].handle = objc_getClass ("DOMDocumentFragment");
	__xamarin_class_map [51].handle = objc_getClass ("DOMDocumentType");
	__xamarin_class_map [52].handle = objc_getClass ("DOMElement");
	__xamarin_class_map [53].handle = objc_getClass ("DOMEntityReference");
	__xamarin_class_map [54].handle = objc_getClass ("DOMEvent");
	__xamarin_class_map [55].handle = objc_getClass ("DOMEventListener");
	__xamarin_class_map [56].handle = objc_getClass ("DOMEventTarget");
	__xamarin_class_map [57].handle = objc_getClass ("DOMFile");
	__xamarin_class_map [58].handle = objc_getClass ("DOMFileList");
	__xamarin_class_map [59].handle = objc_getClass ("DOMHTMLElement");
	__xamarin_class_map [60].handle = objc_getClass ("DOMHTMLAnchorElement");
	__xamarin_class_map [61].handle = objc_getClass ("DOMHTMLAppletElement");
	__xamarin_class_map [62].handle = objc_getClass ("DOMHTMLAreaElement");
	__xamarin_class_map [63].handle = objc_getClass ("DOMHTMLBaseElement");
	__xamarin_class_map [64].handle = objc_getClass ("DOMHTMLBaseFontElement");
	__xamarin_class_map [65].handle = objc_getClass ("DOMHTMLBodyElement");
	__xamarin_class_map [66].handle = objc_getClass ("DOMHTMLBRElement");
	__xamarin_class_map [67].handle = objc_getClass ("DOMHTMLButtonElement");
	__xamarin_class_map [68].handle = objc_getClass ("DOMHTMLCollection");
	__xamarin_class_map [69].handle = objc_getClass ("DOMHTMLDirectoryElement");
	__xamarin_class_map [70].handle = objc_getClass ("DOMHTMLDivElement");
	__xamarin_class_map [71].handle = objc_getClass ("DOMHTMLDListElement");
	__xamarin_class_map [72].handle = objc_getClass ("DOMHTMLDocument");
	__xamarin_class_map [73].handle = objc_getClass ("DOMHTMLEmbedElement");
	__xamarin_class_map [74].handle = objc_getClass ("DOMHTMLFieldSetElement");
	__xamarin_class_map [75].handle = objc_getClass ("DOMHTMLFontElement");
	__xamarin_class_map [76].handle = objc_getClass ("DOMHTMLFormElement");
	__xamarin_class_map [77].handle = objc_getClass ("DOMHTMLFrameElement");
	__xamarin_class_map [78].handle = objc_getClass ("DOMHTMLFrameSetElement");
	__xamarin_class_map [79].handle = objc_getClass ("DOMHTMLHeadElement");
	__xamarin_class_map [80].handle = objc_getClass ("DOMHTMLHeadingElement");
	__xamarin_class_map [81].handle = objc_getClass ("DOMHTMLHRElement");
	__xamarin_class_map [82].handle = objc_getClass ("DOMHTMLHtmlElement");
	__xamarin_class_map [83].handle = objc_getClass ("DOMHTMLIFrameElement");
	__xamarin_class_map [84].handle = objc_getClass ("DOMHTMLImageElement");
	__xamarin_class_map [85].handle = objc_getClass ("DOMHTMLInputElement");
	__xamarin_class_map [86].handle = objc_getClass ("DOMHTMLLabelElement");
	__xamarin_class_map [87].handle = objc_getClass ("DOMHTMLLegendElement");
	__xamarin_class_map [88].handle = objc_getClass ("DOMHTMLLIElement");
	__xamarin_class_map [89].handle = objc_getClass ("DOMHTMLLinkElement");
	__xamarin_class_map [90].handle = objc_getClass ("DOMHTMLMapElement");
	__xamarin_class_map [91].handle = objc_getClass ("DOMHTMLMarqueeElement");
	__xamarin_class_map [92].handle = objc_getClass ("DOMHTMLMenuElement");
	__xamarin_class_map [93].handle = objc_getClass ("DOMHTMLMetaElement");
	__xamarin_class_map [94].handle = objc_getClass ("DOMHTMLModElement");
	__xamarin_class_map [95].handle = objc_getClass ("DOMHTMLObjectElement");
	__xamarin_class_map [96].handle = objc_getClass ("DOMHTMLOListElement");
	__xamarin_class_map [97].handle = objc_getClass ("DOMHTMLOptGroupElement");
	__xamarin_class_map [98].handle = objc_getClass ("DOMHTMLOptionElement");
	__xamarin_class_map [99].handle = objc_getClass ("DOMHTMLOptionsCollection");
	__xamarin_class_map [100].handle = objc_getClass ("DOMHTMLParagraphElement");
	__xamarin_class_map [101].handle = objc_getClass ("DOMHTMLParamElement");
	__xamarin_class_map [102].handle = objc_getClass ("DOMHTMLPreElement");
	__xamarin_class_map [103].handle = objc_getClass ("DOMHTMLQuoteElement");
	__xamarin_class_map [104].handle = objc_getClass ("DOMHTMLScriptElement");
	__xamarin_class_map [105].handle = objc_getClass ("DOMHTMLSelectElement");
	__xamarin_class_map [106].handle = objc_getClass ("DOMHTMLStyleElement");
	__xamarin_class_map [107].handle = objc_getClass ("DOMHTMLTableCaptionElement");
	__xamarin_class_map [108].handle = objc_getClass ("DOMHTMLTableCellElement");
	__xamarin_class_map [109].handle = objc_getClass ("DOMHTMLTableColElement");
	__xamarin_class_map [110].handle = objc_getClass ("DOMHTMLTableElement");
	__xamarin_class_map [111].handle = objc_getClass ("DOMHTMLTableRowElement");
	__xamarin_class_map [112].handle = objc_getClass ("DOMHTMLTableSectionElement");
	__xamarin_class_map [113].handle = objc_getClass ("DOMHTMLTextAreaElement");
	__xamarin_class_map [114].handle = objc_getClass ("DOMImplementation");
	__xamarin_class_map [115].handle = objc_getClass ("DOMCSSImportRule");
	__xamarin_class_map [116].handle = objc_getClass ("DOMUIEvent");
	__xamarin_class_map [117].handle = objc_getClass ("DOMKeyboardEvent");
	__xamarin_class_map [118].handle = objc_getClass ("DOMMediaList");
	__xamarin_class_map [119].handle = objc_getClass ("DOMMouseEvent");
	__xamarin_class_map [120].handle = objc_getClass ("DOMNamedNodeMap");
	__xamarin_class_map [121].handle = objc_getClass ("Xamarin_Mac__WebKit_DomNodeFilter");
	__xamarin_class_map [122].handle = objc_getClass ("DOMNodeIterator");
	__xamarin_class_map [123].handle = objc_getClass ("DOMNodeList");
	__xamarin_class_map [124].handle = objc_getClass ("DOMOverflowEvent");
	__xamarin_class_map [125].handle = objc_getClass ("DOMProcessingInstruction");
	__xamarin_class_map [126].handle = objc_getClass ("DOMProgressEvent");
	__xamarin_class_map [127].handle = objc_getClass ("DOMRange");
	__xamarin_class_map [128].handle = objc_getClass ("DOMStyleSheetList");
	__xamarin_class_map [129].handle = objc_getClass ("DOMWheelEvent");
	__xamarin_class_map [130].handle = objc_getClass ("WebArchive");
	__xamarin_class_map [131].handle = objc_getClass ("WebBackForwardList");
	__xamarin_class_map [132].handle = objc_getClass ("WebDataSource");
	__xamarin_class_map [133].handle = objc_getClass ("WebDocumentRepresentation");
	__xamarin_class_map [134].handle = objc_getClass ("NSURLDownload");
	__xamarin_class_map [135].handle = objc_getClass ("WebDownload");
	__xamarin_class_map [136].handle = objc_getClass ("WebDownloadDelegate");
	__xamarin_class_map [137].handle = objc_getClass ("WebFrame");
	__xamarin_class_map [138].handle = objc_getClass ("WebFrameLoadDelegate");
	__xamarin_class_map [139].handle = objc_getClass ("NSResponder");
	__xamarin_class_map [140].handle = objc_getClass ("NSView");
	__xamarin_class_map [141].handle = objc_getClass ("WebFrameView");
	__xamarin_class_map [142].handle = objc_getClass ("WebHistory");
	__xamarin_class_map [143].handle = objc_getClass ("Xamarin_Mac__WebKit_WebOpenPanelResultListener");
	__xamarin_class_map [144].handle = objc_getClass ("Xamarin_Mac__WebKit_WebPolicyDecisionListener");
	__xamarin_class_map [145].handle = objc_getClass ("WebPolicyDelegate");
	__xamarin_class_map [146].handle = objc_getClass ("WebPreferences");
	__xamarin_class_map [147].handle = objc_getClass ("WebResource");
	__xamarin_class_map [148].handle = objc_getClass ("WebResourceLoadDelegate");
	__xamarin_class_map [149].handle = objc_getClass ("WebUIDelegate");
	__xamarin_class_map [150].handle = objc_getClass ("WKBackForwardList");
	__xamarin_class_map [151].handle = objc_getClass ("WKBackForwardListItem");
	__xamarin_class_map [152].handle = objc_getClass ("WKContentRuleList");
	__xamarin_class_map [153].handle = objc_getClass ("WKFrameInfo");
	__xamarin_class_map [154].handle = objc_getClass ("WKNavigation");
	__xamarin_class_map [155].handle = objc_getClass ("WKNavigationAction");
	__xamarin_class_map [156].handle = objc_getClass ("WKNavigationDelegate");
	__xamarin_class_map [157].handle = objc_getClass ("WKNavigationResponse");
	__xamarin_class_map [158].handle = objc_getClass ("WKOpenPanelParameters");
	__xamarin_class_map [159].handle = objc_getClass ("WKPreferences");
	__xamarin_class_map [160].handle = objc_getClass ("WKProcessPool");
	__xamarin_class_map [161].handle = objc_getClass ("WKScriptMessage");
	__xamarin_class_map [162].handle = objc_getClass ("WKScriptMessageHandler");
	__xamarin_class_map [163].handle = objc_getClass ("WKSecurityOrigin");
	__xamarin_class_map [164].handle = objc_getClass ("WKSnapshotConfiguration");
	__xamarin_class_map [165].handle = objc_getClass ("WKUIDelegate");
	__xamarin_class_map [166].handle = objc_getClass ("WKUserContentController");
	__xamarin_class_map [167].handle = objc_getClass ("WKUserScript");
	__xamarin_class_map [168].handle = objc_getClass ("WKWebsiteDataRecord");
	__xamarin_class_map [169].handle = objc_getClass ("WKWebViewConfiguration");
	__xamarin_class_map [170].handle = objc_getClass ("WKWindowFeatures");
	__xamarin_class_map [171].handle = objc_getClass ("VNObservation");
	__xamarin_class_map [172].handle = objc_getClass ("VNDetectedObjectObservation");
	__xamarin_class_map [173].handle = objc_getClass ("VNRectangleObservation");
	__xamarin_class_map [174].handle = objc_getClass ("VNBarcodeObservation");
	__xamarin_class_map [175].handle = objc_getClass ("VNClassificationObservation");
	__xamarin_class_map [176].handle = objc_getClass ("VNCoreMLFeatureValueObservation");
	__xamarin_class_map [177].handle = objc_getClass ("VNCoreMLModel");
	__xamarin_class_map [178].handle = objc_getClass ("VNRequest");
	__xamarin_class_map [179].handle = objc_getClass ("VNImageBasedRequest");
	__xamarin_class_map [180].handle = objc_getClass ("VNCoreMLRequest");
	__xamarin_class_map [181].handle = objc_getClass ("VNDetectBarcodesRequest");
	__xamarin_class_map [182].handle = objc_getClass ("VNDetectFaceLandmarksRequest");
	__xamarin_class_map [183].handle = objc_getClass ("VNDetectFaceRectanglesRequest");
	__xamarin_class_map [184].handle = objc_getClass ("VNDetectHorizonRequest");
	__xamarin_class_map [185].handle = objc_getClass ("VNDetectRectanglesRequest");
	__xamarin_class_map [186].handle = objc_getClass ("VNDetectTextRectanglesRequest");
	__xamarin_class_map [187].handle = objc_getClass ("VNFaceLandmarkRegion");
	__xamarin_class_map [188].handle = objc_getClass ("VNFaceLandmarkRegion2D");
	__xamarin_class_map [189].handle = objc_getClass ("VNFaceLandmarks");
	__xamarin_class_map [190].handle = objc_getClass ("VNFaceLandmarks2D");
	__xamarin_class_map [191].handle = objc_getClass ("VNFaceObservation");
	__xamarin_class_map [192].handle = objc_getClass ("VNTargetedImageRequest");
	__xamarin_class_map [193].handle = objc_getClass ("VNImageRegistrationRequest");
	__xamarin_class_map [194].handle = objc_getClass ("VNHomographicImageRegistrationRequest");
	__xamarin_class_map [195].handle = objc_getClass ("VNHorizonObservation");
	__xamarin_class_map [196].handle = objc_getClass ("VNImageAlignmentObservation");
	__xamarin_class_map [197].handle = objc_getClass ("VNImageHomographicAlignmentObservation");
	__xamarin_class_map [198].handle = objc_getClass ("VNImageRequestHandler");
	__xamarin_class_map [199].handle = objc_getClass ("VNImageTranslationAlignmentObservation");
	__xamarin_class_map [200].handle = objc_getClass ("VNPixelBufferObservation");
	__xamarin_class_map [201].handle = objc_getClass ("VNRecognizedObjectObservation");
	__xamarin_class_map [202].handle = objc_getClass ("VNSequenceRequestHandler");
	__xamarin_class_map [203].handle = objc_getClass ("VNTextObservation");
	__xamarin_class_map [204].handle = objc_getClass ("VNTrackingRequest");
	__xamarin_class_map [205].handle = objc_getClass ("VNTrackObjectRequest");
	__xamarin_class_map [206].handle = objc_getClass ("VNTrackRectangleRequest");
	__xamarin_class_map [207].handle = objc_getClass ("VNTranslationalImageRegistrationRequest");
	__xamarin_class_map [208].handle = objc_getClass ("SKDownload");
	__xamarin_class_map [209].handle = objc_getClass ("SKPayment");
	__xamarin_class_map [210].handle = objc_getClass ("SKMutablePayment");
	__xamarin_class_map [211].handle = objc_getClass ("SKPaymentQueue");
	__xamarin_class_map [212].handle = objc_getClass ("SKPaymentTransaction");
	__xamarin_class_map [213].handle = objc_getClass ("SKPaymentTransactionObserver");
	__xamarin_class_map [214].handle = objc_getClass ("SKProduct");
	__xamarin_class_map [215].handle = objc_getClass ("SKProductDiscount");
	__xamarin_class_map [216].handle = objc_getClass ("SKRequestDelegate");
	__xamarin_class_map [217].handle = objc_getClass ("SKProductsRequestDelegate");
	__xamarin_class_map [218].handle = objc_getClass ("SKProductsResponse");
	__xamarin_class_map [219].handle = objc_getClass ("SKProductSubscriptionPeriod");
	__xamarin_class_map [220].handle = objc_getClass ("SKRequest");
	__xamarin_class_map [221].handle = objc_getClass ("SKReceiptRefreshRequest");
	__xamarin_class_map [222].handle = objc_getClass ("SKStoreReviewController");
	__xamarin_class_map [223].handle = objc_getClass ("SKNode");
	__xamarin_class_map [224].handle = objc_getClass ("SK3DNode");
	__xamarin_class_map [225].handle = objc_getClass ("SKAction");
	__xamarin_class_map [226].handle = objc_getClass ("SKAttribute");
	__xamarin_class_map [227].handle = objc_getClass ("SKAttributeValue");
	__xamarin_class_map [228].handle = objc_getClass ("SKAudioNode");
	__xamarin_class_map [229].handle = objc_getClass ("SKCameraNode");
	__xamarin_class_map [230].handle = objc_getClass ("SKConstraint");
	__xamarin_class_map [231].handle = objc_getClass ("SKCropNode");
	__xamarin_class_map [232].handle = objc_getClass ("SKEffectNode");
	__xamarin_class_map [233].handle = objc_getClass ("SKEmitterNode");
	__xamarin_class_map [234].handle = objc_getClass ("SKFieldNode");
	__xamarin_class_map [235].handle = objc_getClass ("SKKeyframeSequence");
	__xamarin_class_map [236].handle = objc_getClass ("SKLabelNode");
	__xamarin_class_map [237].handle = objc_getClass ("SKLightNode");
	__xamarin_class_map [238].handle = objc_getClass ("SKTexture");
	__xamarin_class_map [239].handle = objc_getClass ("SKMutableTexture");
	__xamarin_class_map [240].handle = objc_getClass ("SKPhysicsBody");
	__xamarin_class_map [241].handle = objc_getClass ("SKPhysicsContact");
	__xamarin_class_map [242].handle = objc_getClass ("SKPhysicsContactDelegate");
	__xamarin_class_map [243].handle = objc_getClass ("SKPhysicsJoint");
	__xamarin_class_map [244].handle = objc_getClass ("SKPhysicsJointFixed");
	__xamarin_class_map [245].handle = objc_getClass ("SKPhysicsJointLimit");
	__xamarin_class_map [246].handle = objc_getClass ("SKPhysicsJointPin");
	__xamarin_class_map [247].handle = objc_getClass ("SKPhysicsJointSliding");
	__xamarin_class_map [248].handle = objc_getClass ("SKPhysicsJointSpring");
	__xamarin_class_map [249].handle = objc_getClass ("SKRange");
	__xamarin_class_map [250].handle = objc_getClass ("SKReachConstraints");
	__xamarin_class_map [251].handle = objc_getClass ("SKReferenceNode");
	__xamarin_class_map [252].handle = objc_getClass ("SKRegion");
	__xamarin_class_map [253].handle = objc_getClass ("SKRenderer");
	__xamarin_class_map [254].handle = objc_getClass ("SKScene");
	__xamarin_class_map [255].handle = objc_getClass ("SKSceneDelegate");
	__xamarin_class_map [256].handle = objc_getClass ("SKShader");
	__xamarin_class_map [257].handle = objc_getClass ("SKShapeNode");
	__xamarin_class_map [258].handle = objc_getClass ("SKSpriteNode");
	__xamarin_class_map [259].handle = objc_getClass ("SKTileDefinition");
	__xamarin_class_map [260].handle = objc_getClass ("SKTileGroup");
	__xamarin_class_map [261].handle = objc_getClass ("SKTileGroupRule");
	__xamarin_class_map [262].handle = objc_getClass ("SKTileMapNode");
	__xamarin_class_map [263].handle = objc_getClass ("SKTileSet");
	__xamarin_class_map [264].handle = objc_getClass ("SKTransformNode");
	__xamarin_class_map [265].handle = objc_getClass ("SKTransition");
	__xamarin_class_map [266].handle = objc_getClass ("SKUniform");
	__xamarin_class_map [267].handle = objc_getClass ("SKVideoNode");
	__xamarin_class_map [268].handle = objc_getClass ("SKView");
	__xamarin_class_map [269].handle = objc_getClass ("SKViewDelegate");
	__xamarin_class_map [270].handle = objc_getClass ("SKWarpGeometry");
	__xamarin_class_map [271].handle = objc_getClass ("SKWarpGeometryGrid");
	__xamarin_class_map [272].handle = objc_getClass ("NSViewController");
	__xamarin_class_map [273].handle = objc_getClass ("SLComposeServiceViewController");
	__xamarin_class_map [274].handle = objc_getClass ("SBApplicationDelegate");
	__xamarin_class_map [275].handle = objc_getClass ("NSArray");
	__xamarin_class_map [276].handle = objc_getClass ("NSMutableArray");
	__xamarin_class_map [277].handle = objc_getClass ("SBElementArray");
	__xamarin_class_map [278].handle = objc_getClass ("SBObject");
	__xamarin_class_map [279].handle = objc_getClass ("SCNConstraint");
	__xamarin_class_map [280].handle = objc_getClass ("SCNAccelerationConstraint");
	__xamarin_class_map [281].handle = objc_getClass ("SCNAction");
	__xamarin_class_map [282].handle = objc_getClass ("SCNActionable");
	__xamarin_class_map [283].handle = objc_getClass ("SCNAnimatable");
	__xamarin_class_map [284].handle = objc_getClass ("SCNAnimation");
	__xamarin_class_map [285].handle = objc_getClass ("SCNAnimationPlayer");
	__xamarin_class_map [286].handle = objc_getClass ("SCNAudioPlayer");
	__xamarin_class_map [287].handle = objc_getClass ("SCNAudioSource");
	__xamarin_class_map [288].handle = objc_getClass ("SCNAvoidOccluderConstraint");
	__xamarin_class_map [289].handle = objc_getClass ("SCNAvoidOccluderConstraintDelegate");
	__xamarin_class_map [290].handle = objc_getClass ("SCNBillboardConstraint");
	__xamarin_class_map [291].handle = objc_getClass ("SCNBoundingVolume");
	__xamarin_class_map [292].handle = objc_getClass ("SCNGeometry");
	__xamarin_class_map [293].handle = objc_getClass ("SCNBox");
	__xamarin_class_map [294].handle = objc_getClass ("SCNCamera");
	__xamarin_class_map [295].handle = objc_getClass ("SCNCameraController");
	__xamarin_class_map [296].handle = objc_getClass ("SCNCameraControllerDelegate");
	__xamarin_class_map [297].handle = objc_getClass ("SCNCapsule");
	__xamarin_class_map [298].handle = objc_getClass ("SCNCone");
	__xamarin_class_map [299].handle = objc_getClass ("SCNCylinder");
	__xamarin_class_map [300].handle = objc_getClass ("SCNDistanceConstraint");
	__xamarin_class_map [301].handle = objc_getClass ("SCNFloor");
	__xamarin_class_map [302].handle = objc_getClass ("SCNGeometryElement");
	__xamarin_class_map [303].handle = objc_getClass ("SCNGeometrySource");
	__xamarin_class_map [304].handle = objc_getClass ("SCNGeometryTessellator");
	__xamarin_class_map [305].handle = objc_getClass ("SCNHitTestResult");
	__xamarin_class_map [306].handle = objc_getClass ("SCNIKConstraint");
	__xamarin_class_map [307].handle = objc_getClass ("SCNLevelOfDetail");
	__xamarin_class_map [308].handle = objc_getClass ("SCNLight");
	__xamarin_class_map [309].handle = objc_getClass ("SCNLookAtConstraint");
	__xamarin_class_map [310].handle = objc_getClass ("SCNMaterial");
	__xamarin_class_map [311].handle = objc_getClass ("SCNMaterialProperty");
	__xamarin_class_map [312].handle = objc_getClass ("SCNMorpher");
	__xamarin_class_map [313].handle = objc_getClass ("SCNNodeRendererDelegate");
	__xamarin_class_map [314].handle = objc_getClass ("SCNParticlePropertyController");
	__xamarin_class_map [315].handle = objc_getClass ("SCNParticleSystem");
	__xamarin_class_map [316].handle = objc_getClass ("SCNPhysicsBehavior");
	__xamarin_class_map [317].handle = objc_getClass ("SCNPhysicsBallSocketJoint");
	__xamarin_class_map [318].handle = objc_getClass ("SCNPhysicsBody");
	__xamarin_class_map [319].handle = objc_getClass ("SCNPhysicsConeTwistJoint");
	__xamarin_class_map [320].handle = objc_getClass ("SCNPhysicsContact");
	__xamarin_class_map [321].handle = objc_getClass ("SCNPhysicsContactDelegate");
	__xamarin_class_map [322].handle = objc_getClass ("SCNPhysicsField");
	__xamarin_class_map [323].handle = objc_getClass ("SCNPhysicsHingeJoint");
	__xamarin_class_map [324].handle = objc_getClass ("SCNPhysicsShape");
	__xamarin_class_map [325].handle = objc_getClass ("SCNPhysicsSliderJoint");
	__xamarin_class_map [326].handle = objc_getClass ("SCNPhysicsVehicle");
	__xamarin_class_map [327].handle = objc_getClass ("SCNPhysicsVehicleWheel");
	__xamarin_class_map [328].handle = objc_getClass ("SCNPlane");
	__xamarin_class_map [329].handle = objc_getClass ("SCNProgram");
	__xamarin_class_map [330].handle = objc_getClass ("SCNProgramDelegate");
	__xamarin_class_map [331].handle = objc_getClass ("SCNPyramid");
	__xamarin_class_map [332].handle = objc_getClass ("SCNNode");
	__xamarin_class_map [333].handle = objc_getClass ("SCNReferenceNode");
	__xamarin_class_map [334].handle = objc_getClass ("SCNReplicatorConstraint");
	__xamarin_class_map [335].handle = objc_getClass ("SCNScene");
	__xamarin_class_map [336].handle = objc_getClass ("SCNSceneExportDelegate");
	__xamarin_class_map [337].handle = objc_getClass ("SCNSceneRenderer");
	__xamarin_class_map [338].handle = objc_getClass ("SCNSceneRendererDelegate");
	__xamarin_class_map [339].handle = objc_getClass ("SCNSceneSource");
	__xamarin_class_map [340].handle = objc_getClass ("SCNShadable");
	__xamarin_class_map [341].handle = objc_getClass ("SCNShape");
	__xamarin_class_map [342].handle = objc_getClass ("SCNSkinner");
	__xamarin_class_map [343].handle = objc_getClass ("SCNSliderConstraint");
	__xamarin_class_map [344].handle = objc_getClass ("SCNSphere");
	__xamarin_class_map [345].handle = objc_getClass ("SCNTechnique");
	__xamarin_class_map [346].handle = objc_getClass ("SCNTechniqueSupport");
	__xamarin_class_map [347].handle = objc_getClass ("SCNText");
	__xamarin_class_map [348].handle = objc_getClass ("SCNTimingFunction");
	__xamarin_class_map [349].handle = objc_getClass ("SCNTorus");
	__xamarin_class_map [350].handle = objc_getClass ("SCNTransaction");
	__xamarin_class_map [351].handle = objc_getClass ("SCNTransformConstraint");
	__xamarin_class_map [352].handle = objc_getClass ("SCNTube");
	__xamarin_class_map [353].handle = objc_getClass ("SFContentBlockerState");
	__xamarin_class_map [354].handle = objc_getClass ("SFSafariExtensionViewController");
	__xamarin_class_map [355].handle = objc_getClass ("SFSafariPageProperties");
	__xamarin_class_map [356].handle = objc_getClass ("SFSafariToolbarItem");
	__xamarin_class_map [357].handle = objc_getClass ("QLPreviewItem");
	__xamarin_class_map [358].handle = objc_getClass ("NSWindow");
	__xamarin_class_map [359].handle = objc_getClass ("NSPanel");
	__xamarin_class_map [360].handle = objc_getClass ("QLPreviewPanel");
	__xamarin_class_map [361].handle = objc_getClass ("QLPreviewPanelDataSource");
	__xamarin_class_map [362].handle = objc_getClass ("QLPreviewPanelDelegate");
	__xamarin_class_map [363].handle = objc_getClass ("QLPreviewView");
	__xamarin_class_map [364].handle = objc_getClass ("QCComposition");
	__xamarin_class_map [365].handle = objc_getClass ("CALayer");
	__xamarin_class_map [366].handle = objc_getClass ("CAOpenGLLayer");
	__xamarin_class_map [367].handle = objc_getClass ("QCCompositionLayer");
	__xamarin_class_map [368].handle = objc_getClass ("QCCompositionRepository");
	__xamarin_class_map [369].handle = objc_getClass ("PHLivePhotoView");
	__xamarin_class_map [370].handle = objc_getClass ("PHLivePhotoViewDelegate");
	__xamarin_class_map [371].handle = objc_getClass ("PHProjectElement");
	__xamarin_class_map [372].handle = objc_getClass ("PHProjectAssetElement");
	__xamarin_class_map [373].handle = objc_getClass ("NSExtensionContext");
	__xamarin_class_map [374].handle = objc_getClass ("PHProjectExtensionContext");
	__xamarin_class_map [375].handle = objc_getClass ("PHProjectInfo");
	__xamarin_class_map [376].handle = objc_getClass ("PHProjectJournalEntryElement");
	__xamarin_class_map [377].handle = objc_getClass ("PHProjectMapElement");
	__xamarin_class_map [378].handle = objc_getClass ("PHProjectRegionOfInterest");
	__xamarin_class_map [379].handle = objc_getClass ("PHProjectSection");
	__xamarin_class_map [380].handle = objc_getClass ("PHProjectSectionContent");
	__xamarin_class_map [381].handle = objc_getClass ("PHProjectTextElement");
	__xamarin_class_map [382].handle = objc_getClass ("PHProjectTypeDescription");
	__xamarin_class_map [383].handle = objc_getClass ("PHProjectTypeDescriptionDataSource");
	__xamarin_class_map [384].handle = objc_getClass ("PHAdjustmentData");
	__xamarin_class_map [385].handle = objc_getClass ("PHObject");
	__xamarin_class_map [386].handle = objc_getClass ("PHAsset");
	__xamarin_class_map [387].handle = objc_getClass ("PHCollection");
	__xamarin_class_map [388].handle = objc_getClass ("PHAssetCollection");
	__xamarin_class_map [389].handle = objc_getClass ("PHChange");
	__xamarin_class_map [390].handle = objc_getClass ("PHCloudIdentifier");
	__xamarin_class_map [391].handle = objc_getClass ("PHCollectionList");
	__xamarin_class_map [392].handle = objc_getClass ("PHContentEditingInput");
	__xamarin_class_map [393].handle = objc_getClass ("PHContentEditingOutput");
	__xamarin_class_map [394].handle = objc_getClass ("PHFetchOptions");
	__xamarin_class_map [395].handle = objc_getClass ("PHFetchResult");
	__xamarin_class_map [396].handle = objc_getClass ("PHFetchResultChangeDetails");
	__xamarin_class_map [397].handle = objc_getClass ("PHImageManager");
	__xamarin_class_map [398].handle = objc_getClass ("PHImageRequestOptions");
	__xamarin_class_map [399].handle = objc_getClass ("PHLivePhoto");
	__xamarin_class_map [400].handle = objc_getClass ("PHObjectChangeDetails");
	__xamarin_class_map [401].handle = objc_getClass ("PHPhotoLibraryChangeObserver");
	__xamarin_class_map [402].handle = objc_getClass ("PHProject");
	__xamarin_class_map [403].handle = objc_getClass ("PHProjectChangeRequest");
	__xamarin_class_map [404].handle = objc_getClass ("PDFAction");
	__xamarin_class_map [405].handle = objc_getClass ("PDFActionGoTo");
	__xamarin_class_map [406].handle = objc_getClass ("PDFActionNamed");
	__xamarin_class_map [407].handle = objc_getClass ("PDFActionRemoteGoTo");
	__xamarin_class_map [408].handle = objc_getClass ("PDFActionResetForm");
	__xamarin_class_map [409].handle = objc_getClass ("PDFActionURL");
	__xamarin_class_map [410].handle = objc_getClass ("PDFAnnotation");
	__xamarin_class_map [411].handle = objc_getClass ("PDFAnnotationButtonWidget");
	__xamarin_class_map [412].handle = objc_getClass ("PDFAnnotationChoiceWidget");
	__xamarin_class_map [413].handle = objc_getClass ("PDFAnnotationCircle");
	__xamarin_class_map [414].handle = objc_getClass ("PDFAnnotationFreeText");
	__xamarin_class_map [415].handle = objc_getClass ("PDFAnnotationInk");
	__xamarin_class_map [416].handle = objc_getClass ("PDFAnnotationLine");
	__xamarin_class_map [417].handle = objc_getClass ("PDFAnnotationLink");
	__xamarin_class_map [418].handle = objc_getClass ("PDFAnnotationMarkup");
	__xamarin_class_map [419].handle = objc_getClass ("PDFAnnotationPopup");
	__xamarin_class_map [420].handle = objc_getClass ("PDFAnnotationSquare");
	__xamarin_class_map [421].handle = objc_getClass ("PDFAnnotationStamp");
	__xamarin_class_map [422].handle = objc_getClass ("PDFAnnotationText");
	__xamarin_class_map [423].handle = objc_getClass ("PDFAnnotationTextWidget");
	__xamarin_class_map [424].handle = objc_getClass ("PDFAppearanceCharacteristics");
	__xamarin_class_map [425].handle = objc_getClass ("PDFBorder");
	__xamarin_class_map [426].handle = objc_getClass ("PDFDestination");
	__xamarin_class_map [427].handle = objc_getClass ("PDFDocumentDelegate");
	__xamarin_class_map [428].handle = objc_getClass ("PDFOutline");
	__xamarin_class_map [429].handle = objc_getClass ("PDFPage");
	__xamarin_class_map [430].handle = objc_getClass ("PDFSelection");
	__xamarin_class_map [431].handle = objc_getClass ("PDFViewDelegate");
	__xamarin_class_map [432].handle = objc_getClass ("NCWidgetController");
	__xamarin_class_map [433].handle = objc_getClass ("NCWidgetListViewDelegate");
	__xamarin_class_map [434].handle = objc_getClass ("NCWidgetProviding");
	__xamarin_class_map [435].handle = objc_getClass ("NCWidgetSearchViewDelegate");
	__xamarin_class_map [436].handle = objc_getClass ("NEAppRule");
	__xamarin_class_map [437].handle = objc_getClass ("NEVPNProtocol");
	__xamarin_class_map [438].handle = objc_getClass ("NEDNSProxyProviderProtocol");
	__xamarin_class_map [439].handle = objc_getClass ("NEDNSSettings");
	__xamarin_class_map [440].handle = objc_getClass ("NEEvaluateConnectionRule");
	__xamarin_class_map [441].handle = objc_getClass ("NEFilterProviderConfiguration");
	__xamarin_class_map [442].handle = objc_getClass ("NEFlowMetaData");
	__xamarin_class_map [443].handle = objc_getClass ("NEIPv4Route");
	__xamarin_class_map [444].handle = objc_getClass ("NEIPv4Settings");
	__xamarin_class_map [445].handle = objc_getClass ("NEIPv6Route");
	__xamarin_class_map [446].handle = objc_getClass ("NEIPv6Settings");
	__xamarin_class_map [447].handle = objc_getClass ("NEOnDemandRule");
	__xamarin_class_map [448].handle = objc_getClass ("NEOnDemandRuleConnect");
	__xamarin_class_map [449].handle = objc_getClass ("NEOnDemandRuleDisconnect");
	__xamarin_class_map [450].handle = objc_getClass ("NEOnDemandRuleEvaluateConnection");
	__xamarin_class_map [451].handle = objc_getClass ("NEOnDemandRuleIgnore");
	__xamarin_class_map [452].handle = objc_getClass ("NEPacket");
	__xamarin_class_map [453].handle = objc_getClass ("NETunnelNetworkSettings");
	__xamarin_class_map [454].handle = objc_getClass ("NEPacketTunnelNetworkSettings");
	__xamarin_class_map [455].handle = objc_getClass ("NEProxyServer");
	__xamarin_class_map [456].handle = objc_getClass ("NEProxySettings");
	__xamarin_class_map [457].handle = objc_getClass ("NETunnelProviderProtocol");
	__xamarin_class_map [458].handle = objc_getClass ("NEVPNConnection");
	__xamarin_class_map [459].handle = objc_getClass ("NETunnelProviderSession");
	__xamarin_class_map [460].handle = objc_getClass ("NEVPNIKEv2SecurityAssociationParameters");
	__xamarin_class_map [461].handle = objc_getClass ("NEVPNProtocolIPSec");
	__xamarin_class_map [462].handle = objc_getClass ("NEVPNProtocolIKEv2");
	__xamarin_class_map [463].handle = objc_getClass ("NWEndpoint");
	__xamarin_class_map [464].handle = objc_getClass ("NWBonjourServiceEndpoint");
	__xamarin_class_map [465].handle = objc_getClass ("NWHostEndpoint");
	__xamarin_class_map [466].handle = objc_getClass ("NWPath");
	__xamarin_class_map [467].handle = objc_getClass ("NWTCPConnectionAuthenticationDelegate");
	__xamarin_class_map [468].handle = objc_getClass ("NWTLSParameters");
	__xamarin_class_map [469].handle = objc_getClass ("NLModel");
	__xamarin_class_map [470].handle = objc_getClass ("NLModelConfiguration");
	__xamarin_class_map [471].handle = objc_getClass ("NLTokenizer");
	__xamarin_class_map [472].handle = objc_getClass ("MCAdvertiserAssistant");
	__xamarin_class_map [473].handle = objc_getClass ("MCAdvertiserAssistantDelegate");
	__xamarin_class_map [474].handle = objc_getClass ("MCBrowserViewController");
	__xamarin_class_map [475].handle = objc_getClass ("MCBrowserViewControllerDelegate");
	__xamarin_class_map [476].handle = objc_getClass ("MCNearbyServiceAdvertiser");
	__xamarin_class_map [477].handle = objc_getClass ("MCNearbyServiceAdvertiserDelegate");
	__xamarin_class_map [478].handle = objc_getClass ("MCNearbyServiceBrowser");
	__xamarin_class_map [479].handle = objc_getClass ("MCNearbyServiceBrowserDelegate");
	__xamarin_class_map [480].handle = objc_getClass ("MCPeerID");
	__xamarin_class_map [481].handle = objc_getClass ("MCSessionDelegate");
	__xamarin_class_map [482].handle = objc_getClass ("MDLAnimatedValue");
	__xamarin_class_map [483].handle = objc_getClass ("MDLAnimatedMatrix4x4");
	__xamarin_class_map [484].handle = objc_getClass ("MDLAnimatedQuaternionArray");
	__xamarin_class_map [485].handle = objc_getClass ("MDLAnimatedScalar");
	__xamarin_class_map [486].handle = objc_getClass ("MDLAnimatedScalarArray");
	__xamarin_class_map [487].handle = objc_getClass ("MDLAnimatedVector2");
	__xamarin_class_map [488].handle = objc_getClass ("MDLAnimatedVector3");
	__xamarin_class_map [489].handle = objc_getClass ("MDLAnimatedVector3Array");
	__xamarin_class_map [490].handle = objc_getClass ("MDLAnimatedVector4");
	__xamarin_class_map [491].handle = objc_getClass ("MDLAnimationBindComponent");
	__xamarin_class_map [492].handle = objc_getClass ("MDLObject");
	__xamarin_class_map [493].handle = objc_getClass ("MDLLight");
	__xamarin_class_map [494].handle = objc_getClass ("MDLPhysicallyPlausibleLight");
	__xamarin_class_map [495].handle = objc_getClass ("MDLAreaLight");
	__xamarin_class_map [496].handle = objc_getClass ("MDLAsset");
	__xamarin_class_map [497].handle = objc_getClass ("MDLBundleAssetResolver");
	__xamarin_class_map [498].handle = objc_getClass ("MDLCamera");
	__xamarin_class_map [499].handle = objc_getClass ("MDLTexture");
	__xamarin_class_map [500].handle = objc_getClass ("MDLCheckerboardTexture");
	__xamarin_class_map [501].handle = objc_getClass ("MDLColorSwatchTexture");
	__xamarin_class_map [502].handle = objc_getClass ("MDLLightProbe");
	__xamarin_class_map [503].handle = objc_getClass ("MDLLightProbeIrradianceDataSource");
	__xamarin_class_map [504].handle = objc_getClass ("MDLMaterial");
	__xamarin_class_map [505].handle = objc_getClass ("MDLMaterialProperty");
	__xamarin_class_map [506].handle = objc_getClass ("MDLMaterialPropertyConnection");
	__xamarin_class_map [507].handle = objc_getClass ("MDLMaterialPropertyNode");
	__xamarin_class_map [508].handle = objc_getClass ("MDLMaterialPropertyGraph");
	__xamarin_class_map [509].handle = objc_getClass ("MDLMatrix4x4Array");
	__xamarin_class_map [510].handle = objc_getClass ("MDLMeshBufferData");
	__xamarin_class_map [511].handle = objc_getClass ("MDLMeshBufferDataAllocator");
	__xamarin_class_map [512].handle = objc_getClass ("MDLMeshBufferMap");
	__xamarin_class_map [513].handle = objc_getClass ("MDLMeshBufferZoneDefault");
	__xamarin_class_map [514].handle = objc_getClass ("MDLNoiseTexture");
	__xamarin_class_map [515].handle = objc_getClass ("MDLNormalMapTexture");
	__xamarin_class_map [516].handle = objc_getClass ("MDLObjectContainer");
	__xamarin_class_map [517].handle = objc_getClass ("MDLPackedJointAnimation");
	__xamarin_class_map [518].handle = objc_getClass ("MDLPathAssetResolver");
	__xamarin_class_map [519].handle = objc_getClass ("MDLPhotometricLight");
	__xamarin_class_map [520].handle = objc_getClass ("MDLScatteringFunction");
	__xamarin_class_map [521].handle = objc_getClass ("MDLPhysicallyPlausibleScatteringFunction");
	__xamarin_class_map [522].handle = objc_getClass ("MDLRelativeAssetResolver");
	__xamarin_class_map [523].handle = objc_getClass ("MDLSkeleton");
	__xamarin_class_map [524].handle = objc_getClass ("MDLSkyCubeTexture");
	__xamarin_class_map [525].handle = objc_getClass ("MDLStereoscopicCamera");
	__xamarin_class_map [526].handle = objc_getClass ("MDLSubmesh");
	__xamarin_class_map [527].handle = objc_getClass ("MDLSubmeshTopology");
	__xamarin_class_map [528].handle = objc_getClass ("MDLTextureFilter");
	__xamarin_class_map [529].handle = objc_getClass ("MDLTextureSampler");
	__xamarin_class_map [530].handle = objc_getClass ("MDLTransform");
	__xamarin_class_map [531].handle = objc_getClass ("MDLTransformMatrixOp");
	__xamarin_class_map [532].handle = objc_getClass ("MDLTransformRotateOp");
	__xamarin_class_map [533].handle = objc_getClass ("MDLTransformRotateXOp");
	__xamarin_class_map [534].handle = objc_getClass ("MDLTransformRotateYOp");
	__xamarin_class_map [535].handle = objc_getClass ("MDLTransformRotateZOp");
	__xamarin_class_map [536].handle = objc_getClass ("MDLTransformScaleOp");
	__xamarin_class_map [537].handle = objc_getClass ("MDLTransformStack");
	__xamarin_class_map [538].handle = objc_getClass ("MDLTransformTranslateOp");
	__xamarin_class_map [539].handle = objc_getClass ("MDLURLTexture");
	__xamarin_class_map [540].handle = objc_getClass ("MDLVertexAttribute");
	__xamarin_class_map [541].handle = objc_getClass ("MDLVertexAttributeData");
	__xamarin_class_map [542].handle = objc_getClass ("MDLVertexBufferLayout");
	__xamarin_class_map [543].handle = objc_getClass ("MDLVertexDescriptor");
	__xamarin_class_map [544].handle = objc_getClass ("MDLVoxelArray");
	__xamarin_class_map [545].handle = objc_getClass ("MPSKernel");
	__xamarin_class_map [546].handle = objc_getClass ("MPSBinaryImageKernel");
	__xamarin_class_map [547].handle = objc_getClass ("MPSCNNKernel");
	__xamarin_class_map [548].handle = objc_getClass ("MPSCNNBinaryConvolution");
	__xamarin_class_map [549].handle = objc_getClass ("MPSNNFilterNode");
	__xamarin_class_map [550].handle = objc_getClass ("MPSCNNConvolutionNode");
	__xamarin_class_map [551].handle = objc_getClass ("MPSCNNBinaryConvolutionNode");
	__xamarin_class_map [552].handle = objc_getClass ("MPSCNNBinaryFullyConnected");
	__xamarin_class_map [553].handle = objc_getClass ("MPSCNNBinaryFullyConnectedNode");
	__xamarin_class_map [554].handle = objc_getClass ("MPSCNNBinaryKernel");
	__xamarin_class_map [555].handle = objc_getClass ("MPSCNNConvolution");
	__xamarin_class_map [556].handle = objc_getClass ("MPSCNNConvolutionDataSource");
	__xamarin_class_map [557].handle = objc_getClass ("MPSCNNConvolutionDescriptor");
	__xamarin_class_map [558].handle = objc_getClass ("MPSState");
	__xamarin_class_map [559].handle = objc_getClass ("MPSCNNConvolutionState");
	__xamarin_class_map [560].handle = objc_getClass ("MPSNNStateNode");
	__xamarin_class_map [561].handle = objc_getClass ("MPSCNNConvolutionStateNode");
	__xamarin_class_map [562].handle = objc_getClass ("MPSCNNConvolutionTranspose");
	__xamarin_class_map [563].handle = objc_getClass ("MPSCNNConvolutionTransposeNode");
	__xamarin_class_map [564].handle = objc_getClass ("MPSCNNCrossChannelNormalization");
	__xamarin_class_map [565].handle = objc_getClass ("MPSCNNNormalizationNode");
	__xamarin_class_map [566].handle = objc_getClass ("MPSCNNCrossChannelNormalizationNode");
	__xamarin_class_map [567].handle = objc_getClass ("MPSCNNDepthWiseConvolutionDescriptor");
	__xamarin_class_map [568].handle = objc_getClass ("MPSCNNPooling");
	__xamarin_class_map [569].handle = objc_getClass ("MPSCNNDilatedPoolingMax");
	__xamarin_class_map [570].handle = objc_getClass ("MPSCNNDilatedPoolingMaxNode");
	__xamarin_class_map [571].handle = objc_getClass ("MPSCNNFullyConnected");
	__xamarin_class_map [572].handle = objc_getClass ("MPSCNNFullyConnectedNode");
	__xamarin_class_map [573].handle = objc_getClass ("MPSCNNLocalContrastNormalization");
	__xamarin_class_map [574].handle = objc_getClass ("MPSCNNLocalContrastNormalizationNode");
	__xamarin_class_map [575].handle = objc_getClass ("MPSCNNLogSoftMax");
	__xamarin_class_map [576].handle = objc_getClass ("MPSCNNLogSoftMaxNode");
	__xamarin_class_map [577].handle = objc_getClass ("MPSCNNNeuron");
	__xamarin_class_map [578].handle = objc_getClass ("MPSCNNNeuronAbsolute");
	__xamarin_class_map [579].handle = objc_getClass ("MPSCNNNeuronNode");
	__xamarin_class_map [580].handle = objc_getClass ("MPSCNNNeuronAbsoluteNode");
	__xamarin_class_map [581].handle = objc_getClass ("MPSCNNNeuronELU");
	__xamarin_class_map [582].handle = objc_getClass ("MPSCNNNeuronELUNode");
	__xamarin_class_map [583].handle = objc_getClass ("MPSCNNNeuronHardSigmoid");
	__xamarin_class_map [584].handle = objc_getClass ("MPSCNNNeuronHardSigmoidNode");
	__xamarin_class_map [585].handle = objc_getClass ("MPSCNNNeuronLinear");
	__xamarin_class_map [586].handle = objc_getClass ("MPSCNNNeuronLinearNode");
	__xamarin_class_map [587].handle = objc_getClass ("MPSCNNNeuronPReLU");
	__xamarin_class_map [588].handle = objc_getClass ("MPSCNNNeuronPReLUNode");
	__xamarin_class_map [589].handle = objc_getClass ("MPSCNNNeuronReLU");
	__xamarin_class_map [590].handle = objc_getClass ("MPSCNNNeuronReLUN");
	__xamarin_class_map [591].handle = objc_getClass ("MPSCNNNeuronReLUNNode");
	__xamarin_class_map [592].handle = objc_getClass ("MPSCNNNeuronReLUNode");
	__xamarin_class_map [593].handle = objc_getClass ("MPSCNNNeuronSigmoid");
	__xamarin_class_map [594].handle = objc_getClass ("MPSCNNNeuronSigmoidNode");
	__xamarin_class_map [595].handle = objc_getClass ("MPSCNNNeuronSoftPlus");
	__xamarin_class_map [596].handle = objc_getClass ("MPSCNNNeuronSoftPlusNode");
	__xamarin_class_map [597].handle = objc_getClass ("MPSCNNNeuronSoftSign");
	__xamarin_class_map [598].handle = objc_getClass ("MPSCNNNeuronSoftSignNode");
	__xamarin_class_map [599].handle = objc_getClass ("MPSCNNNeuronTanH");
	__xamarin_class_map [600].handle = objc_getClass ("MPSCNNNeuronTanHNode");
	__xamarin_class_map [601].handle = objc_getClass ("MPSCNNPoolingAverage");
	__xamarin_class_map [602].handle = objc_getClass ("MPSCNNPoolingNode");
	__xamarin_class_map [603].handle = objc_getClass ("MPSCNNPoolingAverageNode");
	__xamarin_class_map [604].handle = objc_getClass ("MPSCNNPoolingL2Norm");
	__xamarin_class_map [605].handle = objc_getClass ("MPSCNNPoolingL2NormNode");
	__xamarin_class_map [606].handle = objc_getClass ("MPSCNNPoolingMax");
	__xamarin_class_map [607].handle = objc_getClass ("MPSCNNPoolingMaxNode");
	__xamarin_class_map [608].handle = objc_getClass ("MPSCNNSoftMax");
	__xamarin_class_map [609].handle = objc_getClass ("MPSCNNSoftMaxNode");
	__xamarin_class_map [610].handle = objc_getClass ("MPSCNNSpatialNormalization");
	__xamarin_class_map [611].handle = objc_getClass ("MPSCNNSpatialNormalizationNode");
	__xamarin_class_map [612].handle = objc_getClass ("MPSCNNSubPixelConvolutionDescriptor");
	__xamarin_class_map [613].handle = objc_getClass ("MPSCNNUpsampling");
	__xamarin_class_map [614].handle = objc_getClass ("MPSCNNUpsamplingBilinear");
	__xamarin_class_map [615].handle = objc_getClass ("MPSCNNUpsamplingBilinearNode");
	__xamarin_class_map [616].handle = objc_getClass ("MPSCNNUpsamplingNearest");
	__xamarin_class_map [617].handle = objc_getClass ("MPSCNNUpsamplingNearestNode");
	__xamarin_class_map [618].handle = objc_getClass ("MPSRNNDescriptor");
	__xamarin_class_map [619].handle = objc_getClass ("MPSGRUDescriptor");
	__xamarin_class_map [620].handle = objc_getClass ("MPSImage");
	__xamarin_class_map [621].handle = objc_getClass ("MPSImageArithmetic");
	__xamarin_class_map [622].handle = objc_getClass ("MPSImageAdd");
	__xamarin_class_map [623].handle = objc_getClass ("MPSUnaryImageKernel");
	__xamarin_class_map [624].handle = objc_getClass ("MPSImageAreaMax");
	__xamarin_class_map [625].handle = objc_getClass ("MPSImageAreaMin");
	__xamarin_class_map [626].handle = objc_getClass ("MPSImageScale");
	__xamarin_class_map [627].handle = objc_getClass ("MPSImageBilinearScale");
	__xamarin_class_map [628].handle = objc_getClass ("MPSImageBox");
	__xamarin_class_map [629].handle = objc_getClass ("MPSImageConversion");
	__xamarin_class_map [630].handle = objc_getClass ("MPSImageConvolution");
	__xamarin_class_map [631].handle = objc_getClass ("MPSImageCopyToMatrix");
	__xamarin_class_map [632].handle = objc_getClass ("MPSImageDescriptor");
	__xamarin_class_map [633].handle = objc_getClass ("MPSImageDilate");
	__xamarin_class_map [634].handle = objc_getClass ("MPSImageDivide");
	__xamarin_class_map [635].handle = objc_getClass ("MPSImageErode");
	__xamarin_class_map [636].handle = objc_getClass ("MPSImageFindKeypoints");
	__xamarin_class_map [637].handle = objc_getClass ("MPSImageGaussianBlur");
	__xamarin_class_map [638].handle = objc_getClass ("MPSImagePyramid");
	__xamarin_class_map [639].handle = objc_getClass ("MPSImageGaussianPyramid");
	__xamarin_class_map [640].handle = objc_getClass ("MPSImageHistogram");
	__xamarin_class_map [641].handle = objc_getClass ("MPSImageHistogramEqualization");
	__xamarin_class_map [642].handle = objc_getClass ("MPSImageHistogramSpecification");
	__xamarin_class_map [643].handle = objc_getClass ("MPSImageIntegral");
	__xamarin_class_map [644].handle = objc_getClass ("MPSImageIntegralOfSquares");
	__xamarin_class_map [645].handle = objc_getClass ("MPSImageLanczosScale");
	__xamarin_class_map [646].handle = objc_getClass ("MPSImageLaplacian");
	__xamarin_class_map [647].handle = objc_getClass ("MPSImageMedian");
	__xamarin_class_map [648].handle = objc_getClass ("MPSImageMultiply");
	__xamarin_class_map [649].handle = objc_getClass ("MPSImageSobel");
	__xamarin_class_map [650].handle = objc_getClass ("MPSImageStatisticsMean");
	__xamarin_class_map [651].handle = objc_getClass ("MPSImageStatisticsMeanAndVariance");
	__xamarin_class_map [652].handle = objc_getClass ("MPSImageStatisticsMinAndMax");
	__xamarin_class_map [653].handle = objc_getClass ("MPSImageSubtract");
	__xamarin_class_map [654].handle = objc_getClass ("MPSImageTent");
	__xamarin_class_map [655].handle = objc_getClass ("MPSImageThresholdBinary");
	__xamarin_class_map [656].handle = objc_getClass ("MPSImageThresholdBinaryInverse");
	__xamarin_class_map [657].handle = objc_getClass ("MPSImageThresholdToZero");
	__xamarin_class_map [658].handle = objc_getClass ("MPSImageThresholdToZeroInverse");
	__xamarin_class_map [659].handle = objc_getClass ("MPSImageThresholdTruncate");
	__xamarin_class_map [660].handle = objc_getClass ("MPSImageTranspose");
	__xamarin_class_map [661].handle = objc_getClass ("MPSLSTMDescriptor");
	__xamarin_class_map [662].handle = objc_getClass ("MPSMatrix");
	__xamarin_class_map [663].handle = objc_getClass ("MPSMatrixBinaryKernel");
	__xamarin_class_map [664].handle = objc_getClass ("MPSMatrixCopy");
	__xamarin_class_map [665].handle = objc_getClass ("MPSMatrixCopyDescriptor");
	__xamarin_class_map [666].handle = objc_getClass ("MPSMatrixUnaryKernel");
	__xamarin_class_map [667].handle = objc_getClass ("MPSMatrixDecompositionCholesky");
	__xamarin_class_map [668].handle = objc_getClass ("MPSMatrixDecompositionLU");
	__xamarin_class_map [669].handle = objc_getClass ("MPSMatrixDescriptor");
	__xamarin_class_map [670].handle = objc_getClass ("MPSMatrixFindTopK");
	__xamarin_class_map [671].handle = objc_getClass ("MPSMatrixFullyConnected");
	__xamarin_class_map [672].handle = objc_getClass ("MPSMatrixSoftMax");
	__xamarin_class_map [673].handle = objc_getClass ("MPSMatrixLogSoftMax");
	__xamarin_class_map [674].handle = objc_getClass ("MPSMatrixMultiplication");
	__xamarin_class_map [675].handle = objc_getClass ("MPSMatrixNeuron");
	__xamarin_class_map [676].handle = objc_getClass ("MPSMatrixSolveCholesky");
	__xamarin_class_map [677].handle = objc_getClass ("MPSMatrixSolveLU");
	__xamarin_class_map [678].handle = objc_getClass ("MPSMatrixSolveTriangular");
	__xamarin_class_map [679].handle = objc_getClass ("MPSMatrixSum");
	__xamarin_class_map [680].handle = objc_getClass ("MPSMatrixVectorMultiplication");
	__xamarin_class_map [681].handle = objc_getClass ("MPSNNBinaryArithmeticNode");
	__xamarin_class_map [682].handle = objc_getClass ("MPSNNAdditionNode");
	__xamarin_class_map [683].handle = objc_getClass ("MPSNNScaleNode");
	__xamarin_class_map [684].handle = objc_getClass ("MPSNNBilinearScaleNode");
	__xamarin_class_map [685].handle = objc_getClass ("MPSNNConcatenationNode");
	__xamarin_class_map [686].handle = objc_getClass ("MPSNNDefaultPadding");
	__xamarin_class_map [687].handle = objc_getClass ("MPSNNDivisionNode");
	__xamarin_class_map [688].handle = objc_getClass ("MPSNNImageNode");
	__xamarin_class_map [689].handle = objc_getClass ("MPSNNLanczosScaleNode");
	__xamarin_class_map [690].handle = objc_getClass ("MPSNNMultiplicationNode");
	__xamarin_class_map [691].handle = objc_getClass ("MPSNNSubtractionNode");
	__xamarin_class_map [692].handle = objc_getClass ("MPSRNNImageInferenceLayer");
	__xamarin_class_map [693].handle = objc_getClass ("MPSRNNMatrixInferenceLayer");
	__xamarin_class_map [694].handle = objc_getClass ("MPSRNNRecurrentImageState");
	__xamarin_class_map [695].handle = objc_getClass ("MPSRNNRecurrentMatrixState");
	__xamarin_class_map [696].handle = objc_getClass ("MPSRNNSingleGateDescriptor");
	__xamarin_class_map [697].handle = objc_getClass ("MPSTemporaryImage");
	__xamarin_class_map [698].handle = objc_getClass ("MPSTemporaryMatrix");
	__xamarin_class_map [699].handle = objc_getClass ("MPSVector");
	__xamarin_class_map [700].handle = objc_getClass ("MPSTemporaryVector");
	__xamarin_class_map [701].handle = objc_getClass ("MPSVectorDescriptor");
	__xamarin_class_map [702].handle = objc_getClass ("MTKMesh");
	__xamarin_class_map [703].handle = objc_getClass ("MTKMeshBuffer");
	__xamarin_class_map [704].handle = objc_getClass ("MTKMeshBufferAllocator");
	__xamarin_class_map [705].handle = objc_getClass ("MTKSubmesh");
	__xamarin_class_map [706].handle = objc_getClass ("MTKView");
	__xamarin_class_map [707].handle = objc_getClass ("MTKViewDelegate");
	__xamarin_class_map [708].handle = objc_getClass ("MTLArgument");
	__xamarin_class_map [709].handle = objc_getClass ("MTLArgumentDescriptor");
	__xamarin_class_map [710].handle = objc_getClass ("MTLType");
	__xamarin_class_map [711].handle = objc_getClass ("MTLArrayType");
	__xamarin_class_map [712].handle = objc_getClass ("MTLAttribute");
	__xamarin_class_map [713].handle = objc_getClass ("MTLAttributeDescriptor");
	__xamarin_class_map [714].handle = objc_getClass ("MTLAttributeDescriptorArray");
	__xamarin_class_map [715].handle = objc_getClass ("MTLBufferLayoutDescriptor");
	__xamarin_class_map [716].handle = objc_getClass ("MTLBufferLayoutDescriptorArray");
	__xamarin_class_map [717].handle = objc_getClass ("MTLCaptureManager");
	__xamarin_class_map [718].handle = objc_getClass ("Xamarin_Mac__Metal_MTLCaptureScope");
	__xamarin_class_map [719].handle = objc_getClass ("MTLCompileOptions");
	__xamarin_class_map [720].handle = objc_getClass ("MTLComputePipelineDescriptor");
	__xamarin_class_map [721].handle = objc_getClass ("MTLComputePipelineReflection");
	__xamarin_class_map [722].handle = objc_getClass ("MTLDepthStencilDescriptor");
	__xamarin_class_map [723].handle = objc_getClass ("MTLDrawable");
	__xamarin_class_map [724].handle = objc_getClass ("MTLFunctionConstant");
	__xamarin_class_map [725].handle = objc_getClass ("MTLFunctionConstantValues");
	__xamarin_class_map [726].handle = objc_getClass ("MTLHeapDescriptor");
	__xamarin_class_map [727].handle = objc_getClass ("MTLIndirectCommandBufferDescriptor");
	__xamarin_class_map [728].handle = objc_getClass ("MTLPipelineBufferDescriptor");
	__xamarin_class_map [729].handle = objc_getClass ("MTLPipelineBufferDescriptorArray");
	__xamarin_class_map [730].handle = objc_getClass ("MTLPointerType");
	__xamarin_class_map [731].handle = objc_getClass ("MTLRenderPassAttachmentDescriptor");
	__xamarin_class_map [732].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptor");
	__xamarin_class_map [733].handle = objc_getClass ("MTLRenderPassColorAttachmentDescriptorArray");
	__xamarin_class_map [734].handle = objc_getClass ("MTLRenderPassDepthAttachmentDescriptor");
	__xamarin_class_map [735].handle = objc_getClass ("MTLRenderPassDescriptor");
	__xamarin_class_map [736].handle = objc_getClass ("MTLRenderPassStencilAttachmentDescriptor");
	__xamarin_class_map [737].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptor");
	__xamarin_class_map [738].handle = objc_getClass ("MTLRenderPipelineColorAttachmentDescriptorArray");
	__xamarin_class_map [739].handle = objc_getClass ("MTLRenderPipelineDescriptor");
	__xamarin_class_map [740].handle = objc_getClass ("MTLRenderPipelineReflection");
	__xamarin_class_map [741].handle = objc_getClass ("MTLSamplerDescriptor");
	__xamarin_class_map [742].handle = objc_getClass ("MTLSharedEventHandle");
	__xamarin_class_map [743].handle = objc_getClass ("MTLSharedEventListener");
	__xamarin_class_map [744].handle = objc_getClass ("MTLSharedTextureHandle");
	__xamarin_class_map [745].handle = objc_getClass ("MTLStageInputOutputDescriptor");
	__xamarin_class_map [746].handle = objc_getClass ("MTLStencilDescriptor");
	__xamarin_class_map [747].handle = objc_getClass ("MTLStructMember");
	__xamarin_class_map [748].handle = objc_getClass ("MTLStructType");
	__xamarin_class_map [749].handle = objc_getClass ("MTLTextureDescriptor");
	__xamarin_class_map [750].handle = objc_getClass ("MTLTextureReferenceType");
	__xamarin_class_map [751].handle = objc_getClass ("MTLVertexAttribute");
	__xamarin_class_map [752].handle = objc_getClass ("MTLVertexAttributeDescriptor");
	__xamarin_class_map [753].handle = objc_getClass ("MTLVertexAttributeDescriptorArray");
	__xamarin_class_map [754].handle = objc_getClass ("MTLVertexBufferLayoutDescriptor");
	__xamarin_class_map [755].handle = objc_getClass ("MTLVertexBufferLayoutDescriptorArray");
	__xamarin_class_map [756].handle = objc_getClass ("MTLVertexDescriptor");
	__xamarin_class_map [757].handle = objc_getClass ("MPRemoteCommandEvent");
	__xamarin_class_map [758].handle = objc_getClass ("MPChangeLanguageOptionCommandEvent");
	__xamarin_class_map [759].handle = objc_getClass ("MPRemoteCommand");
	__xamarin_class_map [760].handle = objc_getClass ("MPChangePlaybackPositionCommand");
	__xamarin_class_map [761].handle = objc_getClass ("MPChangePlaybackPositionCommandEvent");
	__xamarin_class_map [762].handle = objc_getClass ("MPChangePlaybackRateCommand");
	__xamarin_class_map [763].handle = objc_getClass ("MPChangePlaybackRateCommandEvent");
	__xamarin_class_map [764].handle = objc_getClass ("MPChangeRepeatModeCommand");
	__xamarin_class_map [765].handle = objc_getClass ("MPChangeRepeatModeCommandEvent");
	__xamarin_class_map [766].handle = objc_getClass ("MPChangeShuffleModeCommand");
	__xamarin_class_map [767].handle = objc_getClass ("MPChangeShuffleModeCommandEvent");
	__xamarin_class_map [768].handle = objc_getClass ("MPContentItem");
	__xamarin_class_map [769].handle = objc_getClass ("MPFeedbackCommand");
	__xamarin_class_map [770].handle = objc_getClass ("MPFeedbackCommandEvent");
	__xamarin_class_map [771].handle = objc_getClass ("MPMediaItem");
	__xamarin_class_map [772].handle = objc_getClass ("MPMediaItemArtwork");
	__xamarin_class_map [773].handle = objc_getClass ("MPNowPlayingInfoCenter");
	__xamarin_class_map [774].handle = objc_getClass ("MPNowPlayingInfoLanguageOption");
	__xamarin_class_map [775].handle = objc_getClass ("MPNowPlayingInfoLanguageOptionGroup");
	__xamarin_class_map [776].handle = objc_getClass ("MPRatingCommand");
	__xamarin_class_map [777].handle = objc_getClass ("MPRatingCommandEvent");
	__xamarin_class_map [778].handle = objc_getClass ("MPRemoteCommandCenter");
	__xamarin_class_map [779].handle = objc_getClass ("MPSeekCommandEvent");
	__xamarin_class_map [780].handle = objc_getClass ("MPSkipIntervalCommandEvent");
	__xamarin_class_map [781].handle = objc_getClass ("MLMediaGroup");
	__xamarin_class_map [782].handle = objc_getClass ("MLMediaLibrary");
	__xamarin_class_map [783].handle = objc_getClass ("MLMediaObject");
	__xamarin_class_map [784].handle = objc_getClass ("MLMediaSource");
	__xamarin_class_map [785].handle = objc_getClass ("MKAnnotation");
	__xamarin_class_map [786].handle = objc_getClass ("MKAnnotationView");
	__xamarin_class_map [787].handle = objc_getClass ("MKShape");
	__xamarin_class_map [788].handle = objc_getClass ("MKCircle");
	__xamarin_class_map [789].handle = objc_getClass ("MKOverlayRenderer");
	__xamarin_class_map [790].handle = objc_getClass ("MKOverlayPathRenderer");
	__xamarin_class_map [791].handle = objc_getClass ("MKCircleRenderer");
	__xamarin_class_map [792].handle = objc_getClass ("MKClusterAnnotation");
	__xamarin_class_map [793].handle = objc_getClass ("MKDirectionsRequest");
	__xamarin_class_map [794].handle = objc_getClass ("MKDirectionsResponse");
	__xamarin_class_map [795].handle = objc_getClass ("NSFormatter");
	__xamarin_class_map [796].handle = objc_getClass ("MKDistanceFormatter");
	__xamarin_class_map [797].handle = objc_getClass ("MKETAResponse");
	__xamarin_class_map [798].handle = objc_getClass ("MKMultiPoint");
	__xamarin_class_map [799].handle = objc_getClass ("MKPolyline");
	__xamarin_class_map [800].handle = objc_getClass ("MKGeodesicPolyline");
	__xamarin_class_map [801].handle = objc_getClass ("MKLocalSearchCompleter");
	__xamarin_class_map [802].handle = objc_getClass ("MKLocalSearchCompleterDelegate");
	__xamarin_class_map [803].handle = objc_getClass ("MKLocalSearchCompletion");
	__xamarin_class_map [804].handle = objc_getClass ("MKLocalSearchRequest");
	__xamarin_class_map [805].handle = objc_getClass ("MKLocalSearchResponse");
	__xamarin_class_map [806].handle = objc_getClass ("MKMapCamera");
	__xamarin_class_map [807].handle = objc_getClass ("MKMapItem");
	__xamarin_class_map [808].handle = objc_getClass ("MKMapSnapshot");
	__xamarin_class_map [809].handle = objc_getClass ("MKMapSnapshotOptions");
	__xamarin_class_map [810].handle = objc_getClass ("MKMapViewDelegate");
	__xamarin_class_map [811].handle = objc_getClass ("MKOverlay");
	__xamarin_class_map [812].handle = objc_getClass ("MKPinAnnotationView");
	__xamarin_class_map [813].handle = objc_getClass ("CLPlacemark");
	__xamarin_class_map [814].handle = objc_getClass ("MKPlacemark");
	__xamarin_class_map [815].handle = objc_getClass ("MKPointAnnotation");
	__xamarin_class_map [816].handle = objc_getClass ("MKPolygon");
	__xamarin_class_map [817].handle = objc_getClass ("MKPolygonRenderer");
	__xamarin_class_map [818].handle = objc_getClass ("MKPolylineRenderer");
	__xamarin_class_map [819].handle = objc_getClass ("MKRoute");
	__xamarin_class_map [820].handle = objc_getClass ("MKRouteStep");
	__xamarin_class_map [821].handle = objc_getClass ("MKTileOverlay");
	__xamarin_class_map [822].handle = objc_getClass ("MKTileOverlayRenderer");
	__xamarin_class_map [823].handle = objc_getClass ("MKUserLocation");
	__xamarin_class_map [824].handle = objc_getClass ("JSContext");
	__xamarin_class_map [825].handle = objc_getClass ("Xamarin_Mac__JavaScriptCore_JSExport");
	__xamarin_class_map [826].handle = objc_getClass ("JSManagedValue");
	__xamarin_class_map [827].handle = objc_getClass ("JSValue");
	__xamarin_class_map [828].handle = objc_getClass ("JSVirtualMachine");
	__xamarin_class_map [829].handle = objc_getClass ("ITLibAlbum");
	__xamarin_class_map [830].handle = objc_getClass ("ITLibArtist");
	__xamarin_class_map [831].handle = objc_getClass ("ITLibArtwork");
	__xamarin_class_map [832].handle = objc_getClass ("ITLibMediaEntity");
	__xamarin_class_map [833].handle = objc_getClass ("ITLibMediaItem");
	__xamarin_class_map [834].handle = objc_getClass ("ITLibMediaItemVideoInfo");
	__xamarin_class_map [835].handle = objc_getClass ("ITLibPlaylist");
	__xamarin_class_map [836].handle = objc_getClass ("ITLibrary");
	__xamarin_class_map [837].handle = objc_getClass ("IOSurface");
	__xamarin_class_map [838].handle = objc_getClass ("INIntentResolutionResult");
	__xamarin_class_map [839].handle = objc_getClass ("INCallDestinationTypeResolutionResult");
	__xamarin_class_map [840].handle = objc_getClass ("INCallRecord");
	__xamarin_class_map [841].handle = objc_getClass ("INCallRecordTypeOptionsResolutionResult");
	__xamarin_class_map [842].handle = objc_getClass ("INCallRecordTypeResolutionResult");
	__xamarin_class_map [843].handle = objc_getClass ("INDateComponentsRange");
	__xamarin_class_map [844].handle = objc_getClass ("INDateComponentsRangeResolutionResult");
	__xamarin_class_map [845].handle = objc_getClass ("INImage");
	__xamarin_class_map [846].handle = objc_getClass ("INIntent");
	__xamarin_class_map [847].handle = objc_getClass ("INIntentResponse");
	__xamarin_class_map [848].handle = objc_getClass ("INMessage");
	__xamarin_class_map [849].handle = objc_getClass ("INMessageAttributeOptionsResolutionResult");
	__xamarin_class_map [850].handle = objc_getClass ("INMessageAttributeResolutionResult");
	__xamarin_class_map [851].handle = objc_getClass ("INParameter");
	__xamarin_class_map [852].handle = objc_getClass ("INPerson");
	__xamarin_class_map [853].handle = objc_getClass ("INPersonHandle");
	__xamarin_class_map [854].handle = objc_getClass ("INPersonResolutionResult");
	__xamarin_class_map [855].handle = objc_getClass ("INPlacemarkResolutionResult");
	__xamarin_class_map [856].handle = objc_getClass ("INRecurrenceRule");
	__xamarin_class_map [857].handle = objc_getClass ("INSearchCallHistoryIntent");
	__xamarin_class_map [858].handle = objc_getClass ("INSearchCallHistoryIntentResponse");
	__xamarin_class_map [859].handle = objc_getClass ("INSearchForMessagesIntent");
	__xamarin_class_map [860].handle = objc_getClass ("INSearchForMessagesIntentResponse");
	__xamarin_class_map [861].handle = objc_getClass ("INSendMessageIntent");
	__xamarin_class_map [862].handle = objc_getClass ("INSendMessageIntentResponse");
	__xamarin_class_map [863].handle = objc_getClass ("INSendMessageRecipientResolutionResult");
	__xamarin_class_map [864].handle = objc_getClass ("INSpeakableString");
	__xamarin_class_map [865].handle = objc_getClass ("INSpeakableStringResolutionResult");
	__xamarin_class_map [866].handle = objc_getClass ("INStartAudioCallIntent");
	__xamarin_class_map [867].handle = objc_getClass ("INStartAudioCallIntentResponse");
	__xamarin_class_map [868].handle = objc_getClass ("INStartVideoCallIntent");
	__xamarin_class_map [869].handle = objc_getClass ("INStartVideoCallIntentResponse");
	__xamarin_class_map [870].handle = objc_getClass ("INStringResolutionResult");
	__xamarin_class_map [871].handle = objc_getClass ("IKCameraDeviceViewDelegate");
	__xamarin_class_map [872].handle = objc_getClass ("IKDeviceBrowserViewDelegate");
	__xamarin_class_map [873].handle = objc_getClass ("IKFilterBrowserView");
	__xamarin_class_map [874].handle = objc_getClass ("IKFilterCustomUIProvider");
	__xamarin_class_map [875].handle = objc_getClass ("IKFilterUIView");
	__xamarin_class_map [876].handle = objc_getClass ("IKImageBrowserCell");
	__xamarin_class_map [877].handle = objc_getClass ("IKImageBrowserDataSource");
	__xamarin_class_map [878].handle = objc_getClass ("IKImageBrowserDelegate");
	__xamarin_class_map [879].handle = objc_getClass ("IKImageBrowserItem");
	__xamarin_class_map [880].handle = objc_getClass ("IKImageEditPanel");
	__xamarin_class_map [881].handle = objc_getClass ("IKImageEditPanelDataSource");
	__xamarin_class_map [882].handle = objc_getClass ("IKImageView");
	__xamarin_class_map [883].handle = objc_getClass ("IKPictureTaker");
	__xamarin_class_map [884].handle = objc_getClass ("IKSaveOptionsDelegate");
	__xamarin_class_map [885].handle = objc_getClass ("IKScannerDeviceViewDelegate");
	__xamarin_class_map [886].handle = objc_getClass ("IKSlideshow");
	__xamarin_class_map [887].handle = objc_getClass ("IKSlideshowDataSource");
	__xamarin_class_map [888].handle = objc_getClass ("GLKBaseEffect");
	__xamarin_class_map [889].handle = objc_getClass ("GLKEffectProperty");
	__xamarin_class_map [890].handle = objc_getClass ("GLKEffectPropertyFog");
	__xamarin_class_map [891].handle = objc_getClass ("GLKEffectPropertyLight");
	__xamarin_class_map [892].handle = objc_getClass ("GLKEffectPropertyMaterial");
	__xamarin_class_map [893].handle = objc_getClass ("GLKEffectPropertyTexture");
	__xamarin_class_map [894].handle = objc_getClass ("GLKEffectPropertyTransform");
	__xamarin_class_map [895].handle = objc_getClass ("GLKMesh");
	__xamarin_class_map [896].handle = objc_getClass ("GLKMeshBuffer");
	__xamarin_class_map [897].handle = objc_getClass ("GLKMeshBufferAllocator");
	__xamarin_class_map [898].handle = objc_getClass ("GLKNamedEffect");
	__xamarin_class_map [899].handle = objc_getClass ("GLKReflectionMapEffect");
	__xamarin_class_map [900].handle = objc_getClass ("GLKSkyboxEffect");
	__xamarin_class_map [901].handle = objc_getClass ("GLKSubmesh");
	__xamarin_class_map [902].handle = objc_getClass ("GLKTextureInfo");
	__xamarin_class_map [903].handle = objc_getClass ("GKComponent");
	__xamarin_class_map [904].handle = objc_getClass ("GKAgent");
	__xamarin_class_map [905].handle = objc_getClass ("GKAgent2D");
	__xamarin_class_map [906].handle = objc_getClass ("GKAgent3D");
	__xamarin_class_map [907].handle = objc_getClass ("GKAgentDelegate");
	__xamarin_class_map [908].handle = objc_getClass ("GKRandomSource");
	__xamarin_class_map [909].handle = objc_getClass ("GKARC4RandomSource");
	__xamarin_class_map [910].handle = objc_getClass ("GKBehavior");
	__xamarin_class_map [911].handle = objc_getClass ("GKNoiseSource");
	__xamarin_class_map [912].handle = objc_getClass ("GKCoherentNoiseSource");
	__xamarin_class_map [913].handle = objc_getClass ("GKBillowNoiseSource");
	__xamarin_class_map [914].handle = objc_getClass ("GKCheckerboardNoiseSource");
	__xamarin_class_map [915].handle = objc_getClass ("GKObstacle");
	__xamarin_class_map [916].handle = objc_getClass ("GKCircleObstacle");
	__xamarin_class_map [917].handle = objc_getClass ("GKComponentSystem");
	__xamarin_class_map [918].handle = objc_getClass ("GKCompositeBehavior");
	__xamarin_class_map [919].handle = objc_getClass ("GKConstantNoiseSource");
	__xamarin_class_map [920].handle = objc_getClass ("GKCylindersNoiseSource");
	__xamarin_class_map [921].handle = objc_getClass ("GKDecisionNode");
	__xamarin_class_map [922].handle = objc_getClass ("GKDecisionTree");
	__xamarin_class_map [923].handle = objc_getClass ("GKEntity");
	__xamarin_class_map [924].handle = objc_getClass ("GKRandomDistribution");
	__xamarin_class_map [925].handle = objc_getClass ("GKGaussianDistribution");
	__xamarin_class_map [926].handle = objc_getClass ("GKGoal");
	__xamarin_class_map [927].handle = objc_getClass ("GKGraph");
	__xamarin_class_map [928].handle = objc_getClass ("GKGraphNode");
	__xamarin_class_map [929].handle = objc_getClass ("GKGraphNode2D");
	__xamarin_class_map [930].handle = objc_getClass ("GKGraphNode3D");
	__xamarin_class_map [931].handle = objc_getClass ("GKGridGraph");
	__xamarin_class_map [932].handle = objc_getClass ("GKGridGraphNode");
	__xamarin_class_map [933].handle = objc_getClass ("GKLinearCongruentialRandomSource");
	__xamarin_class_map [934].handle = objc_getClass ("GKMersenneTwisterRandomSource");
	__xamarin_class_map [935].handle = objc_getClass ("GKMeshGraph");
	__xamarin_class_map [936].handle = objc_getClass ("GKMinmaxStrategist");
	__xamarin_class_map [937].handle = objc_getClass ("GKMonteCarloStrategist");
	__xamarin_class_map [938].handle = objc_getClass ("GKNoise");
	__xamarin_class_map [939].handle = objc_getClass ("GKNoiseMap");
	__xamarin_class_map [940].handle = objc_getClass ("GKRule");
	__xamarin_class_map [941].handle = objc_getClass ("GKNSPredicateRule");
	__xamarin_class_map [942].handle = objc_getClass ("GKObstacleGraph");
	__xamarin_class_map [943].handle = objc_getClass ("GKOctree");
	__xamarin_class_map [944].handle = objc_getClass ("GKOctreeNode");
	__xamarin_class_map [945].handle = objc_getClass ("GKPath");
	__xamarin_class_map [946].handle = objc_getClass ("GKPerlinNoiseSource");
	__xamarin_class_map [947].handle = objc_getClass ("GKPolygonObstacle");
	__xamarin_class_map [948].handle = objc_getClass ("GKQuadtree");
	__xamarin_class_map [949].handle = objc_getClass ("GKQuadtreeNode");
	__xamarin_class_map [950].handle = objc_getClass ("GKRidgedNoiseSource");
	__xamarin_class_map [951].handle = objc_getClass ("GKRTree");
	__xamarin_class_map [952].handle = objc_getClass ("GKRuleSystem");
	__xamarin_class_map [953].handle = objc_getClass ("GKScene");
	__xamarin_class_map [954].handle = objc_getClass ("GKSCNNodeComponent");
	__xamarin_class_map [955].handle = objc_getClass ("GKShuffledDistribution");
	__xamarin_class_map [956].handle = objc_getClass ("GKSKNodeComponent");
	__xamarin_class_map [957].handle = objc_getClass ("GKSphereObstacle");
	__xamarin_class_map [958].handle = objc_getClass ("GKSpheresNoiseSource");
	__xamarin_class_map [959].handle = objc_getClass ("GKState");
	__xamarin_class_map [960].handle = objc_getClass ("GKStateMachine");
	__xamarin_class_map [961].handle = objc_getClass ("GKVoronoiNoiseSource");
	__xamarin_class_map [962].handle = objc_getClass ("GKChallenge");
	__xamarin_class_map [963].handle = objc_getClass ("GKAchievementChallenge");
	__xamarin_class_map [964].handle = objc_getClass ("GKAchievementViewControllerDelegate");
	__xamarin_class_map [965].handle = objc_getClass ("GKBasePlayer");
	__xamarin_class_map [966].handle = objc_getClass ("GKChallengeEventHandlerDelegate");
	__xamarin_class_map [967].handle = objc_getClass ("GKChallengeListener");
	__xamarin_class_map [968].handle = objc_getClass ("GKChallengesViewController");
	__xamarin_class_map [969].handle = objc_getClass ("GKChallengesViewControllerDelegate");
	__xamarin_class_map [970].handle = objc_getClass ("GKCloudPlayer");
	__xamarin_class_map [971].handle = objc_getClass ("GKDialogController");
	__xamarin_class_map [972].handle = objc_getClass ("GKFriendRequestComposeViewControllerDelegate");
	__xamarin_class_map [973].handle = objc_getClass ("GKGameCenterControllerDelegate");
	__xamarin_class_map [974].handle = objc_getClass ("GKInvite");
	__xamarin_class_map [975].handle = objc_getClass ("GKInviteEventListener");
	__xamarin_class_map [976].handle = objc_getClass ("GKLeaderboardViewControllerDelegate");
	__xamarin_class_map [977].handle = objc_getClass ("GKLocalPlayerListener");
	__xamarin_class_map [978].handle = objc_getClass ("GKMatchDelegate");
	__xamarin_class_map [979].handle = objc_getClass ("GKMatchmakerViewControllerDelegate");
	__xamarin_class_map [980].handle = objc_getClass ("GKMatchRequest");
	__xamarin_class_map [981].handle = objc_getClass ("GKSavedGameListener");
	__xamarin_class_map [982].handle = objc_getClass ("GKScoreChallenge");
	__xamarin_class_map [983].handle = objc_getClass ("GKSession");
	__xamarin_class_map [984].handle = objc_getClass ("GKSessionDelegate");
	__xamarin_class_map [985].handle = objc_getClass ("GKTurnBasedEventHandler");
	__xamarin_class_map [986].handle = objc_getClass ("GKTurnBasedEventHandlerDelegate");
	__xamarin_class_map [987].handle = objc_getClass ("GKTurnBasedEventListener");
	__xamarin_class_map [988].handle = objc_getClass ("GKTurnBasedExchangeReply");
	__xamarin_class_map [989].handle = objc_getClass ("GKTurnBasedMatchmakerViewController");
	__xamarin_class_map [990].handle = objc_getClass ("GKTurnBasedMatchmakerViewControllerDelegate");
	__xamarin_class_map [991].handle = objc_getClass ("GKTurnBasedParticipant");
	__xamarin_class_map [992].handle = objc_getClass ("GKVoiceChat");
	__xamarin_class_map [993].handle = objc_getClass ("GCControllerElement");
	__xamarin_class_map [994].handle = objc_getClass ("GCControllerAxisInput");
	__xamarin_class_map [995].handle = objc_getClass ("GCControllerButtonInput");
	__xamarin_class_map [996].handle = objc_getClass ("GCControllerDirectionPad");
	__xamarin_class_map [997].handle = objc_getClass ("GCEventViewController");
	__xamarin_class_map [998].handle = objc_getClass ("GCExtendedGamepad");
	__xamarin_class_map [999].handle = objc_getClass ("GCExtendedGamepadSnapshot");
	__xamarin_class_map [1000].handle = objc_getClass ("GCGamepad");
	__xamarin_class_map [1001].handle = objc_getClass ("GCGamepadSnapshot");
	__xamarin_class_map [1002].handle = objc_getClass ("GCMicroGamepad");
	__xamarin_class_map [1003].handle = objc_getClass ("GCMicroGamepadSnapshot");
	__xamarin_class_map [1004].handle = objc_getClass ("GCMotion");
	__xamarin_class_map [1005].handle = objc_getClass ("EAAccessoryDelegate");
	__xamarin_class_map [1006].handle = objc_getClass ("EASession");
	__xamarin_class_map [1007].handle = objc_getClass ("EKObject");
	__xamarin_class_map [1008].handle = objc_getClass ("EKAlarm");
	__xamarin_class_map [1009].handle = objc_getClass ("EKCalendar");
	__xamarin_class_map [1010].handle = objc_getClass ("EKCalendarItem");
	__xamarin_class_map [1011].handle = objc_getClass ("EKEvent");
	__xamarin_class_map [1012].handle = objc_getClass ("EKParticipant");
	__xamarin_class_map [1013].handle = objc_getClass ("EKRecurrenceDayOfWeek");
	__xamarin_class_map [1014].handle = objc_getClass ("EKRecurrenceEnd");
	__xamarin_class_map [1015].handle = objc_getClass ("EKRecurrenceRule");
	__xamarin_class_map [1016].handle = objc_getClass ("EKReminder");
	__xamarin_class_map [1017].handle = objc_getClass ("EKSource");
	__xamarin_class_map [1018].handle = objc_getClass ("EKStructuredLocation");
	__xamarin_class_map [1019].handle = objc_getClass ("CW8021XProfile");
	__xamarin_class_map [1020].handle = objc_getClass ("CWChannel");
	__xamarin_class_map [1021].handle = objc_getClass ("CWConfiguration");
	__xamarin_class_map [1022].handle = objc_getClass ("CWEventDelegate");
	__xamarin_class_map [1023].handle = objc_getClass ("CWMutableConfiguration");
	__xamarin_class_map [1024].handle = objc_getClass ("CWNetworkProfile");
	__xamarin_class_map [1025].handle = objc_getClass ("CWMutableNetworkProfile");
	__xamarin_class_map [1026].handle = objc_getClass ("CWNetwork");
	__xamarin_class_map [1027].handle = objc_getClass ("CWWiFiClient");
	__xamarin_class_map [1028].handle = objc_getClass ("CWWirelessProfile");
	__xamarin_class_map [1029].handle = objc_getClass ("CSCustomAttributeKey");
	__xamarin_class_map [1030].handle = objc_getClass ("CSIndexExtensionRequestHandler");
	__xamarin_class_map [1031].handle = objc_getClass ("NSString");
	__xamarin_class_map [1032].handle = objc_getClass ("CSLocalizedString");
	__xamarin_class_map [1033].handle = objc_getClass ("CSPerson");
	__xamarin_class_map [1034].handle = objc_getClass ("CSSearchableIndexDelegate");
	__xamarin_class_map [1035].handle = objc_getClass ("CSSearchableItem");
	__xamarin_class_map [1036].handle = objc_getClass ("CSSearchableItemAttributeSet");
	__xamarin_class_map [1037].handle = objc_getClass ("CSSearchQuery");
	__xamarin_class_map [1038].handle = objc_getClass ("MLArrayBatchProvider");
	__xamarin_class_map [1039].handle = objc_getClass ("Xamarin_Mac__CoreML_MLCustomModel");
	__xamarin_class_map [1040].handle = objc_getClass ("MLDictionaryConstraint");
	__xamarin_class_map [1041].handle = objc_getClass ("MLDictionaryFeatureProvider");
	__xamarin_class_map [1042].handle = objc_getClass ("MLFeatureDescription");
	__xamarin_class_map [1043].handle = objc_getClass ("MLFeatureValue");
	__xamarin_class_map [1044].handle = objc_getClass ("MLImageConstraint");
	__xamarin_class_map [1045].handle = objc_getClass ("MLImageSize");
	__xamarin_class_map [1046].handle = objc_getClass ("MLImageSizeConstraint");
	__xamarin_class_map [1047].handle = objc_getClass ("MLModel");
	__xamarin_class_map [1048].handle = objc_getClass ("MLModelConfiguration");
	__xamarin_class_map [1049].handle = objc_getClass ("MLModelDescription");
	__xamarin_class_map [1050].handle = objc_getClass ("MLMultiArrayConstraint");
	__xamarin_class_map [1051].handle = objc_getClass ("MLMultiArrayShapeConstraint");
	__xamarin_class_map [1052].handle = objc_getClass ("MLPredictionOptions");
	__xamarin_class_map [1053].handle = objc_getClass ("MLSequence");
	__xamarin_class_map [1054].handle = objc_getClass ("MLSequenceConstraint");
	__xamarin_class_map [1055].handle = objc_getClass ("MIDICIProfile");
	__xamarin_class_map [1056].handle = objc_getClass ("MIDICIProfileState");
	__xamarin_class_map [1057].handle = objc_getClass ("MIDICISession");
	__xamarin_class_map [1058].handle = objc_getClass ("CLRegion");
	__xamarin_class_map [1059].handle = objc_getClass ("CLCircularRegion");
	__xamarin_class_map [1060].handle = objc_getClass ("CLHeading");
	__xamarin_class_map [1061].handle = objc_getClass ("CLLocation");
	__xamarin_class_map [1062].handle = objc_getClass ("CLLocationManagerDelegate");
	__xamarin_class_map [1063].handle = objc_getClass ("CIFilter");
	__xamarin_class_map [1064].handle = objc_getClass ("CoreImage_CIAccordionFoldTransition");
	__xamarin_class_map [1065].handle = objc_getClass ("CoreImage_CICompositingFilter");
	__xamarin_class_map [1066].handle = objc_getClass ("CoreImage_CIAdditionCompositing");
	__xamarin_class_map [1067].handle = objc_getClass ("CoreImage_CIAffineFilter");
	__xamarin_class_map [1068].handle = objc_getClass ("CoreImage_CIAffineClamp");
	__xamarin_class_map [1069].handle = objc_getClass ("CoreImage_CIAffineTile");
	__xamarin_class_map [1070].handle = objc_getClass ("CoreImage_CIAffineTransform");
	__xamarin_class_map [1071].handle = objc_getClass ("CoreImage_CIAreaAverage");
	__xamarin_class_map [1072].handle = objc_getClass ("CoreImage_CIAreaHistogram");
	__xamarin_class_map [1073].handle = objc_getClass ("CoreImage_CIReductionFilter");
	__xamarin_class_map [1074].handle = objc_getClass ("CoreImage_CIAreaMaximum");
	__xamarin_class_map [1075].handle = objc_getClass ("CoreImage_CIAreaMaximumAlpha");
	__xamarin_class_map [1076].handle = objc_getClass ("CoreImage_CIAreaMinimum");
	__xamarin_class_map [1077].handle = objc_getClass ("CoreImage_CIAreaMinimumAlpha");
	__xamarin_class_map [1078].handle = objc_getClass ("CoreImage_CIAreaMinMax");
	__xamarin_class_map [1079].handle = objc_getClass ("CoreImage_CIAreaMinMaxRed");
	__xamarin_class_map [1080].handle = objc_getClass ("CoreImage_CIImageGenerator");
	__xamarin_class_map [1081].handle = objc_getClass ("CoreImage_CIAttributedTextImageGenerator");
	__xamarin_class_map [1082].handle = objc_getClass ("CIBarcodeDescriptor");
	__xamarin_class_map [1083].handle = objc_getClass ("CIAztecCodeDescriptor");
	__xamarin_class_map [1084].handle = objc_getClass ("CoreImage_CICodeGenerator");
	__xamarin_class_map [1085].handle = objc_getClass ("CoreImage_CIAztecCodeGenerator");
	__xamarin_class_map [1086].handle = objc_getClass ("CoreImage_CIBarcodeGenerator");
	__xamarin_class_map [1087].handle = objc_getClass ("CoreImage_CITransitionFilter");
	__xamarin_class_map [1088].handle = objc_getClass ("CoreImage_CIBarsSwipeTransition");
	__xamarin_class_map [1089].handle = objc_getClass ("CoreImage_CIBicubicScaleTransform");
	__xamarin_class_map [1090].handle = objc_getClass ("CoreImage_CIBlendFilter");
	__xamarin_class_map [1091].handle = objc_getClass ("CIKernel");
	__xamarin_class_map [1092].handle = objc_getClass ("CIColorKernel");
	__xamarin_class_map [1093].handle = objc_getClass ("CIBlendKernel");
	__xamarin_class_map [1094].handle = objc_getClass ("CoreImage_CIBlendWithMask");
	__xamarin_class_map [1095].handle = objc_getClass ("CoreImage_CIBlendWithAlphaMask");
	__xamarin_class_map [1096].handle = objc_getClass ("CoreImage_CIBlendWithBlueMask");
	__xamarin_class_map [1097].handle = objc_getClass ("CoreImage_CIBlendWithRedMask");
	__xamarin_class_map [1098].handle = objc_getClass ("CoreImage_CIBloom");
	__xamarin_class_map [1099].handle = objc_getClass ("CoreImage_CILinearBlur");
	__xamarin_class_map [1100].handle = objc_getClass ("CoreImage_CIBokehBlur");
	__xamarin_class_map [1101].handle = objc_getClass ("CoreImage_CIBoxBlur");
	__xamarin_class_map [1102].handle = objc_getClass ("CoreImage_CIDistortionFilter");
	__xamarin_class_map [1103].handle = objc_getClass ("CoreImage_CIBumpDistortion");
	__xamarin_class_map [1104].handle = objc_getClass ("CoreImage_CIBumpDistortionLinear");
	__xamarin_class_map [1105].handle = objc_getClass ("CoreImage_CICameraCalibrationLensCorrection");
	__xamarin_class_map [1106].handle = objc_getClass ("CoreImage_CICheckerboardGenerator");
	__xamarin_class_map [1107].handle = objc_getClass ("CoreImage_CICircleSplashDistortion");
	__xamarin_class_map [1108].handle = objc_getClass ("CoreImage_CIScreenFilter");
	__xamarin_class_map [1109].handle = objc_getClass ("CoreImage_CICircularScreen");
	__xamarin_class_map [1110].handle = objc_getClass ("CoreImage_CICircularWrap");
	__xamarin_class_map [1111].handle = objc_getClass ("CoreImage_CIClamp");
	__xamarin_class_map [1112].handle = objc_getClass ("CoreImage_CICmykHalftone");
	__xamarin_class_map [1113].handle = objc_getClass ("CoreImage_CICode128BarcodeGenerator");
	__xamarin_class_map [1114].handle = objc_getClass ("CIColor");
	__xamarin_class_map [1115].handle = objc_getClass ("CoreImage_CIColorBlendMode");
	__xamarin_class_map [1116].handle = objc_getClass ("CoreImage_CIColorBurnBlendMode");
	__xamarin_class_map [1117].handle = objc_getClass ("CoreImage_CIColorClamp");
	__xamarin_class_map [1118].handle = objc_getClass ("CoreImage_CIColorControls");
	__xamarin_class_map [1119].handle = objc_getClass ("CoreImage_CIColorCrossPolynomial");
	__xamarin_class_map [1120].handle = objc_getClass ("CoreImage_CIColorCube");
	__xamarin_class_map [1121].handle = objc_getClass ("CoreImage_CIColorCubesMixedWithMask");
	__xamarin_class_map [1122].handle = objc_getClass ("CoreImage_CIColorCubeWithColorSpace");
	__xamarin_class_map [1123].handle = objc_getClass ("CoreImage_CIColorCurves");
	__xamarin_class_map [1124].handle = objc_getClass ("CoreImage_CIColorDodgeBlendMode");
	__xamarin_class_map [1125].handle = objc_getClass ("CoreImage_CIColorInvert");
	__xamarin_class_map [1126].handle = objc_getClass ("CoreImage_CIColorMap");
	__xamarin_class_map [1127].handle = objc_getClass ("CoreImage_CIColorMatrix");
	__xamarin_class_map [1128].handle = objc_getClass ("CoreImage_CIColorMonochrome");
	__xamarin_class_map [1129].handle = objc_getClass ("CoreImage_CIColorPolynomial");
	__xamarin_class_map [1130].handle = objc_getClass ("CoreImage_CIColorPosterize");
	__xamarin_class_map [1131].handle = objc_getClass ("CoreImage_CIColumnAverage");
	__xamarin_class_map [1132].handle = objc_getClass ("CoreImage_CIComicEffect");
	__xamarin_class_map [1133].handle = objc_getClass ("CoreImage_CIConstantColorGenerator");
	__xamarin_class_map [1134].handle = objc_getClass ("CIContext");
	__xamarin_class_map [1135].handle = objc_getClass ("CoreImage_CIConvolutionCore");
	__xamarin_class_map [1136].handle = objc_getClass ("CoreImage_CIConvolution3X3");
	__xamarin_class_map [1137].handle = objc_getClass ("CoreImage_CIConvolution5X5");
	__xamarin_class_map [1138].handle = objc_getClass ("CoreImage_CIConvolution7X7");
	__xamarin_class_map [1139].handle = objc_getClass ("CoreImage_CIConvolution9Horizontal");
	__xamarin_class_map [1140].handle = objc_getClass ("CoreImage_CIConvolution9Vertical");
	__xamarin_class_map [1141].handle = objc_getClass ("CoreImage_CICopyMachineTransition");
	__xamarin_class_map [1142].handle = objc_getClass ("CoreImage_CICoreMLModelFilter");
	__xamarin_class_map [1143].handle = objc_getClass ("CoreImage_CICrop");
	__xamarin_class_map [1144].handle = objc_getClass ("CoreImage_CICrystallize");
	__xamarin_class_map [1145].handle = objc_getClass ("CoreImage_CIDarkenBlendMode");
	__xamarin_class_map [1146].handle = objc_getClass ("CIDataMatrixCodeDescriptor");
	__xamarin_class_map [1147].handle = objc_getClass ("CoreImage_CIDepthBlurEffect");
	__xamarin_class_map [1148].handle = objc_getClass ("CoreImage_CIDepthDisparityConverter");
	__xamarin_class_map [1149].handle = objc_getClass ("CoreImage_CIDepthOfField");
	__xamarin_class_map [1150].handle = objc_getClass ("CoreImage_CIDepthToDisparity");
	__xamarin_class_map [1151].handle = objc_getClass ("CIDetector");
	__xamarin_class_map [1152].handle = objc_getClass ("CoreImage_CIDifferenceBlendMode");
	__xamarin_class_map [1153].handle = objc_getClass ("CoreImage_CIDiscBlur");
	__xamarin_class_map [1154].handle = objc_getClass ("CoreImage_CIDisintegrateWithMaskTransition");
	__xamarin_class_map [1155].handle = objc_getClass ("CoreImage_CIDisparityToDepth");
	__xamarin_class_map [1156].handle = objc_getClass ("CoreImage_CIDisplacementDistortion");
	__xamarin_class_map [1157].handle = objc_getClass ("CoreImage_CIDissolveTransition");
	__xamarin_class_map [1158].handle = objc_getClass ("CoreImage_CIDither");
	__xamarin_class_map [1159].handle = objc_getClass ("CoreImage_CIDivideBlendMode");
	__xamarin_class_map [1160].handle = objc_getClass ("CoreImage_CIDotScreen");
	__xamarin_class_map [1161].handle = objc_getClass ("CoreImage_CIDroste");
	__xamarin_class_map [1162].handle = objc_getClass ("CoreImage_CIEdgePreserveUpsampleFilter");
	__xamarin_class_map [1163].handle = objc_getClass ("CoreImage_CIEdges");
	__xamarin_class_map [1164].handle = objc_getClass ("CoreImage_CIEdgeWork");
	__xamarin_class_map [1165].handle = objc_getClass ("CoreImage_CITileFilter");
	__xamarin_class_map [1166].handle = objc_getClass ("CoreImage_CIEightfoldReflectedTile");
	__xamarin_class_map [1167].handle = objc_getClass ("CoreImage_CIExclusionBlendMode");
	__xamarin_class_map [1168].handle = objc_getClass ("CoreImage_CIExposureAdjust");
	__xamarin_class_map [1169].handle = objc_getClass ("CoreImage_CIFaceBalance");
	__xamarin_class_map [1170].handle = objc_getClass ("CIFeature");
	__xamarin_class_map [1171].handle = objc_getClass ("CIFaceFeature");
	__xamarin_class_map [1172].handle = objc_getClass ("CoreImage_CIFalseColor");
	__xamarin_class_map [1173].handle = objc_getClass ("CIFilterGenerator");
	__xamarin_class_map [1174].handle = objc_getClass ("CIFilterShape");
	__xamarin_class_map [1175].handle = objc_getClass ("CoreImage_CIFlashTransition");
	__xamarin_class_map [1176].handle = objc_getClass ("CoreImage_CIFourfoldReflectedTile");
	__xamarin_class_map [1177].handle = objc_getClass ("CoreImage_CIFourfoldRotatedTile");
	__xamarin_class_map [1178].handle = objc_getClass ("CoreImage_CIFourfoldTranslatedTile");
	__xamarin_class_map [1179].handle = objc_getClass ("CoreImage_CIGammaAdjust");
	__xamarin_class_map [1180].handle = objc_getClass ("CoreImage_CIGaussianBlur");
	__xamarin_class_map [1181].handle = objc_getClass ("CoreImage_CIGaussianGradient");
	__xamarin_class_map [1182].handle = objc_getClass ("CoreImage_CIGlassDistortion");
	__xamarin_class_map [1183].handle = objc_getClass ("CoreImage_CIGlassLozenge");
	__xamarin_class_map [1184].handle = objc_getClass ("CoreImage_CIGlideReflectedTile");
	__xamarin_class_map [1185].handle = objc_getClass ("CoreImage_CIGloom");
	__xamarin_class_map [1186].handle = objc_getClass ("CoreImage_CIGuidedFilter");
	__xamarin_class_map [1187].handle = objc_getClass ("CoreImage_CIHardLightBlendMode");
	__xamarin_class_map [1188].handle = objc_getClass ("CoreImage_CIHatchedScreen");
	__xamarin_class_map [1189].handle = objc_getClass ("CoreImage_CIHeightFieldFromMask");
	__xamarin_class_map [1190].handle = objc_getClass ("CoreImage_CIHexagonalPixellate");
	__xamarin_class_map [1191].handle = objc_getClass ("CoreImage_CIHighlightShadowAdjust");
	__xamarin_class_map [1192].handle = objc_getClass ("CoreImage_CIHistogramDisplayFilter");
	__xamarin_class_map [1193].handle = objc_getClass ("CoreImage_CIHoleDistortion");
	__xamarin_class_map [1194].handle = objc_getClass ("CoreImage_CIHueAdjust");
	__xamarin_class_map [1195].handle = objc_getClass ("CoreImage_CIHueBlendMode");
	__xamarin_class_map [1196].handle = objc_getClass ("CoreImage_CIHueSaturationValueGradient");
	__xamarin_class_map [1197].handle = objc_getClass ("CIImage");
	__xamarin_class_map [1198].handle = objc_getClass ("CIImageAccumulator");
	__xamarin_class_map [1199].handle = objc_getClass ("CIImageProcessorKernel");
	__xamarin_class_map [1200].handle = objc_getClass ("CoreImage_CIKaleidoscope");
	__xamarin_class_map [1201].handle = objc_getClass ("CoreImage_CILabDeltaE");
	__xamarin_class_map [1202].handle = objc_getClass ("CoreImage_CILanczosScaleTransform");
	__xamarin_class_map [1203].handle = objc_getClass ("CoreImage_CILenticularHaloGenerator");
	__xamarin_class_map [1204].handle = objc_getClass ("CoreImage_CILightenBlendMode");
	__xamarin_class_map [1205].handle = objc_getClass ("CoreImage_CILightTunnel");
	__xamarin_class_map [1206].handle = objc_getClass ("CoreImage_CILinearBurnBlendMode");
	__xamarin_class_map [1207].handle = objc_getClass ("CoreImage_CILinearDodgeBlendMode");
	__xamarin_class_map [1208].handle = objc_getClass ("CoreImage_CILinearGradient");
	__xamarin_class_map [1209].handle = objc_getClass ("CoreImage_CILinearToSRGBToneCurve");
	__xamarin_class_map [1210].handle = objc_getClass ("CoreImage_CILineOverlay");
	__xamarin_class_map [1211].handle = objc_getClass ("CoreImage_CILineScreen");
	__xamarin_class_map [1212].handle = objc_getClass ("CoreImage_CILuminosityBlendMode");
	__xamarin_class_map [1213].handle = objc_getClass ("CoreImage_CIMaskedVariableBlur");
	__xamarin_class_map [1214].handle = objc_getClass ("CoreImage_CIMaskToAlpha");
	__xamarin_class_map [1215].handle = objc_getClass ("CoreImage_CIMaximumComponent");
	__xamarin_class_map [1216].handle = objc_getClass ("CoreImage_CIMaximumCompositing");
	__xamarin_class_map [1217].handle = objc_getClass ("CoreImage_CIMedianFilter");
	__xamarin_class_map [1218].handle = objc_getClass ("CoreImage_CIMeshGenerator");
	__xamarin_class_map [1219].handle = objc_getClass ("CoreImage_CIMinimumComponent");
	__xamarin_class_map [1220].handle = objc_getClass ("CoreImage_CIMinimumCompositing");
	__xamarin_class_map [1221].handle = objc_getClass ("CoreImage_CIMix");
	__xamarin_class_map [1222].handle = objc_getClass ("CoreImage_CIModTransition");
	__xamarin_class_map [1223].handle = objc_getClass ("CoreImage_CIMorphology");
	__xamarin_class_map [1224].handle = objc_getClass ("CoreImage_CIMorphologyGradient");
	__xamarin_class_map [1225].handle = objc_getClass ("CoreImage_CIMorphologyMaximum");
	__xamarin_class_map [1226].handle = objc_getClass ("CoreImage_CIMorphologyMinimum");
	__xamarin_class_map [1227].handle = objc_getClass ("CoreImage_CIMotionBlur");
	__xamarin_class_map [1228].handle = objc_getClass ("CoreImage_CIMultiplyBlendMode");
	__xamarin_class_map [1229].handle = objc_getClass ("CoreImage_CIMultiplyCompositing");
	__xamarin_class_map [1230].handle = objc_getClass ("CoreImage_CINinePartStretched");
	__xamarin_class_map [1231].handle = objc_getClass ("CoreImage_CINinePartTiled");
	__xamarin_class_map [1232].handle = objc_getClass ("CoreImage_CINoiseReduction");
	__xamarin_class_map [1233].handle = objc_getClass ("CoreImage_CIOpTile");
	__xamarin_class_map [1234].handle = objc_getClass ("CoreImage_CIOverlayBlendMode");
	__xamarin_class_map [1235].handle = objc_getClass ("CoreImage_CIPageCurlTransition");
	__xamarin_class_map [1236].handle = objc_getClass ("CoreImage_CIPageCurlWithShadowTransition");
	__xamarin_class_map [1237].handle = objc_getClass ("CoreImage_CIParallelogramTile");
	__xamarin_class_map [1238].handle = objc_getClass ("CoreImage_CIPdf417BarcodeGenerator");
	__xamarin_class_map [1239].handle = objc_getClass ("CIPDF417CodeDescriptor");
	__xamarin_class_map [1240].handle = objc_getClass ("CoreImage_CIPerspectiveTransform");
	__xamarin_class_map [1241].handle = objc_getClass ("CoreImage_CIPerspectiveCorrection");
	__xamarin_class_map [1242].handle = objc_getClass ("CoreImage_CIPerspectiveTile");
	__xamarin_class_map [1243].handle = objc_getClass ("CoreImage_CIPerspectiveTransformWithExtent");
	__xamarin_class_map [1244].handle = objc_getClass ("CoreImage_CIPhotoEffect");
	__xamarin_class_map [1245].handle = objc_getClass ("CoreImage_CIPhotoEffectChrome");
	__xamarin_class_map [1246].handle = objc_getClass ("CoreImage_CIPhotoEffectFade");
	__xamarin_class_map [1247].handle = objc_getClass ("CoreImage_CIPhotoEffectInstant");
	__xamarin_class_map [1248].handle = objc_getClass ("CoreImage_CIPhotoEffectMono");
	__xamarin_class_map [1249].handle = objc_getClass ("CoreImage_CIPhotoEffectNoir");
	__xamarin_class_map [1250].handle = objc_getClass ("CoreImage_CIPhotoEffectProcess");
	__xamarin_class_map [1251].handle = objc_getClass ("CoreImage_CIPhotoEffectTonal");
	__xamarin_class_map [1252].handle = objc_getClass ("CoreImage_CIPhotoEffectTransfer");
	__xamarin_class_map [1253].handle = objc_getClass ("CoreImage_CIPinchDistortion");
	__xamarin_class_map [1254].handle = objc_getClass ("CoreImage_CIPinLightBlendMode");
	__xamarin_class_map [1255].handle = objc_getClass ("CoreImage_CIPixellate");
	__xamarin_class_map [1256].handle = objc_getClass ("CIPlugIn");
	__xamarin_class_map [1257].handle = objc_getClass ("CoreImage_CIPointillize");
	__xamarin_class_map [1258].handle = objc_getClass ("CIQRCodeDescriptor");
	__xamarin_class_map [1259].handle = objc_getClass ("CIQRCodeFeature");
	__xamarin_class_map [1260].handle = objc_getClass ("CoreImage_CIQRCodeGenerator");
	__xamarin_class_map [1261].handle = objc_getClass ("CoreImage_CIRadialGradient");
	__xamarin_class_map [1262].handle = objc_getClass ("CoreImage_CIRandomGenerator");
	__xamarin_class_map [1263].handle = objc_getClass ("CIRectangleFeature");
	__xamarin_class_map [1264].handle = objc_getClass ("CIRenderDestination");
	__xamarin_class_map [1265].handle = objc_getClass ("CIRenderInfo");
	__xamarin_class_map [1266].handle = objc_getClass ("CIRenderTask");
	__xamarin_class_map [1267].handle = objc_getClass ("CoreImage_CIRippleTransition");
	__xamarin_class_map [1268].handle = objc_getClass ("CoreImage_CIRowAverage");
	__xamarin_class_map [1269].handle = objc_getClass ("CoreImage_CISaliencyMapFilter");
	__xamarin_class_map [1270].handle = objc_getClass ("CoreImage_CISampleNearest");
	__xamarin_class_map [1271].handle = objc_getClass ("CISampler");
	__xamarin_class_map [1272].handle = objc_getClass ("CoreImage_CISaturationBlendMode");
	__xamarin_class_map [1273].handle = objc_getClass ("CoreImage_CIScreenBlendMode");
	__xamarin_class_map [1274].handle = objc_getClass ("CoreImage_CISepiaTone");
	__xamarin_class_map [1275].handle = objc_getClass ("CoreImage_CIShadedMaterial");
	__xamarin_class_map [1276].handle = objc_getClass ("CoreImage_CISharpenLuminance");
	__xamarin_class_map [1277].handle = objc_getClass ("CoreImage_CISixfoldReflectedTile");
	__xamarin_class_map [1278].handle = objc_getClass ("CoreImage_CISixfoldRotatedTile");
	__xamarin_class_map [1279].handle = objc_getClass ("CoreImage_CISmoothLinearGradient");
	__xamarin_class_map [1280].handle = objc_getClass ("CoreImage_CISoftLightBlendMode");
	__xamarin_class_map [1281].handle = objc_getClass ("CoreImage_CISourceAtopCompositing");
	__xamarin_class_map [1282].handle = objc_getClass ("CoreImage_CISourceInCompositing");
	__xamarin_class_map [1283].handle = objc_getClass ("CoreImage_CISourceOutCompositing");
	__xamarin_class_map [1284].handle = objc_getClass ("CoreImage_CISourceOverCompositing");
	__xamarin_class_map [1285].handle = objc_getClass ("CoreImage_CISpotColor");
	__xamarin_class_map [1286].handle = objc_getClass ("CoreImage_CISpotLight");
	__xamarin_class_map [1287].handle = objc_getClass ("CoreImage_CISRGBToneCurveToLinear");
	__xamarin_class_map [1288].handle = objc_getClass ("CoreImage_CIStarShineGenerator");
	__xamarin_class_map [1289].handle = objc_getClass ("CoreImage_CIStraightenFilter");
	__xamarin_class_map [1290].handle = objc_getClass ("CoreImage_CIStretchCrop");
	__xamarin_class_map [1291].handle = objc_getClass ("CoreImage_CIStripesGenerator");
	__xamarin_class_map [1292].handle = objc_getClass ("CoreImage_CISubtractBlendMode");
	__xamarin_class_map [1293].handle = objc_getClass ("CoreImage_CISunbeamsGenerator");
	__xamarin_class_map [1294].handle = objc_getClass ("CoreImage_CISwipeTransition");
	__xamarin_class_map [1295].handle = objc_getClass ("CoreImage_CITemperatureAndTint");
	__xamarin_class_map [1296].handle = objc_getClass ("CITextFeature");
	__xamarin_class_map [1297].handle = objc_getClass ("CoreImage_CITextImageGenerator");
	__xamarin_class_map [1298].handle = objc_getClass ("CoreImage_CIThermal");
	__xamarin_class_map [1299].handle = objc_getClass ("CoreImage_CIToneCurve");
	__xamarin_class_map [1300].handle = objc_getClass ("CoreImage_CITorusLensDistortion");
	__xamarin_class_map [1301].handle = objc_getClass ("CoreImage_CITriangleKaleidoscope");
	__xamarin_class_map [1302].handle = objc_getClass ("CoreImage_CITriangleTile");
	__xamarin_class_map [1303].handle = objc_getClass ("CoreImage_CITwelvefoldReflectedTile");
	__xamarin_class_map [1304].handle = objc_getClass ("CoreImage_CITwirlDistortion");
	__xamarin_class_map [1305].handle = objc_getClass ("CoreImage_CIUnsharpMask");
	__xamarin_class_map [1306].handle = objc_getClass ("CIVector");
	__xamarin_class_map [1307].handle = objc_getClass ("CoreImage_CIVibrance");
	__xamarin_class_map [1308].handle = objc_getClass ("CoreImage_CIVignette");
	__xamarin_class_map [1309].handle = objc_getClass ("CoreImage_CIVignetteEffect");
	__xamarin_class_map [1310].handle = objc_getClass ("CoreImage_CIVortexDistortion");
	__xamarin_class_map [1311].handle = objc_getClass ("CIWarpKernel");
	__xamarin_class_map [1312].handle = objc_getClass ("CoreImage_CIWhitePointAdjust");
	__xamarin_class_map [1313].handle = objc_getClass ("CoreImage_CIXRay");
	__xamarin_class_map [1314].handle = objc_getClass ("CoreImage_CIZoomBlur");
	__xamarin_class_map [1315].handle = objc_getClass ("CoreImage_CICMYKHalftone");
	__xamarin_class_map [1316].handle = objc_getClass ("NSPersistentStoreRequest");
	__xamarin_class_map [1317].handle = objc_getClass ("NSAsynchronousFetchRequest");
	__xamarin_class_map [1318].handle = objc_getClass ("NSPersistentStoreResult");
	__xamarin_class_map [1319].handle = objc_getClass ("NSPersistentStoreAsynchronousResult");
	__xamarin_class_map [1320].handle = objc_getClass ("NSAsynchronousFetchResult");
	__xamarin_class_map [1321].handle = objc_getClass ("NSPersistentStore");
	__xamarin_class_map [1322].handle = objc_getClass ("NSAtomicStore");
	__xamarin_class_map [1323].handle = objc_getClass ("NSAtomicStoreCacheNode");
	__xamarin_class_map [1324].handle = objc_getClass ("NSPropertyDescription");
	__xamarin_class_map [1325].handle = objc_getClass ("NSAttributeDescription");
	__xamarin_class_map [1326].handle = objc_getClass ("NSBatchDeleteRequest");
	__xamarin_class_map [1327].handle = objc_getClass ("NSBatchDeleteResult");
	__xamarin_class_map [1328].handle = objc_getClass ("NSBatchUpdateRequest");
	__xamarin_class_map [1329].handle = objc_getClass ("NSBatchUpdateResult");
	__xamarin_class_map [1330].handle = objc_getClass ("NSConstraintConflict");
	__xamarin_class_map [1331].handle = objc_getClass ("NSCoreDataCoreSpotlightDelegate");
	__xamarin_class_map [1332].handle = objc_getClass ("NSEntityDescription");
	__xamarin_class_map [1333].handle = objc_getClass ("NSEntityMapping");
	__xamarin_class_map [1334].handle = objc_getClass ("NSEntityMigrationPolicy");
	__xamarin_class_map [1335].handle = objc_getClass ("NSExpressionDescription");
	__xamarin_class_map [1336].handle = objc_getClass ("NSFetchedPropertyDescription");
	__xamarin_class_map [1337].handle = objc_getClass ("NSFetchIndexDescription");
	__xamarin_class_map [1338].handle = objc_getClass ("NSFetchIndexElementDescription");
	__xamarin_class_map [1339].handle = objc_getClass ("NSFetchRequest");
	__xamarin_class_map [1340].handle = objc_getClass ("NSExpression");
	__xamarin_class_map [1341].handle = objc_getClass ("NSFetchRequestExpression");
	__xamarin_class_map [1342].handle = objc_getClass ("NSIncrementalStore");
	__xamarin_class_map [1343].handle = objc_getClass ("NSIncrementalStoreNode");
	__xamarin_class_map [1344].handle = objc_getClass ("NSManagedObject");
	__xamarin_class_map [1345].handle = objc_getClass ("NSManagedObjectID");
	__xamarin_class_map [1346].handle = objc_getClass ("NSManagedObjectModel");
	__xamarin_class_map [1347].handle = objc_getClass ("NSMappingModel");
	__xamarin_class_map [1348].handle = objc_getClass ("NSMergeConflict");
	__xamarin_class_map [1349].handle = objc_getClass ("NSMergePolicy");
	__xamarin_class_map [1350].handle = objc_getClass ("NSMigrationManager");
	__xamarin_class_map [1351].handle = objc_getClass ("NSPersistentHistoryChange");
	__xamarin_class_map [1352].handle = objc_getClass ("NSPersistentHistoryChangeRequest");
	__xamarin_class_map [1353].handle = objc_getClass ("NSPersistentHistoryResult");
	__xamarin_class_map [1354].handle = objc_getClass ("NSPersistentHistoryToken");
	__xamarin_class_map [1355].handle = objc_getClass ("NSPersistentHistoryTransaction");
	__xamarin_class_map [1356].handle = objc_getClass ("NSPersistentStoreDescription");
	__xamarin_class_map [1357].handle = objc_getClass ("NSPropertyMapping");
	__xamarin_class_map [1358].handle = objc_getClass ("NSQueryGenerationToken");
	__xamarin_class_map [1359].handle = objc_getClass ("NSRelationshipDescription");
	__xamarin_class_map [1360].handle = objc_getClass ("NSSaveChangesRequest");
	__xamarin_class_map [1361].handle = objc_getClass ("CBATTRequest");
	__xamarin_class_map [1362].handle = objc_getClass ("CBAttribute");
	__xamarin_class_map [1363].handle = objc_getClass ("CBPeer");
	__xamarin_class_map [1364].handle = objc_getClass ("CBCentral");
	__xamarin_class_map [1365].handle = objc_getClass ("CBCentralManagerDelegate");
	__xamarin_class_map [1366].handle = objc_getClass ("CBCharacteristic");
	__xamarin_class_map [1367].handle = objc_getClass ("CBDescriptor");
	__xamarin_class_map [1368].handle = objc_getClass ("CBL2CAPChannel");
	__xamarin_class_map [1369].handle = objc_getClass ("CBManager");
	__xamarin_class_map [1370].handle = objc_getClass ("CBMutableCharacteristic");
	__xamarin_class_map [1371].handle = objc_getClass ("CBMutableDescriptor");
	__xamarin_class_map [1372].handle = objc_getClass ("CBService");
	__xamarin_class_map [1373].handle = objc_getClass ("CBMutableService");
	__xamarin_class_map [1374].handle = objc_getClass ("CBPeripheralDelegate");
	__xamarin_class_map [1375].handle = objc_getClass ("CBPeripheralManagerDelegate");
	__xamarin_class_map [1376].handle = objc_getClass ("CBUUID");
	__xamarin_class_map [1377].handle = objc_getClass ("AUAudioUnitViewConfiguration");
	__xamarin_class_map [1378].handle = objc_getClass ("AUGenericView");
	__xamarin_class_map [1379].handle = objc_getClass ("AUPannerView");
	__xamarin_class_map [1380].handle = objc_getClass ("AUViewController");
	__xamarin_class_map [1381].handle = objc_getClass ("NSWindowController");
	__xamarin_class_map [1382].handle = objc_getClass ("CABTLEMIDIWindowController");
	__xamarin_class_map [1383].handle = objc_getClass ("CAInterDeviceAudioViewController");
	__xamarin_class_map [1384].handle = objc_getClass ("CANetworkBrowserWindowController");
	__xamarin_class_map [1385].handle = objc_getClass ("CAAction");
	__xamarin_class_map [1386].handle = objc_getClass ("CAAnimationDelegate");
	__xamarin_class_map [1387].handle = objc_getClass ("CAAnimation");
	__xamarin_class_map [1388].handle = objc_getClass ("CAAnimationGroup");
	__xamarin_class_map [1389].handle = objc_getClass ("CAPropertyAnimation");
	__xamarin_class_map [1390].handle = objc_getClass ("CABasicAnimation");
	__xamarin_class_map [1391].handle = objc_getClass ("CAConstraint");
	__xamarin_class_map [1392].handle = objc_getClass ("CAConstraintLayoutManager");
	__xamarin_class_map [1393].handle = objc_getClass ("CAEmitterBehavior");
	__xamarin_class_map [1394].handle = objc_getClass ("CAEmitterCell");
	__xamarin_class_map [1395].handle = objc_getClass ("CAEmitterLayer");
	__xamarin_class_map [1396].handle = objc_getClass ("CAGradientLayer");
	__xamarin_class_map [1397].handle = objc_getClass ("CAKeyframeAnimation");
	__xamarin_class_map [1398].handle = objc_getClass ("CALayerDelegate");
	__xamarin_class_map [1399].handle = objc_getClass ("CAMediaTiming");
	__xamarin_class_map [1400].handle = objc_getClass ("CAMediaTimingFunction");
	__xamarin_class_map [1401].handle = objc_getClass ("CAMetalLayer");
	__xamarin_class_map [1402].handle = objc_getClass ("CARenderer");
	__xamarin_class_map [1403].handle = objc_getClass ("CAReplicatorLayer");
	__xamarin_class_map [1404].handle = objc_getClass ("CAScrollLayer");
	__xamarin_class_map [1405].handle = objc_getClass ("CAShapeLayer");
	__xamarin_class_map [1406].handle = objc_getClass ("CASpringAnimation");
	__xamarin_class_map [1407].handle = objc_getClass ("CATextLayer");
	__xamarin_class_map [1408].handle = objc_getClass ("CATiledLayer");
	__xamarin_class_map [1409].handle = objc_getClass ("CATransaction");
	__xamarin_class_map [1410].handle = objc_getClass ("CATransformLayer");
	__xamarin_class_map [1411].handle = objc_getClass ("CATransition");
	__xamarin_class_map [1412].handle = objc_getClass ("CAValueFunction");
	__xamarin_class_map [1413].handle = objc_getClass ("CNContactPicker");
	__xamarin_class_map [1414].handle = objc_getClass ("CNContactPickerDelegate");
	__xamarin_class_map [1415].handle = objc_getClass ("CNContactViewController");
	__xamarin_class_map [1416].handle = objc_getClass ("CNContactFetchRequest");
	__xamarin_class_map [1417].handle = objc_getClass ("CNContactFormatter");
	__xamarin_class_map [1418].handle = objc_getClass ("CNContactProperty");
	__xamarin_class_map [1419].handle = objc_getClass ("CNContactRelation");
	__xamarin_class_map [1420].handle = objc_getClass ("CNContactsUserDefaults");
	__xamarin_class_map [1421].handle = objc_getClass ("CNContactVCardSerialization");
	__xamarin_class_map [1422].handle = objc_getClass ("CNContainer");
	__xamarin_class_map [1423].handle = objc_getClass ("CNGroup");
	__xamarin_class_map [1424].handle = objc_getClass ("CNInstantMessageAddress");
	__xamarin_class_map [1425].handle = objc_getClass ("CNLabeledValue");
	__xamarin_class_map [1426].handle = objc_getClass ("CNContact");
	__xamarin_class_map [1427].handle = objc_getClass ("CNMutableContact");
	__xamarin_class_map [1428].handle = objc_getClass ("CNMutableGroup");
	__xamarin_class_map [1429].handle = objc_getClass ("CNPostalAddress");
	__xamarin_class_map [1430].handle = objc_getClass ("CNMutablePostalAddress");
	__xamarin_class_map [1431].handle = objc_getClass ("CNPhoneNumber");
	__xamarin_class_map [1432].handle = objc_getClass ("CNPostalAddressFormatter");
	__xamarin_class_map [1433].handle = objc_getClass ("CNSaveRequest");
	__xamarin_class_map [1434].handle = objc_getClass ("CNSocialProfile");
	__xamarin_class_map [1435].handle = objc_getClass ("NSOperation");
	__xamarin_class_map [1436].handle = objc_getClass ("CKOperation");
	__xamarin_class_map [1437].handle = objc_getClass ("CKAcceptSharesOperation");
	__xamarin_class_map [1438].handle = objc_getClass ("CKAsset");
	__xamarin_class_map [1439].handle = objc_getClass ("CKNotification");
	__xamarin_class_map [1440].handle = objc_getClass ("CKDatabaseNotification");
	__xamarin_class_map [1441].handle = objc_getClass ("CKDatabaseOperation");
	__xamarin_class_map [1442].handle = objc_getClass ("CKSubscription");
	__xamarin_class_map [1443].handle = objc_getClass ("CKDatabaseSubscription");
	__xamarin_class_map [1444].handle = objc_getClass ("CKDiscoverAllContactsOperation");
	__xamarin_class_map [1445].handle = objc_getClass ("CKDiscoverAllUserIdentitiesOperation");
	__xamarin_class_map [1446].handle = objc_getClass ("CKDiscoveredUserInfo");
	__xamarin_class_map [1447].handle = objc_getClass ("CKDiscoverUserIdentitiesOperation");
	__xamarin_class_map [1448].handle = objc_getClass ("CKDiscoverUserInfosOperation");
	__xamarin_class_map [1449].handle = objc_getClass ("CKFetchDatabaseChangesOperation");
	__xamarin_class_map [1450].handle = objc_getClass ("CKFetchNotificationChangesOperation");
	__xamarin_class_map [1451].handle = objc_getClass ("CKFetchRecordChangesOperation");
	__xamarin_class_map [1452].handle = objc_getClass ("CKFetchRecordsOperation");
	__xamarin_class_map [1453].handle = objc_getClass ("CKFetchRecordZoneChangesConfiguration");
	__xamarin_class_map [1454].handle = objc_getClass ("CKFetchRecordZoneChangesOperation");
	__xamarin_class_map [1455].handle = objc_getClass ("CKFetchRecordZoneChangesOptions");
	__xamarin_class_map [1456].handle = objc_getClass ("CKFetchRecordZonesOperation");
	__xamarin_class_map [1457].handle = objc_getClass ("CKFetchShareMetadataOperation");
	__xamarin_class_map [1458].handle = objc_getClass ("CKFetchShareParticipantsOperation");
	__xamarin_class_map [1459].handle = objc_getClass ("CKFetchSubscriptionsOperation");
	__xamarin_class_map [1460].handle = objc_getClass ("CKFetchWebAuthTokenOperation");
	__xamarin_class_map [1461].handle = objc_getClass ("NSSortDescriptor");
	__xamarin_class_map [1462].handle = objc_getClass ("CKLocationSortDescriptor");
	__xamarin_class_map [1463].handle = objc_getClass ("CKMarkNotificationsReadOperation");
	__xamarin_class_map [1464].handle = objc_getClass ("CKModifyBadgeOperation");
	__xamarin_class_map [1465].handle = objc_getClass ("CKModifyRecordsOperation");
	__xamarin_class_map [1466].handle = objc_getClass ("CKModifyRecordZonesOperation");
	__xamarin_class_map [1467].handle = objc_getClass ("CKModifySubscriptionsOperation");
	__xamarin_class_map [1468].handle = objc_getClass ("CKNotificationID");
	__xamarin_class_map [1469].handle = objc_getClass ("CKNotificationInfo");
	__xamarin_class_map [1470].handle = objc_getClass ("CKOperationConfiguration");
	__xamarin_class_map [1471].handle = objc_getClass ("CKOperationGroup");
	__xamarin_class_map [1472].handle = objc_getClass ("CKQuery");
	__xamarin_class_map [1473].handle = objc_getClass ("CKQueryCursor");
	__xamarin_class_map [1474].handle = objc_getClass ("CKQueryNotification");
	__xamarin_class_map [1475].handle = objc_getClass ("CKQueryOperation");
	__xamarin_class_map [1476].handle = objc_getClass ("CKQuerySubscription");
	__xamarin_class_map [1477].handle = objc_getClass ("CKRecord");
	__xamarin_class_map [1478].handle = objc_getClass ("CKRecordID");
	__xamarin_class_map [1479].handle = objc_getClass ("CKRecordValue");
	__xamarin_class_map [1480].handle = objc_getClass ("CKRecordZone");
	__xamarin_class_map [1481].handle = objc_getClass ("CKRecordZoneID");
	__xamarin_class_map [1482].handle = objc_getClass ("CKRecordZoneNotification");
	__xamarin_class_map [1483].handle = objc_getClass ("CKRecordZoneSubscription");
	__xamarin_class_map [1484].handle = objc_getClass ("CKReference");
	__xamarin_class_map [1485].handle = objc_getClass ("CKServerChangeToken");
	__xamarin_class_map [1486].handle = objc_getClass ("CKShare");
	__xamarin_class_map [1487].handle = objc_getClass ("CKShareMetadata");
	__xamarin_class_map [1488].handle = objc_getClass ("CKShareParticipant");
	__xamarin_class_map [1489].handle = objc_getClass ("CKUserIdentity");
	__xamarin_class_map [1490].handle = objc_getClass ("CKUserIdentityLookupInfo");
	__xamarin_class_map [1491].handle = objc_getClass ("BCChatAction");
	__xamarin_class_map [1492].handle = objc_getClass ("NSControl");
	__xamarin_class_map [1493].handle = objc_getClass ("BCChatButton");
	__xamarin_class_map [1494].handle = objc_getClass ("AVCaptureView");
	__xamarin_class_map [1495].handle = objc_getClass ("AVCaptureViewDelegate");
	__xamarin_class_map [1496].handle = objc_getClass ("AVPlayerView");
	__xamarin_class_map [1497].handle = objc_getClass ("AVAssetCache");
	__xamarin_class_map [1498].handle = objc_getClass ("AVAssetImageGenerator");
	__xamarin_class_map [1499].handle = objc_getClass ("AVAssetReader");
	__xamarin_class_map [1500].handle = objc_getClass ("AVAssetReaderOutput");
	__xamarin_class_map [1501].handle = objc_getClass ("AVAssetReaderAudioMixOutput");
	__xamarin_class_map [1502].handle = objc_getClass ("AVAssetReaderOutputMetadataAdaptor");
	__xamarin_class_map [1503].handle = objc_getClass ("AVAssetReaderSampleReferenceOutput");
	__xamarin_class_map [1504].handle = objc_getClass ("AVAssetReaderTrackOutput");
	__xamarin_class_map [1505].handle = objc_getClass ("AVAssetReaderVideoCompositionOutput");
	__xamarin_class_map [1506].handle = objc_getClass ("AVAssetResourceLoader");
	__xamarin_class_map [1507].handle = objc_getClass ("AVAssetResourceLoaderDelegate");
	__xamarin_class_map [1508].handle = objc_getClass ("AVAssetResourceLoadingContentInformationRequest");
	__xamarin_class_map [1509].handle = objc_getClass ("AVAssetResourceLoadingDataRequest");
	__xamarin_class_map [1510].handle = objc_getClass ("AVAssetResourceLoadingRequest");
	__xamarin_class_map [1511].handle = objc_getClass ("AVAssetResourceLoadingRequestor");
	__xamarin_class_map [1512].handle = objc_getClass ("AVAssetResourceRenewalRequest");
	__xamarin_class_map [1513].handle = objc_getClass ("AVAssetTrackGroup");
	__xamarin_class_map [1514].handle = objc_getClass ("AVAssetTrackSegment");
	__xamarin_class_map [1515].handle = objc_getClass ("AVAssetWriterInput");
	__xamarin_class_map [1516].handle = objc_getClass ("AVMediaSelectionGroup");
	__xamarin_class_map [1517].handle = objc_getClass ("AVAssetWriterInputGroup");
	__xamarin_class_map [1518].handle = objc_getClass ("AVAssetWriterInputMetadataAdaptor");
	__xamarin_class_map [1519].handle = objc_getClass ("AVAssetWriterInputPassDescription");
	__xamarin_class_map [1520].handle = objc_getClass ("AVAssetWriterInputPixelBufferAdaptor");
	__xamarin_class_map [1521].handle = objc_getClass ("AVAsynchronousCIImageFilteringRequest");
	__xamarin_class_map [1522].handle = objc_getClass ("AVAsynchronousKeyValueLoading");
	__xamarin_class_map [1523].handle = objc_getClass ("AVAsynchronousVideoCompositionRequest");
	__xamarin_class_map [1524].handle = objc_getClass ("AVAudio3DMixing");
	__xamarin_class_map [1525].handle = objc_getClass ("AVAudioBuffer");
	__xamarin_class_map [1526].handle = objc_getClass ("AVAudioChannelLayout");
	__xamarin_class_map [1527].handle = objc_getClass ("AVAudioCompressedBuffer");
	__xamarin_class_map [1528].handle = objc_getClass ("AVAudioConnectionPoint");
	__xamarin_class_map [1529].handle = objc_getClass ("AVAudioConverter");
	__xamarin_class_map [1530].handle = objc_getClass ("AVAudioEnvironmentDistanceAttenuationParameters");
	__xamarin_class_map [1531].handle = objc_getClass ("AVAudioNode");
	__xamarin_class_map [1532].handle = objc_getClass ("AVAudioEnvironmentNode");
	__xamarin_class_map [1533].handle = objc_getClass ("AVAudioEnvironmentReverbParameters");
	__xamarin_class_map [1534].handle = objc_getClass ("AVAudioFile");
	__xamarin_class_map [1535].handle = objc_getClass ("AVAudioFormat");
	__xamarin_class_map [1536].handle = objc_getClass ("AVAudioIONode");
	__xamarin_class_map [1537].handle = objc_getClass ("AVAudioInputNode");
	__xamarin_class_map [1538].handle = objc_getClass ("AVAudioMix");
	__xamarin_class_map [1539].handle = objc_getClass ("AVAudioMixerNode");
	__xamarin_class_map [1540].handle = objc_getClass ("AVAudioMixingDestination");
	__xamarin_class_map [1541].handle = objc_getClass ("AVAudioMixInputParameters");
	__xamarin_class_map [1542].handle = objc_getClass ("AVAudioOutputNode");
	__xamarin_class_map [1543].handle = objc_getClass ("AVAudioPCMBuffer");
	__xamarin_class_map [1544].handle = objc_getClass ("AVAudioPlayer");
	__xamarin_class_map [1545].handle = objc_getClass ("AVAudioPlayerDelegate");
	__xamarin_class_map [1546].handle = objc_getClass ("AVAudioRecorder");
	__xamarin_class_map [1547].handle = objc_getClass ("AVAudioRecorderDelegate");
	__xamarin_class_map [1548].handle = objc_getClass ("AVAudioSequencer");
	__xamarin_class_map [1549].handle = objc_getClass ("AVAudioStereoMixing");
	__xamarin_class_map [1550].handle = objc_getClass ("AVAudioTime");
	__xamarin_class_map [1551].handle = objc_getClass ("AVAudioUnitComponentManager");
	__xamarin_class_map [1552].handle = objc_getClass ("AVAudioUnit");
	__xamarin_class_map [1553].handle = objc_getClass ("AVAudioUnitEffect");
	__xamarin_class_map [1554].handle = objc_getClass ("AVAudioUnitDelay");
	__xamarin_class_map [1555].handle = objc_getClass ("AVAudioUnitDistortion");
	__xamarin_class_map [1556].handle = objc_getClass ("AVAudioUnitEQ");
	__xamarin_class_map [1557].handle = objc_getClass ("AVAudioUnitEQFilterParameters");
	__xamarin_class_map [1558].handle = objc_getClass ("AVAudioUnitGenerator");
	__xamarin_class_map [1559].handle = objc_getClass ("AVAudioUnitMIDIInstrument");
	__xamarin_class_map [1560].handle = objc_getClass ("AVAudioUnitReverb");
	__xamarin_class_map [1561].handle = objc_getClass ("AVAudioUnitSampler");
	__xamarin_class_map [1562].handle = objc_getClass ("AVAudioUnitTimeEffect");
	__xamarin_class_map [1563].handle = objc_getClass ("AVAudioUnitTimePitch");
	__xamarin_class_map [1564].handle = objc_getClass ("AVAudioUnitVarispeed");
	__xamarin_class_map [1565].handle = objc_getClass ("AVCameraCalibrationData");
	__xamarin_class_map [1566].handle = objc_getClass ("AVCaptureAudioChannel");
	__xamarin_class_map [1567].handle = objc_getClass ("AVCaptureOutput");
	__xamarin_class_map [1568].handle = objc_getClass ("AVCaptureAudioDataOutput");
	__xamarin_class_map [1569].handle = objc_getClass ("AVCaptureAudioDataOutputSampleBufferDelegate");
	__xamarin_class_map [1570].handle = objc_getClass ("AVCaptureFileOutput");
	__xamarin_class_map [1571].handle = objc_getClass ("AVCaptureAudioFileOutput");
	__xamarin_class_map [1572].handle = objc_getClass ("AVCaptureAudioPreviewOutput");
	__xamarin_class_map [1573].handle = objc_getClass ("AVCaptureConnection");
	__xamarin_class_map [1574].handle = objc_getClass ("AVCaptureDeviceFormat");
	__xamarin_class_map [1575].handle = objc_getClass ("AVCaptureInput");
	__xamarin_class_map [1576].handle = objc_getClass ("AVCaptureDeviceInput");
	__xamarin_class_map [1577].handle = objc_getClass ("AVCaptureDeviceInputSource");
	__xamarin_class_map [1578].handle = objc_getClass ("AVCaptureFileOutputDelegate");
	__xamarin_class_map [1579].handle = objc_getClass ("AVCaptureFileOutputRecordingDelegate");
	__xamarin_class_map [1580].handle = objc_getClass ("AVCaptureInputPort");
	__xamarin_class_map [1581].handle = objc_getClass ("AVCaptureMovieFileOutput");
	__xamarin_class_map [1582].handle = objc_getClass ("AVCaptureScreenInput");
	__xamarin_class_map [1583].handle = objc_getClass ("AVCaptureSynchronizedData");
	__xamarin_class_map [1584].handle = objc_getClass ("AVCaptureSynchronizedDataCollection");
	__xamarin_class_map [1585].handle = objc_getClass ("AVCaptureVideoDataOutput");
	__xamarin_class_map [1586].handle = objc_getClass ("AVCaptureVideoDataOutputSampleBufferDelegate");
	__xamarin_class_map [1587].handle = objc_getClass ("AVAsset");
	__xamarin_class_map [1588].handle = objc_getClass ("AVComposition");
	__xamarin_class_map [1589].handle = objc_getClass ("AVAssetTrack");
	__xamarin_class_map [1590].handle = objc_getClass ("AVCompositionTrack");
	__xamarin_class_map [1591].handle = objc_getClass ("AVCompositionTrackSegment");
	__xamarin_class_map [1592].handle = objc_getClass ("AVContentKeyResponse");
	__xamarin_class_map [1593].handle = objc_getClass ("AVContentKeySession");
	__xamarin_class_map [1594].handle = objc_getClass ("AVContentKeySessionDelegate");
	__xamarin_class_map [1595].handle = objc_getClass ("AVMetadataGroup");
	__xamarin_class_map [1596].handle = objc_getClass ("AVDateRangeMetadataGroup");
	__xamarin_class_map [1597].handle = objc_getClass ("AVDepthData");
	__xamarin_class_map [1598].handle = objc_getClass ("AVURLAsset");
	__xamarin_class_map [1599].handle = objc_getClass ("AVFragmentedAsset");
	__xamarin_class_map [1600].handle = objc_getClass ("AVFragmentedAssetMinder");
	__xamarin_class_map [1601].handle = objc_getClass ("AVFragmentedAssetTrack");
	__xamarin_class_map [1602].handle = objc_getClass ("AVFragmentedMovieMinder");
	__xamarin_class_map [1603].handle = objc_getClass ("AVFrameRateRange");
	__xamarin_class_map [1604].handle = objc_getClass ("AVMediaDataStorage");
	__xamarin_class_map [1605].handle = objc_getClass ("AVMediaSelection");
	__xamarin_class_map [1606].handle = objc_getClass ("AVMediaSelectionOption");
	__xamarin_class_map [1607].handle = objc_getClass ("AVMetadataObject");
	__xamarin_class_map [1608].handle = objc_getClass ("AVMetadataFaceObject");
	__xamarin_class_map [1609].handle = objc_getClass ("AVMetadataItemFilter");
	__xamarin_class_map [1610].handle = objc_getClass ("AVMetadataItemValueRequest");
	__xamarin_class_map [1611].handle = objc_getClass ("AVMovie");
	__xamarin_class_map [1612].handle = objc_getClass ("AVMovieTrack");
	__xamarin_class_map [1613].handle = objc_getClass ("AVMusicTrack");
	__xamarin_class_map [1614].handle = objc_getClass ("AVMutableAudioMix");
	__xamarin_class_map [1615].handle = objc_getClass ("AVMutableAudioMixInputParameters");
	__xamarin_class_map [1616].handle = objc_getClass ("AVMutableComposition");
	__xamarin_class_map [1617].handle = objc_getClass ("AVMutableCompositionTrack");
	__xamarin_class_map [1618].handle = objc_getClass ("AVMutableDateRangeMetadataGroup");
	__xamarin_class_map [1619].handle = objc_getClass ("AVMutableMediaSelection");
	__xamarin_class_map [1620].handle = objc_getClass ("AVMetadataItem");
	__xamarin_class_map [1621].handle = objc_getClass ("AVMutableMetadataItem");
	__xamarin_class_map [1622].handle = objc_getClass ("AVMutableMovie");
	__xamarin_class_map [1623].handle = objc_getClass ("AVMutableMovieTrack");
	__xamarin_class_map [1624].handle = objc_getClass ("AVTimedMetadataGroup");
	__xamarin_class_map [1625].handle = objc_getClass ("AVMutableTimedMetadataGroup");
	__xamarin_class_map [1626].handle = objc_getClass ("AVVideoComposition");
	__xamarin_class_map [1627].handle = objc_getClass ("AVMutableVideoComposition");
	__xamarin_class_map [1628].handle = objc_getClass ("AVVideoCompositionInstruction");
	__xamarin_class_map [1629].handle = objc_getClass ("AVMutableVideoCompositionInstruction");
	__xamarin_class_map [1630].handle = objc_getClass ("AVVideoCompositionLayerInstruction");
	__xamarin_class_map [1631].handle = objc_getClass ("AVMutableVideoCompositionLayerInstruction");
	__xamarin_class_map [1632].handle = objc_getClass ("AVOutputSettingsAssistant");
	__xamarin_class_map [1633].handle = objc_getClass ("AVContentKeyRequest");
	__xamarin_class_map [1634].handle = objc_getClass ("AVPersistableContentKeyRequest");
	__xamarin_class_map [1635].handle = objc_getClass ("AVPlayerItemAccessLog");
	__xamarin_class_map [1636].handle = objc_getClass ("AVPlayerItemAccessLogEvent");
	__xamarin_class_map [1637].handle = objc_getClass ("AVPlayerItemErrorLog");
	__xamarin_class_map [1638].handle = objc_getClass ("AVPlayerItemErrorLogEvent");
	__xamarin_class_map [1639].handle = objc_getClass ("AVPlayerItemOutput");
	__xamarin_class_map [1640].handle = objc_getClass ("AVPlayerItemLegibleOutput");
	__xamarin_class_map [1641].handle = objc_getClass ("AVPlayerItemOutputPushDelegate");
	__xamarin_class_map [1642].handle = objc_getClass ("AVPlayerItemLegibleOutputPushDelegate");
	__xamarin_class_map [1643].handle = objc_getClass ("AVPlayerItemMediaDataCollector");
	__xamarin_class_map [1644].handle = objc_getClass ("AVPlayerItemMetadataCollector");
	__xamarin_class_map [1645].handle = objc_getClass ("AVPlayerItemMetadataCollectorPushDelegate");
	__xamarin_class_map [1646].handle = objc_getClass ("AVPlayerItemMetadataOutput");
	__xamarin_class_map [1647].handle = objc_getClass ("AVPlayerItemMetadataOutputPushDelegate");
	__xamarin_class_map [1648].handle = objc_getClass ("AVPlayerItemOutputPullDelegate");
	__xamarin_class_map [1649].handle = objc_getClass ("AVPlayerItemTrack");
	__xamarin_class_map [1650].handle = objc_getClass ("AVPlayerLayer");
	__xamarin_class_map [1651].handle = objc_getClass ("AVPlayerLooper");
	__xamarin_class_map [1652].handle = objc_getClass ("AVPlayerMediaSelectionCriteria");
	__xamarin_class_map [1653].handle = objc_getClass ("AVPortraitEffectsMatte");
	__xamarin_class_map [1654].handle = objc_getClass ("AVPlayer");
	__xamarin_class_map [1655].handle = objc_getClass ("AVQueuePlayer");
	__xamarin_class_map [1656].handle = objc_getClass ("AVSampleBufferRequest");
	__xamarin_class_map [1657].handle = objc_getClass ("AVSampleCursor");
	__xamarin_class_map [1658].handle = objc_getClass ("AVSynchronizedLayer");
	__xamarin_class_map [1659].handle = objc_getClass ("AVTextStyleRule");
	__xamarin_class_map [1660].handle = objc_getClass ("AVVideoCompositing");
	__xamarin_class_map [1661].handle = objc_getClass ("AVVideoCompositionCoreAnimationTool");
	__xamarin_class_map [1662].handle = objc_getClass ("AVVideoCompositionRenderContext");
	__xamarin_class_map [1663].handle = objc_getClass ("AVVideoCompositionValidationHandling");
	__xamarin_class_map [1664].handle = objc_getClass ("AVFoundation_AVCaptureDataOutputSynchronizer");
	__xamarin_class_map [1665].handle = objc_getClass ("AVFoundation_AVCaptureDataOutputSynchronizerDelegate");
	__xamarin_class_map [1666].handle = objc_getClass ("AVFoundation_InternalAVAudioPlayerDelegate");
	__xamarin_class_map [1667].handle = objc_getClass ("AVFoundation_InternalAVAudioRecorderDelegate");
	__xamarin_class_map [1668].handle = objc_getClass ("AUAudioUnitBus");
	__xamarin_class_map [1669].handle = objc_getClass ("AUAudioUnitBusArray");
	__xamarin_class_map [1670].handle = objc_getClass ("AUAudioUnitPreset");
	__xamarin_class_map [1671].handle = objc_getClass ("AUParameterNode");
	__xamarin_class_map [1672].handle = objc_getClass ("AUParameter");
	__xamarin_class_map [1673].handle = objc_getClass ("AUParameterGroup");
	__xamarin_class_map [1674].handle = objc_getClass ("AUParameterTree");
	__xamarin_class_map [1675].handle = objc_getClass ("NSAccessibilityCustomAction");
	__xamarin_class_map [1676].handle = objc_getClass ("NSAccessibilityCustomRotor");
	__xamarin_class_map [1677].handle = objc_getClass ("NSAccessibilityCustomRotorItemResult");
	__xamarin_class_map [1678].handle = objc_getClass ("NSAccessibilityCustomRotorItemSearchDelegate");
	__xamarin_class_map [1679].handle = objc_getClass ("NSAccessibilityCustomRotorSearchParameters");
	__xamarin_class_map [1680].handle = objc_getClass ("NSCell");
	__xamarin_class_map [1681].handle = objc_getClass ("NSActionCell");
	__xamarin_class_map [1682].handle = objc_getClass ("NSAlertDelegate");
	__xamarin_class_map [1683].handle = objc_getClass ("NSAlignmentFeedbackFilter");
	__xamarin_class_map [1684].handle = objc_getClass ("NSAlignmentFeedbackToken");
	__xamarin_class_map [1685].handle = objc_getClass ("NSAnimationContext");
	__xamarin_class_map [1686].handle = objc_getClass ("NSAnimationDelegate");
	__xamarin_class_map [1687].handle = objc_getClass ("NSAppearance");
	__xamarin_class_map [1688].handle = objc_getClass ("NSAppearanceCustomization");
	__xamarin_class_map [1689].handle = objc_getClass ("NSApplicationDelegate");
	__xamarin_class_map [1690].handle = objc_getClass ("NSController");
	__xamarin_class_map [1691].handle = objc_getClass ("NSObjectController");
	__xamarin_class_map [1692].handle = objc_getClass ("NSArrayController");
	__xamarin_class_map [1693].handle = objc_getClass ("NSTypesetter");
	__xamarin_class_map [1694].handle = objc_getClass ("NSATSTypesetter");
	__xamarin_class_map [1695].handle = objc_getClass ("NSBezierPath");
	__xamarin_class_map [1696].handle = objc_getClass ("NSImageRep");
	__xamarin_class_map [1697].handle = objc_getClass ("NSBitmapImageRep");
	__xamarin_class_map [1698].handle = objc_getClass ("NSBox");
	__xamarin_class_map [1699].handle = objc_getClass ("NSBrowserCell");
	__xamarin_class_map [1700].handle = objc_getClass ("NSBrowserDelegate");
	__xamarin_class_map [1701].handle = objc_getClass ("NSButton");
	__xamarin_class_map [1702].handle = objc_getClass ("NSButtonCell");
	__xamarin_class_map [1703].handle = objc_getClass ("NSCachedImageRep");
	__xamarin_class_map [1704].handle = objc_getClass ("NSTouchBarItem");
	__xamarin_class_map [1705].handle = objc_getClass ("NSCandidateListTouchBarItem");
	__xamarin_class_map [1706].handle = objc_getClass ("NSCandidateListTouchBarItemDelegate");
	__xamarin_class_map [1707].handle = objc_getClass ("NSCIImageRep");
	__xamarin_class_map [1708].handle = objc_getClass ("NSClipView");
	__xamarin_class_map [1709].handle = objc_getClass ("NSSharingServiceDelegate");
	__xamarin_class_map [1710].handle = objc_getClass ("NSCloudSharingServiceDelegate");
	__xamarin_class_map [1711].handle = objc_getClass ("NSCollectionView");
	__xamarin_class_map [1712].handle = objc_getClass ("NSCollectionViewDataSource");
	__xamarin_class_map [1713].handle = objc_getClass ("NSCollectionViewDelegate");
	__xamarin_class_map [1714].handle = objc_getClass ("NSCollectionViewDelegateFlowLayout");
	__xamarin_class_map [1715].handle = objc_getClass ("NSCollectionViewElement");
	__xamarin_class_map [1716].handle = objc_getClass ("NSCollectionViewLayout");
	__xamarin_class_map [1717].handle = objc_getClass ("NSCollectionViewFlowLayout");
	__xamarin_class_map [1718].handle = objc_getClass ("NSCollectionViewLayoutInvalidationContext");
	__xamarin_class_map [1719].handle = objc_getClass ("NSCollectionViewFlowLayoutInvalidationContext");
	__xamarin_class_map [1720].handle = objc_getClass ("NSCollectionViewGridLayout");
	__xamarin_class_map [1721].handle = objc_getClass ("NSCollectionViewItem");
	__xamarin_class_map [1722].handle = objc_getClass ("NSCollectionViewLayoutAttributes");
	__xamarin_class_map [1723].handle = objc_getClass ("NSCollectionViewTransitionLayout");
	__xamarin_class_map [1724].handle = objc_getClass ("NSCollectionViewUpdateItem");
	__xamarin_class_map [1725].handle = objc_getClass ("NSColorList");
	__xamarin_class_map [1726].handle = objc_getClass ("NSColorPicker");
	__xamarin_class_map [1727].handle = objc_getClass ("NSColorPickerTouchBarItem");
	__xamarin_class_map [1728].handle = objc_getClass ("NSColorSpace");
	__xamarin_class_map [1729].handle = objc_getClass ("NSColorWell");
	__xamarin_class_map [1730].handle = objc_getClass ("NSTextFieldCell");
	__xamarin_class_map [1731].handle = objc_getClass ("NSComboBoxCell");
	__xamarin_class_map [1732].handle = objc_getClass ("NSComboBoxCellDataSource");
	__xamarin_class_map [1733].handle = objc_getClass ("NSComboBoxDataSource");
	__xamarin_class_map [1734].handle = objc_getClass ("NSTextFieldDelegate");
	__xamarin_class_map [1735].handle = objc_getClass ("NSComboBoxDelegate");
	__xamarin_class_map [1736].handle = objc_getClass ("NSControlTextEditingDelegate");
	__xamarin_class_map [1737].handle = objc_getClass ("NSCursor");
	__xamarin_class_map [1738].handle = objc_getClass ("NSCustomImageRep");
	__xamarin_class_map [1739].handle = objc_getClass ("NSCustomTouchBarItem");
	__xamarin_class_map [1740].handle = objc_getClass ("NSDataAsset");
	__xamarin_class_map [1741].handle = objc_getClass ("NSDatePickerCellDelegate");
	__xamarin_class_map [1742].handle = objc_getClass ("NSDictionaryController");
	__xamarin_class_map [1743].handle = objc_getClass ("NSDictionaryControllerKeyValuePair");
	__xamarin_class_map [1744].handle = objc_getClass ("NSDockTile");
	__xamarin_class_map [1745].handle = objc_getClass ("NSDockTilePlugIn");
	__xamarin_class_map [1746].handle = objc_getClass ("NSDocumentController");
	__xamarin_class_map [1747].handle = objc_getClass ("NSDraggingDestination");
	__xamarin_class_map [1748].handle = objc_getClass ("NSDraggingImageComponent");
	__xamarin_class_map [1749].handle = objc_getClass ("NSDraggingItem");
	__xamarin_class_map [1750].handle = objc_getClass ("NSDraggingSession");
	__xamarin_class_map [1751].handle = objc_getClass ("NSDraggingSource");
	__xamarin_class_map [1752].handle = objc_getClass ("NSDrawerDelegate");
	__xamarin_class_map [1753].handle = objc_getClass ("NSEPSImageRep");
	__xamarin_class_map [1754].handle = objc_getClass ("NSFilePromiseProvider");
	__xamarin_class_map [1755].handle = objc_getClass ("NSFilePromiseReceiver");
	__xamarin_class_map [1756].handle = objc_getClass ("NSFontAssetRequest");
	__xamarin_class_map [1757].handle = objc_getClass ("NSFontDescriptor");
	__xamarin_class_map [1758].handle = objc_getClass ("NSFontManager");
	__xamarin_class_map [1759].handle = objc_getClass ("NSFontPanel");
	__xamarin_class_map [1760].handle = objc_getClass ("NSMatrix");
	__xamarin_class_map [1761].handle = objc_getClass ("NSForm");
	__xamarin_class_map [1762].handle = objc_getClass ("NSFormCell");
	__xamarin_class_map [1763].handle = objc_getClass ("NSGestureRecognizerDelegate");
	__xamarin_class_map [1764].handle = objc_getClass ("NSGlyphGenerator");
	__xamarin_class_map [1765].handle = objc_getClass ("NSGlyphInfo");
	__xamarin_class_map [1766].handle = objc_getClass ("NSGraphicsContext");
	__xamarin_class_map [1767].handle = objc_getClass ("NSGridCell");
	__xamarin_class_map [1768].handle = objc_getClass ("NSGridColumn");
	__xamarin_class_map [1769].handle = objc_getClass ("NSGridRow");
	__xamarin_class_map [1770].handle = objc_getClass ("NSGridView");
	__xamarin_class_map [1771].handle = objc_getClass ("NSGroupTouchBarItem");
	__xamarin_class_map [1772].handle = objc_getClass ("NSHapticFeedbackManager");
	__xamarin_class_map [1773].handle = objc_getClass ("NSHapticFeedbackPerformer");
	__xamarin_class_map [1774].handle = objc_getClass ("NSImageCell");
	__xamarin_class_map [1775].handle = objc_getClass ("NSImageDelegate");
	__xamarin_class_map [1776].handle = objc_getClass ("NSImageView");
	__xamarin_class_map [1777].handle = objc_getClass ("NSLayoutAnchor");
	__xamarin_class_map [1778].handle = objc_getClass ("NSLayoutConstraint");
	__xamarin_class_map [1779].handle = objc_getClass ("NSLayoutDimension");
	__xamarin_class_map [1780].handle = objc_getClass ("NSLayoutGuide");
	__xamarin_class_map [1781].handle = objc_getClass ("NSLayoutManager");
	__xamarin_class_map [1782].handle = objc_getClass ("NSLayoutManagerDelegate");
	__xamarin_class_map [1783].handle = objc_getClass ("NSLayoutXAxisAnchor");
	__xamarin_class_map [1784].handle = objc_getClass ("NSLayoutYAxisAnchor");
	__xamarin_class_map [1785].handle = objc_getClass ("NSLevelIndicator");
	__xamarin_class_map [1786].handle = objc_getClass ("NSLevelIndicatorCell");
	__xamarin_class_map [1787].handle = objc_getClass ("NSMatrixDelegate");
	__xamarin_class_map [1788].handle = objc_getClass ("NSMenuDelegate");
	__xamarin_class_map [1789].handle = objc_getClass ("NSMenuItemCell");
	__xamarin_class_map [1790].handle = objc_getClass ("NSMenuView");
	__xamarin_class_map [1791].handle = objc_getClass ("NSFontCollection");
	__xamarin_class_map [1792].handle = objc_getClass ("NSMutableFontCollection");
	__xamarin_class_map [1793].handle = objc_getClass ("NSParagraphStyle");
	__xamarin_class_map [1794].handle = objc_getClass ("NSMutableParagraphStyle");
	__xamarin_class_map [1795].handle = objc_getClass ("NSNib");
	__xamarin_class_map [1796].handle = objc_getClass ("NSOpenGLContext");
	__xamarin_class_map [1797].handle = objc_getClass ("NSOpenGLLayer");
	__xamarin_class_map [1798].handle = objc_getClass ("NSOpenGLPixelBuffer");
	__xamarin_class_map [1799].handle = objc_getClass ("NSOpenGLPixelFormat");
	__xamarin_class_map [1800].handle = objc_getClass ("NSOpenGLView");
	__xamarin_class_map [1801].handle = objc_getClass ("NSSavePanel");
	__xamarin_class_map [1802].handle = objc_getClass ("NSOpenPanel");
	__xamarin_class_map [1803].handle = objc_getClass ("NSOpenSavePanelDelegate");
	__xamarin_class_map [1804].handle = objc_getClass ("NSOutlineViewDataSource");
	__xamarin_class_map [1805].handle = objc_getClass ("NSOutlineViewDelegate");
	__xamarin_class_map [1806].handle = objc_getClass ("NSPageControllerDelegate");
	__xamarin_class_map [1807].handle = objc_getClass ("NSPageLayout");
	__xamarin_class_map [1808].handle = objc_getClass ("NSPasteboard");
	__xamarin_class_map [1809].handle = objc_getClass ("NSPasteboardItem");
	__xamarin_class_map [1810].handle = objc_getClass ("NSPasteboardItemDataProvider");
	__xamarin_class_map [1811].handle = objc_getClass ("NSPasteboardReading");
	__xamarin_class_map [1812].handle = objc_getClass ("NSPasteboardWriting");
	__xamarin_class_map [1813].handle = objc_getClass ("NSPathCellDelegate");
	__xamarin_class_map [1814].handle = objc_getClass ("NSPathComponentCell");
	__xamarin_class_map [1815].handle = objc_getClass ("NSPathControl");
	__xamarin_class_map [1816].handle = objc_getClass ("NSPathControlDelegate");
	__xamarin_class_map [1817].handle = objc_getClass ("NSPathControlItem");
	__xamarin_class_map [1818].handle = objc_getClass ("NSPDFImageRep");
	__xamarin_class_map [1819].handle = objc_getClass ("NSPopoverDelegate");
	__xamarin_class_map [1820].handle = objc_getClass ("NSPopoverTouchBarItem");
	__xamarin_class_map [1821].handle = objc_getClass ("NSRuleEditor");
	__xamarin_class_map [1822].handle = objc_getClass ("NSPredicateEditor");
	__xamarin_class_map [1823].handle = objc_getClass ("NSPressureConfiguration");
	__xamarin_class_map [1824].handle = objc_getClass ("NSPrinter");
	__xamarin_class_map [1825].handle = objc_getClass ("NSPrintInfo");
	__xamarin_class_map [1826].handle = objc_getClass ("NSPrintOperation");
	__xamarin_class_map [1827].handle = objc_getClass ("NSPrintPanel");
	__xamarin_class_map [1828].handle = objc_getClass ("NSPrintPanelAccessorizing");
	__xamarin_class_map [1829].handle = objc_getClass ("NSPrintPreviewGraphicsContext");
	__xamarin_class_map [1830].handle = objc_getClass ("NSProgressIndicator");
	__xamarin_class_map [1831].handle = objc_getClass ("NSRemoteOpenPanel");
	__xamarin_class_map [1832].handle = objc_getClass ("NSRemoteSavePanel");
	__xamarin_class_map [1833].handle = objc_getClass ("NSRuleEditorDelegate");
	__xamarin_class_map [1834].handle = objc_getClass ("NSRulerMarker");
	__xamarin_class_map [1835].handle = objc_getClass ("NSRulerView");
	__xamarin_class_map [1836].handle = objc_getClass ("NSRunningApplication");
	__xamarin_class_map [1837].handle = objc_getClass ("NSScrubber");
	__xamarin_class_map [1838].handle = objc_getClass ("NSScrubberArrangedView");
	__xamarin_class_map [1839].handle = objc_getClass ("NSScrubberDataSource");
	__xamarin_class_map [1840].handle = objc_getClass ("NSScrubberDelegate");
	__xamarin_class_map [1841].handle = objc_getClass ("NSScrubberLayout");
	__xamarin_class_map [1842].handle = objc_getClass ("NSScrubberFlowLayout");
	__xamarin_class_map [1843].handle = objc_getClass ("NSScrubberFlowLayoutDelegate");
	__xamarin_class_map [1844].handle = objc_getClass ("NSScrubberItemView");
	__xamarin_class_map [1845].handle = objc_getClass ("NSScrubberImageItemView");
	__xamarin_class_map [1846].handle = objc_getClass ("NSScrubberLayoutAttributes");
	__xamarin_class_map [1847].handle = objc_getClass ("NSScrubberProportionalLayout");
	__xamarin_class_map [1848].handle = objc_getClass ("NSScrubberSelectionStyle");
	__xamarin_class_map [1849].handle = objc_getClass ("NSScrubberSelectionView");
	__xamarin_class_map [1850].handle = objc_getClass ("NSScrubberTextItemView");
	__xamarin_class_map [1851].handle = objc_getClass ("NSSearchFieldCell");
	__xamarin_class_map [1852].handle = objc_getClass ("NSSearchFieldDelegate");
	__xamarin_class_map [1853].handle = objc_getClass ("NSTextField");
	__xamarin_class_map [1854].handle = objc_getClass ("NSSecureTextField");
	__xamarin_class_map [1855].handle = objc_getClass ("NSSecureTextFieldCell");
	__xamarin_class_map [1856].handle = objc_getClass ("NSSegmentedCell");
	__xamarin_class_map [1857].handle = objc_getClass ("NSSegmentedControl");
	__xamarin_class_map [1858].handle = objc_getClass ("NSSeguePerforming");
	__xamarin_class_map [1859].handle = objc_getClass ("NSShadow");
	__xamarin_class_map [1860].handle = objc_getClass ("NSSharingServicePickerDelegate");
	__xamarin_class_map [1861].handle = objc_getClass ("NSSharingServicePickerTouchBarItem");
	__xamarin_class_map [1862].handle = objc_getClass ("NSSharingServicePickerTouchBarItemDelegate");
	__xamarin_class_map [1863].handle = objc_getClass ("NSSlider");
	__xamarin_class_map [1864].handle = objc_getClass ("NSSliderAccessoryBehavior");
	__xamarin_class_map [1865].handle = objc_getClass ("NSSliderCell");
	__xamarin_class_map [1866].handle = objc_getClass ("NSSliderTouchBarItem");
	__xamarin_class_map [1867].handle = objc_getClass ("NSSoundDelegate");
	__xamarin_class_map [1868].handle = objc_getClass ("NSSpeechRecognizer");
	__xamarin_class_map [1869].handle = objc_getClass ("NSSpeechRecognizerDelegate");
	__xamarin_class_map [1870].handle = objc_getClass ("NSSpeechSynthesizer");
	__xamarin_class_map [1871].handle = objc_getClass ("NSSpeechSynthesizerDelegate");
	__xamarin_class_map [1872].handle = objc_getClass ("NSSplitViewController");
	__xamarin_class_map [1873].handle = objc_getClass ("NSSplitViewDelegate");
	__xamarin_class_map [1874].handle = objc_getClass ("NSSplitViewItem");
	__xamarin_class_map [1875].handle = objc_getClass ("NSSpringLoadingDestination");
	__xamarin_class_map [1876].handle = objc_getClass ("NSStackView");
	__xamarin_class_map [1877].handle = objc_getClass ("NSStackViewDelegate");
	__xamarin_class_map [1878].handle = objc_getClass ("NSStatusBar");
	__xamarin_class_map [1879].handle = objc_getClass ("NSStatusBarButton");
	__xamarin_class_map [1880].handle = objc_getClass ("NSStatusItem");
	__xamarin_class_map [1881].handle = objc_getClass ("NSStepper");
	__xamarin_class_map [1882].handle = objc_getClass ("NSStepperCell");
	__xamarin_class_map [1883].handle = objc_getClass ("NSStoryboard");
	__xamarin_class_map [1884].handle = objc_getClass ("NSStoryboardSegue");
	__xamarin_class_map [1885].handle = objc_getClass ("NSStringDrawingContext");
	__xamarin_class_map [1886].handle = objc_getClass ("NSTableCellView");
	__xamarin_class_map [1887].handle = objc_getClass ("NSTableColumn");
	__xamarin_class_map [1888].handle = objc_getClass ("NSTableHeaderCell");
	__xamarin_class_map [1889].handle = objc_getClass ("NSTableHeaderView");
	__xamarin_class_map [1890].handle = objc_getClass ("NSTableRowView");
	__xamarin_class_map [1891].handle = objc_getClass ("NSTableViewDataSource");
	__xamarin_class_map [1892].handle = objc_getClass ("NSTableViewDelegate");
	__xamarin_class_map [1893].handle = objc_getClass ("NSTableViewRowAction");
	__xamarin_class_map [1894].handle = objc_getClass ("NSTableViewSource");
	__xamarin_class_map [1895].handle = objc_getClass ("NSTabViewController");
	__xamarin_class_map [1896].handle = objc_getClass ("NSTabViewDelegate");
	__xamarin_class_map [1897].handle = objc_getClass ("NSTabViewItem");
	__xamarin_class_map [1898].handle = objc_getClass ("NSTextAttachment");
	__xamarin_class_map [1899].handle = objc_getClass ("NSTextAttachmentCell");
	__xamarin_class_map [1900].handle = objc_getClass ("NSTextAttachmentContainer");
	__xamarin_class_map [1901].handle = objc_getClass ("NSTextBlock");
	__xamarin_class_map [1902].handle = objc_getClass ("NSTextContainer");
	__xamarin_class_map [1903].handle = objc_getClass ("NSTextDelegate");
	__xamarin_class_map [1904].handle = objc_getClass ("NSTextFinder");
	__xamarin_class_map [1905].handle = objc_getClass ("NSTextFinderBarContainer");
	__xamarin_class_map [1906].handle = objc_getClass ("NSTextFinderClient");
	__xamarin_class_map [1907].handle = objc_getClass ("NSTextInputClient");
	__xamarin_class_map [1908].handle = objc_getClass ("NSTextList");
	__xamarin_class_map [1909].handle = objc_getClass ("NSTextStorageDelegate");
	__xamarin_class_map [1910].handle = objc_getClass ("NSTextTab");
	__xamarin_class_map [1911].handle = objc_getClass ("NSTextTable");
	__xamarin_class_map [1912].handle = objc_getClass ("NSTextTableBlock");
	__xamarin_class_map [1913].handle = objc_getClass ("NSTextViewDelegate");
	__xamarin_class_map [1914].handle = objc_getClass ("NSTitlebarAccessoryViewController");
	__xamarin_class_map [1915].handle = objc_getClass ("NSTokenField");
	__xamarin_class_map [1916].handle = objc_getClass ("NSTokenFieldCell");
	__xamarin_class_map [1917].handle = objc_getClass ("NSTokenFieldCellDelegate");
	__xamarin_class_map [1918].handle = objc_getClass ("NSTokenFieldDelegate");
	__xamarin_class_map [1919].handle = objc_getClass ("NSToolbarDelegate");
	__xamarin_class_map [1920].handle = objc_getClass ("NSToolbarItem");
	__xamarin_class_map [1921].handle = objc_getClass ("NSToolbarItemGroup");
	__xamarin_class_map [1922].handle = objc_getClass ("NSTouch");
	__xamarin_class_map [1923].handle = objc_getClass ("NSTouchBarDelegate");
	__xamarin_class_map [1924].handle = objc_getClass ("NSTrackingArea");
	__xamarin_class_map [1925].handle = objc_getClass ("NSTreeController");
	__xamarin_class_map [1926].handle = objc_getClass ("NSTreeNode");
	__xamarin_class_map [1927].handle = objc_getClass ("NSUserDefaultsController");
	__xamarin_class_map [1928].handle = objc_getClass ("NSUserInterfaceCompressionOptions");
	__xamarin_class_map [1929].handle = objc_getClass ("NSAnimation");
	__xamarin_class_map [1930].handle = objc_getClass ("NSViewAnimation");
	__xamarin_class_map [1931].handle = objc_getClass ("NSViewControllerPresentationAnimator");
	__xamarin_class_map [1932].handle = objc_getClass ("NSVisualEffectView");
	__xamarin_class_map [1933].handle = objc_getClass ("NSWindowDelegate");
	__xamarin_class_map [1934].handle = objc_getClass ("NSWindowRestoration");
	__xamarin_class_map [1935].handle = objc_getClass ("NSWindowTab");
	__xamarin_class_map [1936].handle = objc_getClass ("NSWindowTabGroup");
	__xamarin_class_map [1937].handle = objc_getClass ("NSWorkspaceAuthorization");
	__xamarin_class_map [1938].handle = objc_getClass ("__monomac_internal_ActionDispatcher");
	__xamarin_class_map [1939].handle = objc_getClass ("__MonoMac_NSAlertDidEndDispatcher");
	__xamarin_class_map [1940].handle = objc_getClass ("ASIdentifierManager");
	__xamarin_class_map [1941].handle = objc_getClass ("ACAccount");
	__xamarin_class_map [1942].handle = objc_getClass ("ACAccountCredential");
	__xamarin_class_map [1943].handle = objc_getClass ("ACAccountType");
	__xamarin_class_map [1944].handle = objc_getClass ("NSAffineTransform");
	__xamarin_class_map [1945].handle = objc_getClass ("NSAppleEventDescriptor");
	__xamarin_class_map [1946].handle = objc_getClass ("NSAppleEventManager");
	__xamarin_class_map [1947].handle = objc_getClass ("NSAppleScript");
	__xamarin_class_map [1948].handle = objc_getClass ("NSAttributedString");
	__xamarin_class_map [1949].handle = objc_getClass ("NSBindingSelectionMarker");
	__xamarin_class_map [1950].handle = objc_getClass ("NSBlockOperation");
	__xamarin_class_map [1951].handle = objc_getClass ("NSBundle");
	__xamarin_class_map [1952].handle = objc_getClass ("NSByteCountFormatter");
	__xamarin_class_map [1953].handle = objc_getClass ("NSCacheDelegate");
	__xamarin_class_map [1954].handle = objc_getClass ("NSCachedURLResponse");
	__xamarin_class_map [1955].handle = objc_getClass ("NSDate");
	__xamarin_class_map [1956].handle = objc_getClass ("NSCalendarDate");
	__xamarin_class_map [1957].handle = objc_getClass ("NSCharacterSet");
	__xamarin_class_map [1958].handle = objc_getClass ("NSCoder");
	__xamarin_class_map [1959].handle = objc_getClass ("NSCoding");
	__xamarin_class_map [1960].handle = objc_getClass ("NSPredicate");
	__xamarin_class_map [1961].handle = objc_getClass ("NSComparisonPredicate");
	__xamarin_class_map [1962].handle = objc_getClass ("NSCompoundPredicate");
	__xamarin_class_map [1963].handle = objc_getClass ("NSCondition");
	__xamarin_class_map [1964].handle = objc_getClass ("NSConditionLock");
	__xamarin_class_map [1965].handle = objc_getClass ("NSConnection");
	__xamarin_class_map [1966].handle = objc_getClass ("NSConnectionDelegate");
	__xamarin_class_map [1967].handle = objc_getClass ("NSCopying");
	__xamarin_class_map [1968].handle = objc_getClass ("NSRegularExpression");
	__xamarin_class_map [1969].handle = objc_getClass ("NSDataDetector");
	__xamarin_class_map [1970].handle = objc_getClass ("NSDateComponents");
	__xamarin_class_map [1971].handle = objc_getClass ("NSDateComponentsFormatter");
	__xamarin_class_map [1972].handle = objc_getClass ("NSDateFormatter");
	__xamarin_class_map [1973].handle = objc_getClass ("NSDateInterval");
	__xamarin_class_map [1974].handle = objc_getClass ("NSDateIntervalFormatter");
	__xamarin_class_map [1975].handle = objc_getClass ("NSValue");
	__xamarin_class_map [1976].handle = objc_getClass ("NSNumber");
	__xamarin_class_map [1977].handle = objc_getClass ("NSDecimalNumber");
	__xamarin_class_map [1978].handle = objc_getClass ("NSUnit");
	__xamarin_class_map [1979].handle = objc_getClass ("NSDimension");
	__xamarin_class_map [1980].handle = objc_getClass ("NSEnumerator");
	__xamarin_class_map [1981].handle = objc_getClass ("NSDirectoryEnumerator");
	__xamarin_class_map [1982].handle = objc_getClass ("NSDistantObjectRequest");
	__xamarin_class_map [1983].handle = objc_getClass ("NSDistributedLock");
	__xamarin_class_map [1984].handle = objc_getClass ("NSNotificationCenter");
	__xamarin_class_map [1985].handle = objc_getClass ("NSDistributedNotificationCenter");
	__xamarin_class_map [1986].handle = objc_getClass ("NSEnergyFormatter");
	__xamarin_class_map [1987].handle = objc_getClass ("NSError");
	__xamarin_class_map [1988].handle = objc_getClass ("NSException");
	__xamarin_class_map [1989].handle = objc_getClass ("NSExtensionItem");
	__xamarin_class_map [1990].handle = objc_getClass ("NSExtensionRequestHandling");
	__xamarin_class_map [1991].handle = objc_getClass ("NSFileAccessIntent");
	__xamarin_class_map [1992].handle = objc_getClass ("NSFileCoordinator");
	__xamarin_class_map [1993].handle = objc_getClass ("NSFileManagerDelegate");
	__xamarin_class_map [1994].handle = objc_getClass ("NSFilePresenter");
	__xamarin_class_map [1995].handle = objc_getClass ("NSFileProviderService");
	__xamarin_class_map [1996].handle = objc_getClass ("NSFileWrapper");
	__xamarin_class_map [1997].handle = objc_getClass ("NSHTTPCookie");
	__xamarin_class_map [1998].handle = objc_getClass ("NSURLResponse");
	__xamarin_class_map [1999].handle = objc_getClass ("NSHTTPURLResponse");
	__xamarin_class_map [2000].handle = objc_getClass ("NSStream");
	__xamarin_class_map [2001].handle = objc_getClass ("NSInputStream");
	__xamarin_class_map [2002].handle = objc_getClass ("NSInvocation");
	__xamarin_class_map [2003].handle = objc_getClass ("NSISO8601DateFormatter");
	__xamarin_class_map [2004].handle = objc_getClass ("NSJSONSerialization");
	__xamarin_class_map [2005].handle = objc_getClass ("NSKeyedArchiverDelegate");
	__xamarin_class_map [2006].handle = objc_getClass ("NSKeyedUnarchiverDelegate");
	__xamarin_class_map [2007].handle = objc_getClass ("NSLengthFormatter");
	__xamarin_class_map [2008].handle = objc_getClass ("NSLinguisticTagger");
	__xamarin_class_map [2009].handle = objc_getClass ("NSLock");
	__xamarin_class_map [2010].handle = objc_getClass ("NSPort");
	__xamarin_class_map [2011].handle = objc_getClass ("NSMachPort");
	__xamarin_class_map [2012].handle = objc_getClass ("NSPortDelegate");
	__xamarin_class_map [2013].handle = objc_getClass ("NSMachPortDelegate");
	__xamarin_class_map [2014].handle = objc_getClass ("NSMassFormatter");
	__xamarin_class_map [2015].handle = objc_getClass ("NSMeasurement");
	__xamarin_class_map [2016].handle = objc_getClass ("NSMeasurementFormatter");
	__xamarin_class_map [2017].handle = objc_getClass ("NSMetadataItem");
	__xamarin_class_map [2018].handle = objc_getClass ("NSMetadataQueryAttributeValueTuple");
	__xamarin_class_map [2019].handle = objc_getClass ("NSMetadataQueryDelegate");
	__xamarin_class_map [2020].handle = objc_getClass ("NSMetadataQueryResultGroup");
	__xamarin_class_map [2021].handle = objc_getClass ("NSMethodSignature");
	__xamarin_class_map [2022].handle = objc_getClass ("NSMutableAttributedString");
	__xamarin_class_map [2023].handle = objc_getClass ("NSMutableCharacterSet");
	__xamarin_class_map [2024].handle = objc_getClass ("NSMutableCopying");
	__xamarin_class_map [2025].handle = objc_getClass ("NSIndexSet");
	__xamarin_class_map [2026].handle = objc_getClass ("NSMutableIndexSet");
	__xamarin_class_map [2027].handle = objc_getClass ("NSOrderedSet");
	__xamarin_class_map [2028].handle = objc_getClass ("NSMutableOrderedSet");
	__xamarin_class_map [2029].handle = objc_getClass ("NSSet");
	__xamarin_class_map [2030].handle = objc_getClass ("NSMutableSet");
	__xamarin_class_map [2031].handle = objc_getClass ("NSMutableString");
	__xamarin_class_map [2032].handle = objc_getClass ("NSURLRequest");
	__xamarin_class_map [2033].handle = objc_getClass ("NSMutableURLRequest");
	__xamarin_class_map [2034].handle = objc_getClass ("NSNetServiceBrowserDelegate");
	__xamarin_class_map [2035].handle = objc_getClass ("NSNetServiceDelegate");
	__xamarin_class_map [2036].handle = objc_getClass ("NSNotification");
	__xamarin_class_map [2037].handle = objc_getClass ("NSNotificationQueue");
	__xamarin_class_map [2038].handle = objc_getClass ("NSNull");
	__xamarin_class_map [2039].handle = objc_getClass ("NSNumberFormatter");
	__xamarin_class_map [2040].handle = objc_getClass ("NSOperationQueue");
	__xamarin_class_map [2041].handle = objc_getClass ("NSOrthography");
	__xamarin_class_map [2042].handle = objc_getClass ("NSOutputStream");
	__xamarin_class_map [2043].handle = objc_getClass ("NSPersonNameComponents");
	__xamarin_class_map [2044].handle = objc_getClass ("NSPersonNameComponentsFormatter");
	__xamarin_class_map [2045].handle = objc_getClass ("NSPipe");
	__xamarin_class_map [2046].handle = objc_getClass ("NSPortMessage");
	__xamarin_class_map [2047].handle = objc_getClass ("NSPortNameServer");
	__xamarin_class_map [2048].handle = objc_getClass ("NSPropertyListSerialization");
	__xamarin_class_map [2049].handle = objc_getClass ("NSData");
	__xamarin_class_map [2050].handle = objc_getClass ("NSMutableData");
	__xamarin_class_map [2051].handle = objc_getClass ("NSPurgeableData");
	__xamarin_class_map [2052].handle = objc_getClass ("NSRecursiveLock");
	__xamarin_class_map [2053].handle = objc_getClass ("NSRunLoop");
	__xamarin_class_map [2054].handle = objc_getClass ("NSScriptCommand");
	__xamarin_class_map [2055].handle = objc_getClass ("NSScriptCommandDescription");
	__xamarin_class_map [2056].handle = objc_getClass ("NSStreamDelegate");
	__xamarin_class_map [2057].handle = objc_getClass ("NSTextCheckingResult");
	__xamarin_class_map [2058].handle = objc_getClass ("NSTimer");
	__xamarin_class_map [2059].handle = objc_getClass ("NSTimeZone");
	__xamarin_class_map [2060].handle = objc_getClass ("NSUnitAcceleration");
	__xamarin_class_map [2061].handle = objc_getClass ("NSUnitAngle");
	__xamarin_class_map [2062].handle = objc_getClass ("NSUnitArea");
	__xamarin_class_map [2063].handle = objc_getClass ("NSUnitConcentrationMass");
	__xamarin_class_map [2064].handle = objc_getClass ("NSUnitConverter");
	__xamarin_class_map [2065].handle = objc_getClass ("NSUnitConverterLinear");
	__xamarin_class_map [2066].handle = objc_getClass ("NSUnitDispersion");
	__xamarin_class_map [2067].handle = objc_getClass ("NSUnitDuration");
	__xamarin_class_map [2068].handle = objc_getClass ("NSUnitElectricCharge");
	__xamarin_class_map [2069].handle = objc_getClass ("NSUnitElectricCurrent");
	__xamarin_class_map [2070].handle = objc_getClass ("NSUnitElectricPotentialDifference");
	__xamarin_class_map [2071].handle = objc_getClass ("NSUnitElectricResistance");
	__xamarin_class_map [2072].handle = objc_getClass ("NSUnitEnergy");
	__xamarin_class_map [2073].handle = objc_getClass ("NSUnitFrequency");
	__xamarin_class_map [2074].handle = objc_getClass ("NSUnitFuelEfficiency");
	__xamarin_class_map [2075].handle = objc_getClass ("NSUnitIlluminance");
	__xamarin_class_map [2076].handle = objc_getClass ("NSUnitLength");
	__xamarin_class_map [2077].handle = objc_getClass ("NSUnitMass");
	__xamarin_class_map [2078].handle = objc_getClass ("NSUnitPower");
	__xamarin_class_map [2079].handle = objc_getClass ("NSUnitPressure");
	__xamarin_class_map [2080].handle = objc_getClass ("NSUnitSpeed");
	__xamarin_class_map [2081].handle = objc_getClass ("NSUnitTemperature");
	__xamarin_class_map [2082].handle = objc_getClass ("NSUnitVolume");
	__xamarin_class_map [2083].handle = objc_getClass ("NSURLAuthenticationChallenge");
	__xamarin_class_map [2084].handle = objc_getClass ("NSURLAuthenticationChallengeSender");
	__xamarin_class_map [2085].handle = objc_getClass ("NSURLComponents");
	__xamarin_class_map [2086].handle = objc_getClass ("NSURLConnectionDelegate");
	__xamarin_class_map [2087].handle = objc_getClass ("NSURLConnectionDataDelegate");
	__xamarin_class_map [2088].handle = objc_getClass ("NSURLConnectionDownloadDelegate");
	__xamarin_class_map [2089].handle = objc_getClass ("NSURLCredential");
	__xamarin_class_map [2090].handle = objc_getClass ("NSUrlDownloadDelegate");
	__xamarin_class_map [2091].handle = objc_getClass ("NSURLProtectionSpace");
	__xamarin_class_map [2092].handle = objc_getClass ("NSURLProtocol");
	__xamarin_class_map [2093].handle = objc_getClass ("NSURLQueryItem");
	__xamarin_class_map [2094].handle = objc_getClass ("NSURLSessionConfiguration");
	__xamarin_class_map [2095].handle = objc_getClass ("NSURLSessionDelegate");
	__xamarin_class_map [2096].handle = objc_getClass ("NSURLSessionTaskDelegate");
	__xamarin_class_map [2097].handle = objc_getClass ("NSURLSessionDataDelegate");
	__xamarin_class_map [2098].handle = objc_getClass ("NSURLSessionTask");
	__xamarin_class_map [2099].handle = objc_getClass ("NSURLSessionDataTask");
	__xamarin_class_map [2100].handle = objc_getClass ("NSURLSessionDownloadDelegate");
	__xamarin_class_map [2101].handle = objc_getClass ("NSURLSessionDownloadTask");
	__xamarin_class_map [2102].handle = objc_getClass ("NSURLSessionStreamDelegate");
	__xamarin_class_map [2103].handle = objc_getClass ("NSURLSessionTaskMetrics");
	__xamarin_class_map [2104].handle = objc_getClass ("NSURLSessionTaskTransactionMetrics");
	__xamarin_class_map [2105].handle = objc_getClass ("NSURLSessionUploadTask");
	__xamarin_class_map [2106].handle = objc_getClass ("NSUserActivityDelegate");
	__xamarin_class_map [2107].handle = objc_getClass ("NSUserNotification");
	__xamarin_class_map [2108].handle = objc_getClass ("NSUserNotificationAction");
	__xamarin_class_map [2109].handle = objc_getClass ("NSUserNotificationCenterDelegate");
	__xamarin_class_map [2110].handle = objc_getClass ("NSUUID");
	__xamarin_class_map [2111].handle = objc_getClass ("NSValueTransformer");
	__xamarin_class_map [2112].handle = objc_getClass ("NSXPCListenerEndpoint");
	__xamarin_class_map [2113].handle = objc_getClass ("Foundation_InternalNSNotificationHandler");
	__xamarin_class_map [2114].handle = objc_getClass ("NSProxy");
	__xamarin_class_map [2115].handle = objc_getClass ("Foundation_NSUrlProtocolClient");
	__xamarin_class_map [2116].handle = objc_getClass ("Foundation_NSDispatcher");
	__xamarin_class_map [2117].handle = objc_getClass ("__MonoMac_NSActionDispatcher");
	__xamarin_class_map [2118].handle = objc_getClass ("__MonoMac_NSSynchronizationContextDispatcher");
	__xamarin_class_map [2119].handle = objc_getClass ("__Xamarin_NSTimerActionDispatcher");
	__xamarin_class_map [2120].handle = objc_getClass ("Foundation_NSAsyncDispatcher");
	__xamarin_class_map [2121].handle = objc_getClass ("__MonoMac_NSAsyncActionDispatcher");
	__xamarin_class_map [2122].handle = objc_getClass ("__MonoMac_NSAsyncSynchronizationContextDispatcher");
	__xamarin_class_map [2123].handle = objc_getClass ("NSAutoreleasePool");
	__xamarin_class_map [2124].handle = objc_getClass ("UNUserNotificationCenter");
	__xamarin_class_map [2125].handle = objc_getClass ("WebHistoryItem");
	__xamarin_class_map [2126].handle = objc_getClass ("WebView");
	__xamarin_class_map [2127].handle = objc_getClass ("WKContentRuleListStore");
	__xamarin_class_map [2128].handle = objc_getClass ("WKHTTPCookieStore");
	__xamarin_class_map [2129].handle = objc_getClass ("WKWebsiteDataStore");
	__xamarin_class_map [2130].handle = objc_getClass ("WKWebView");
	__xamarin_class_map [2131].handle = objc_getClass ("SKProductsRequest");
	__xamarin_class_map [2132].handle = objc_getClass ("SKPhysicsWorld");
	__xamarin_class_map [2133].handle = objc_getClass ("SKTextureAtlas");
	__xamarin_class_map [2134].handle = objc_getClass ("SLRequest");
	__xamarin_class_map [2135].handle = objc_getClass ("SBApplication");
	__xamarin_class_map [2136].handle = objc_getClass ("SCNAnimationEvent");
	__xamarin_class_map [2137].handle = objc_getClass ("SCNLayer");
	__xamarin_class_map [2138].handle = objc_getClass ("SCNPhysicsWorld");
	__xamarin_class_map [2139].handle = objc_getClass ("SCNRenderer");
	__xamarin_class_map [2140].handle = objc_getClass ("SCNView");
	__xamarin_class_map [2141].handle = objc_getClass ("SFContentBlockerManager");
	__xamarin_class_map [2142].handle = objc_getClass ("SFSafariApplication");
	__xamarin_class_map [2143].handle = objc_getClass ("SFSafariExtensionHandler");
	__xamarin_class_map [2144].handle = objc_getClass ("SFSafariPage");
	__xamarin_class_map [2145].handle = objc_getClass ("SFSafariTab");
	__xamarin_class_map [2146].handle = objc_getClass ("SFSafariWindow");
	__xamarin_class_map [2147].handle = objc_getClass ("PHLivePhotoEditingContext");
	__xamarin_class_map [2148].handle = objc_getClass ("PHPhotoLibrary");
	__xamarin_class_map [2149].handle = objc_getClass ("PDFDocument");
	__xamarin_class_map [2150].handle = objc_getClass ("PDFThumbnailView");
	__xamarin_class_map [2151].handle = objc_getClass ("PDFView");
	__xamarin_class_map [2152].handle = objc_getClass ("NCWidgetListViewController");
	__xamarin_class_map [2153].handle = objc_getClass ("NCWidgetSearchViewController");
	__xamarin_class_map [2154].handle = objc_getClass ("NEAppProxyFlow");
	__xamarin_class_map [2155].handle = objc_getClass ("NEProvider");
	__xamarin_class_map [2156].handle = objc_getClass ("NETunnelProvider");
	__xamarin_class_map [2157].handle = objc_getClass ("NEAppProxyProvider");
	__xamarin_class_map [2158].handle = objc_getClass ("NEVPNManager");
	__xamarin_class_map [2159].handle = objc_getClass ("NETunnelProviderManager");
	__xamarin_class_map [2160].handle = objc_getClass ("NEAppProxyProviderManager");
	__xamarin_class_map [2161].handle = objc_getClass ("NEAppProxyTCPFlow");
	__xamarin_class_map [2162].handle = objc_getClass ("NEAppProxyUDPFlow");
	__xamarin_class_map [2163].handle = objc_getClass ("NEFilterManager");
	__xamarin_class_map [2164].handle = objc_getClass ("NEFilterProvider");
	__xamarin_class_map [2165].handle = objc_getClass ("NEPacketTunnelFlow");
	__xamarin_class_map [2166].handle = objc_getClass ("NEPacketTunnelProvider");
	__xamarin_class_map [2167].handle = objc_getClass ("NWTCPConnection");
	__xamarin_class_map [2168].handle = objc_getClass ("NWUDPSession");
	__xamarin_class_map [2169].handle = objc_getClass ("NLLanguageRecognizer");
	__xamarin_class_map [2170].handle = objc_getClass ("NLTagger");
	__xamarin_class_map [2171].handle = objc_getClass ("MCSession");
	__xamarin_class_map [2172].handle = objc_getClass ("MDLMesh");
	__xamarin_class_map [2173].handle = objc_getClass ("MPSNNGraph");
	__xamarin_class_map [2174].handle = objc_getClass ("MTKTextureLoader");
	__xamarin_class_map [2175].handle = objc_getClass ("MPSkipIntervalCommand");
	__xamarin_class_map [2176].handle = objc_getClass ("MKDirections");
	__xamarin_class_map [2177].handle = objc_getClass ("MKLocalSearch");
	__xamarin_class_map [2178].handle = objc_getClass ("MKMapSnapshotter");
	__xamarin_class_map [2179].handle = objc_getClass ("MKMapView");
	__xamarin_class_map [2180].handle = objc_getClass ("LAContext");
	__xamarin_class_map [2181].handle = objc_getClass ("INInteraction");
	__xamarin_class_map [2182].handle = objc_getClass ("IKCameraDeviceView");
	__xamarin_class_map [2183].handle = objc_getClass ("IKDeviceBrowserView");
	__xamarin_class_map [2184].handle = objc_getClass ("IKFilterBrowserPanel");
	__xamarin_class_map [2185].handle = objc_getClass ("IKImageBrowserView");
	__xamarin_class_map [2186].handle = objc_getClass ("IKSaveOptions");
	__xamarin_class_map [2187].handle = objc_getClass ("IKScannerDeviceView");
	__xamarin_class_map [2188].handle = objc_getClass ("GLKTextureLoader");
	__xamarin_class_map [2189].handle = objc_getClass ("GKAchievement");
	__xamarin_class_map [2190].handle = objc_getClass ("GKAchievementDescription");
	__xamarin_class_map [2191].handle = objc_getClass ("GKGameCenterViewController");
	__xamarin_class_map [2192].handle = objc_getClass ("GKAchievementViewController");
	__xamarin_class_map [2193].handle = objc_getClass ("GKChallengeEventHandler");
	__xamarin_class_map [2194].handle = objc_getClass ("GKFriendRequestComposeViewController");
	__xamarin_class_map [2195].handle = objc_getClass ("GKGameSession");
	__xamarin_class_map [2196].handle = objc_getClass ("GKLeaderboard");
	__xamarin_class_map [2197].handle = objc_getClass ("GKLeaderboardSet");
	__xamarin_class_map [2198].handle = objc_getClass ("GKLeaderboardViewController");
	__xamarin_class_map [2199].handle = objc_getClass ("GKPlayer");
	__xamarin_class_map [2200].handle = objc_getClass ("GKLocalPlayer");
	__xamarin_class_map [2201].handle = objc_getClass ("GKMatch");
	__xamarin_class_map [2202].handle = objc_getClass ("GKMatchmaker");
	__xamarin_class_map [2203].handle = objc_getClass ("GKMatchmakerViewController");
	__xamarin_class_map [2204].handle = objc_getClass ("GKNotificationBanner");
	__xamarin_class_map [2205].handle = objc_getClass ("GKSavedGame");
	__xamarin_class_map [2206].handle = objc_getClass ("GKScore");
	__xamarin_class_map [2207].handle = objc_getClass ("GKTurnBasedExchange");
	__xamarin_class_map [2208].handle = objc_getClass ("GKTurnBasedMatch");
	__xamarin_class_map [2209].handle = objc_getClass ("GCController");
	__xamarin_class_map [2210].handle = objc_getClass ("FIFinderSync");
	__xamarin_class_map [2211].handle = objc_getClass ("FIFinderSyncController");
	__xamarin_class_map [2212].handle = objc_getClass ("EAAccessory");
	__xamarin_class_map [2213].handle = objc_getClass ("EAAccessoryManager");
	__xamarin_class_map [2214].handle = objc_getClass ("EKEventStore");
	__xamarin_class_map [2215].handle = objc_getClass ("CWInterface");
	__xamarin_class_map [2216].handle = objc_getClass ("CSSearchableIndex");
	__xamarin_class_map [2217].handle = objc_getClass ("MLMultiArray");
	__xamarin_class_map [2218].handle = objc_getClass ("CLGeocoder");
	__xamarin_class_map [2219].handle = objc_getClass ("CLLocationManager");
	__xamarin_class_map [2220].handle = objc_getClass ("NSManagedObjectContext");
	__xamarin_class_map [2221].handle = objc_getClass ("NSPersistentContainer");
	__xamarin_class_map [2222].handle = objc_getClass ("NSPersistentStoreCoordinator");
	__xamarin_class_map [2223].handle = objc_getClass ("CBCentralManager");
	__xamarin_class_map [2224].handle = objc_getClass ("CBPeripheral");
	__xamarin_class_map [2225].handle = objc_getClass ("CBPeripheralManager");
	__xamarin_class_map [2226].handle = objc_getClass ("CNContactStore");
	__xamarin_class_map [2227].handle = objc_getClass ("CKContainer");
	__xamarin_class_map [2228].handle = objc_getClass ("CKDatabase");
	__xamarin_class_map [2229].handle = objc_getClass ("AVAssetExportSession");
	__xamarin_class_map [2230].handle = objc_getClass ("AVAssetWriter");
	__xamarin_class_map [2231].handle = objc_getClass ("AVAudioEngine");
	__xamarin_class_map [2232].handle = objc_getClass ("AVAudioPlayerNode");
	__xamarin_class_map [2233].handle = objc_getClass ("AVAudioUnitComponent");
	__xamarin_class_map [2234].handle = objc_getClass ("AVCaptureDevice");
	__xamarin_class_map [2235].handle = objc_getClass ("AVCaptureSession");
	__xamarin_class_map [2236].handle = objc_getClass ("AVCaptureStillImageOutput");
	__xamarin_class_map [2237].handle = objc_getClass ("AVCaptureVideoPreviewLayer");
	__xamarin_class_map [2238].handle = objc_getClass ("AVFragmentedMovie");
	__xamarin_class_map [2239].handle = objc_getClass ("AVFragmentedMovieTrack");
	__xamarin_class_map [2240].handle = objc_getClass ("AVMIDIPlayer");
	__xamarin_class_map [2241].handle = objc_getClass ("AVPlayerItem");
	__xamarin_class_map [2242].handle = objc_getClass ("AVPlayerItemVideoOutput");
	__xamarin_class_map [2243].handle = objc_getClass ("AVRouteDetector");
	__xamarin_class_map [2244].handle = objc_getClass ("AVSampleBufferAudioRenderer");
	__xamarin_class_map [2245].handle = objc_getClass ("AVSampleBufferDisplayLayer");
	__xamarin_class_map [2246].handle = objc_getClass ("AVSampleBufferGenerator");
	__xamarin_class_map [2247].handle = objc_getClass ("AVSampleBufferRenderSynchronizer");
	__xamarin_class_map [2248].handle = objc_getClass ("AUAudioUnit");
	__xamarin_class_map [2249].handle = objc_getClass ("NSAccessibilityElement");
	__xamarin_class_map [2250].handle = objc_getClass ("NSAlert");
	__xamarin_class_map [2251].handle = objc_getClass ("NSApplication");
	__xamarin_class_map [2252].handle = objc_getClass ("NSBrowser");
	__xamarin_class_map [2253].handle = objc_getClass ("NSGestureRecognizer");
	__xamarin_class_map [2254].handle = objc_getClass ("NSClickGestureRecognizer");
	__xamarin_class_map [2255].handle = objc_getClass ("NSColor");
	__xamarin_class_map [2256].handle = objc_getClass ("NSColorPanel");
	__xamarin_class_map [2257].handle = objc_getClass ("NSComboBox");
	__xamarin_class_map [2258].handle = objc_getClass ("NSDatePicker");
	__xamarin_class_map [2259].handle = objc_getClass ("NSDatePickerCell");
	__xamarin_class_map [2260].handle = objc_getClass ("NSDocument");
	__xamarin_class_map [2261].handle = objc_getClass ("NSDrawer");
	__xamarin_class_map [2262].handle = objc_getClass ("NSEvent");
	__xamarin_class_map [2263].handle = objc_getClass ("NSFont");
	__xamarin_class_map [2264].handle = objc_getClass ("NSGradient");
	__xamarin_class_map [2265].handle = objc_getClass ("NSHelpManager");
	__xamarin_class_map [2266].handle = objc_getClass ("NSImage");
	__xamarin_class_map [2267].handle = objc_getClass ("NSMagnificationGestureRecognizer");
	__xamarin_class_map [2268].handle = objc_getClass ("NSMenu");
	__xamarin_class_map [2269].handle = objc_getClass ("NSMenuItem");
	__xamarin_class_map [2270].handle = objc_getClass ("NSTableView");
	__xamarin_class_map [2271].handle = objc_getClass ("NSOutlineView");
	__xamarin_class_map [2272].handle = objc_getClass ("NSPageController");
	__xamarin_class_map [2273].handle = objc_getClass ("NSPanGestureRecognizer");
	__xamarin_class_map [2274].handle = objc_getClass ("NSPathCell");
	__xamarin_class_map [2275].handle = objc_getClass ("NSPopover");
	__xamarin_class_map [2276].handle = objc_getClass ("NSPopUpButton");
	__xamarin_class_map [2277].handle = objc_getClass ("NSPopUpButtonCell");
	__xamarin_class_map [2278].handle = objc_getClass ("NSPredicateEditorRowTemplate");
	__xamarin_class_map [2279].handle = objc_getClass ("NSPressGestureRecognizer");
	__xamarin_class_map [2280].handle = objc_getClass ("NSRotationGestureRecognizer");
	__xamarin_class_map [2281].handle = objc_getClass ("NSScreen");
	__xamarin_class_map [2282].handle = objc_getClass ("NSScroller");
	__xamarin_class_map [2283].handle = objc_getClass ("NSScrollView");
	__xamarin_class_map [2284].handle = objc_getClass ("NSSearchField");
	__xamarin_class_map [2285].handle = objc_getClass ("NSSharingService");
	__xamarin_class_map [2286].handle = objc_getClass ("NSSharingServicePicker");
	__xamarin_class_map [2287].handle = objc_getClass ("NSSliderAccessory");
	__xamarin_class_map [2288].handle = objc_getClass ("NSSound");
	__xamarin_class_map [2289].handle = objc_getClass ("NSSpellChecker");
	__xamarin_class_map [2290].handle = objc_getClass ("NSSplitView");
	__xamarin_class_map [2291].handle = objc_getClass ("NSTabView");
	__xamarin_class_map [2292].handle = objc_getClass ("NSText");
	__xamarin_class_map [2293].handle = objc_getClass ("NSTextAlternatives");
	__xamarin_class_map [2294].handle = objc_getClass ("NSTextInputContext");
	__xamarin_class_map [2295].handle = objc_getClass ("NSTextStorage");
	__xamarin_class_map [2296].handle = objc_getClass ("NSTextView");
	__xamarin_class_map [2297].handle = objc_getClass ("NSToolbar");
	__xamarin_class_map [2298].handle = objc_getClass ("NSTouchBar");
	__xamarin_class_map [2299].handle = objc_getClass ("NSWorkspace");
	__xamarin_class_map [2300].handle = objc_getClass ("ACAccountStore");
	__xamarin_class_map [2301].handle = objc_getClass ("NSCache");
	__xamarin_class_map [2302].handle = objc_getClass ("NSCalendar");
	__xamarin_class_map [2303].handle = objc_getClass ("NSDictionary");
	__xamarin_class_map [2304].handle = objc_getClass ("NSFileHandle");
	__xamarin_class_map [2305].handle = objc_getClass ("NSFileManager");
	__xamarin_class_map [2306].handle = objc_getClass ("NSFileVersion");
	__xamarin_class_map [2307].handle = objc_getClass ("NSHost");
	__xamarin_class_map [2308].handle = objc_getClass ("NSHTTPCookieStorage");
	__xamarin_class_map [2309].handle = objc_getClass ("NSIndexPath");
	__xamarin_class_map [2310].handle = objc_getClass ("NSItemProvider");
	__xamarin_class_map [2311].handle = objc_getClass ("NSKeyedArchiver");
	__xamarin_class_map [2312].handle = objc_getClass ("NSKeyedUnarchiver");
	__xamarin_class_map [2313].handle = objc_getClass ("NSLocale");
	__xamarin_class_map [2314].handle = objc_getClass ("NSMetadataQuery");
	__xamarin_class_map [2315].handle = objc_getClass ("NSMutableDictionary");
	__xamarin_class_map [2316].handle = objc_getClass ("NSNetService");
	__xamarin_class_map [2317].handle = objc_getClass ("NSNetServiceBrowser");
	__xamarin_class_map [2318].handle = objc_getClass ("NSProcessInfo");
	__xamarin_class_map [2319].handle = objc_getClass ("NSProgress");
	__xamarin_class_map [2320].handle = objc_getClass ("NSSecureUnarchiveFromDataTransformer");
	__xamarin_class_map [2321].handle = objc_getClass ("NSTask");
	__xamarin_class_map [2322].handle = objc_getClass ("NSThread");
	__xamarin_class_map [2323].handle = objc_getClass ("NSUbiquitousKeyValueStore");
	__xamarin_class_map [2324].handle = objc_getClass ("NSUndoManager");
	__xamarin_class_map [2325].handle = objc_getClass ("NSURL");
	__xamarin_class_map [2326].handle = objc_getClass ("NSURLCache");
	__xamarin_class_map [2327].handle = objc_getClass ("NSURLConnection");
	__xamarin_class_map [2328].handle = objc_getClass ("NSURLCredentialStorage");
	__xamarin_class_map [2329].handle = objc_getClass ("NSURLSession");
	__xamarin_class_map [2330].handle = objc_getClass ("NSURLSessionStreamTask");
	__xamarin_class_map [2331].handle = objc_getClass ("NSUserActivity");
	__xamarin_class_map [2332].handle = objc_getClass ("NSUserDefaults");
	__xamarin_class_map [2333].handle = objc_getClass ("NSUserNotificationCenter");
	__xamarin_class_map [2334].handle = objc_getClass ("WebKit_DomNode_DomNodeEventProxy");
	__xamarin_class_map [2335].handle = objc_getClass ("WebKit_DomNode_DomNodeEventProxy2");
	__xamarin_class_map [2336].handle = objc_getClass ("WebKit_WebView__WebFrameLoadDelegate");
	__xamarin_class_map [2337].handle = objc_getClass ("WebKit_WebView__WebDownloadDelegate");
	__xamarin_class_map [2338].handle = objc_getClass ("WebKit_WebView__WebResourceLoadDelegate");
	__xamarin_class_map [2339].handle = objc_getClass ("WebKit_WebView__WebUIDelegate");
	__xamarin_class_map [2340].handle = objc_getClass ("WebKit_WebView__WebPolicyDelegate");
	__xamarin_class_map [2341].handle = objc_getClass ("StoreKit_SKRequest__SKRequestDelegate");
	__xamarin_class_map [2342].handle = objc_getClass ("StoreKit_SKProductsRequest__SKProductsRequestDelegate");
	__xamarin_class_map [2343].handle = objc_getClass ("SpriteKit_SKPhysicsWorld__SKPhysicsContactDelegate");
	__xamarin_class_map [2344].handle = objc_getClass ("ScriptingBridge_SBApplication__SBApplicationDelegate");
	__xamarin_class_map [2345].handle = objc_getClass ("SceneKit_SCNPhysicsWorld__SCNPhysicsContactDelegate");
	__xamarin_class_map [2346].handle = objc_getClass ("PdfKit_PdfDocument__PdfDocumentDelegate");
	__xamarin_class_map [2347].handle = objc_getClass ("PdfKit_PdfView__PdfViewDelegate");
	__xamarin_class_map [2348].handle = objc_getClass ("NotificationCenter_NCWidgetListViewController__NCWidgetListViewDelegate");
	__xamarin_class_map [2349].handle = objc_getClass ("NotificationCenter_NCWidgetSearchViewController__NCWidgetSearchViewDelegate");
	__xamarin_class_map [2350].handle = objc_getClass ("MapKit_MKMapView__MKMapViewDelegate");
	__xamarin_class_map [2351].handle = objc_getClass ("ImageKit_IKCameraDeviceView__IKCameraDeviceViewDelegate");
	__xamarin_class_map [2352].handle = objc_getClass ("ImageKit_IKDeviceBrowserView__IKDeviceBrowserViewDelegate");
	__xamarin_class_map [2353].handle = objc_getClass ("ImageKit_IKImageBrowserView__IKImageBrowserDelegate");
	__xamarin_class_map [2354].handle = objc_getClass ("ImageKit_IKSaveOptions__IKSaveOptionsDelegate");
	__xamarin_class_map [2355].handle = objc_getClass ("ImageKit_IKScannerDeviceView__IKScannerDeviceViewDelegate");
	__xamarin_class_map [2356].handle = objc_getClass ("GameKit_GKGameCenterViewController__GKGameCenterControllerDelegate");
	__xamarin_class_map [2357].handle = objc_getClass ("GameKit_GKAchievementViewController__GKAchievementViewControllerDelegate");
	__xamarin_class_map [2358].handle = objc_getClass ("GameKit_GKChallengeEventHandler__GKChallengeEventHandlerDelegate");
	__xamarin_class_map [2359].handle = objc_getClass ("GameKit_GKFriendRequestComposeViewController__GKFriendRequestComposeViewControllerDelegate");
	__xamarin_class_map [2360].handle = objc_getClass ("GameKit_GKLeaderboardViewController__GKLeaderboardViewControllerDelegate");
	__xamarin_class_map [2361].handle = objc_getClass ("GameKit_GKMatch__GKMatchDelegate");
	__xamarin_class_map [2362].handle = objc_getClass ("GameKit_GKMatchmakerViewController__GKMatchmakerViewControllerDelegate");
	__xamarin_class_map [2363].handle = objc_getClass ("ExternalAccessory_EAAccessory__EAAccessoryDelegate");
	__xamarin_class_map [2364].handle = objc_getClass ("CoreLocation_CLLocationManager__CLLocationManagerDelegate");
	__xamarin_class_map [2365].handle = objc_getClass ("CoreBluetooth_CBCentralManager__CBCentralManagerDelegate");
	__xamarin_class_map [2366].handle = objc_getClass ("CoreBluetooth_CBPeripheral__CBPeripheralDelegate");
	__xamarin_class_map [2367].handle = objc_getClass ("CoreBluetooth_CBPeripheralManager__CBPeripheralManagerDelegate");
	__xamarin_class_map [2368].handle = objc_getClass ("CoreAnimation_CAAnimation__CAAnimationDelegate");
	__xamarin_class_map [2369].handle = objc_getClass ("AVFoundation_AVCaptureFileOutput_recordingProxy");
	__xamarin_class_map [2370].handle = objc_getClass ("AppKit_NSAlert__NSAlertDelegate");
	__xamarin_class_map [2371].handle = objc_getClass ("AppKit_NSAnimation__NSAnimationDelegate");
	__xamarin_class_map [2372].handle = objc_getClass ("AppKit_NSApplication__NSApplicationDelegate");
	__xamarin_class_map [2373].handle = objc_getClass ("__NSGestureRecognizerToken");
	__xamarin_class_map [2374].handle = objc_getClass ("__NSClickGestureRecognizer");
	__xamarin_class_map [2375].handle = objc_getClass ("AppKit_NSTextField__NSTextFieldDelegate");
	__xamarin_class_map [2376].handle = objc_getClass ("AppKit_NSComboBox__NSComboBoxDelegate");
	__xamarin_class_map [2377].handle = objc_getClass ("AppKit_NSDatePicker__NSDatePickerCellDelegate");
	__xamarin_class_map [2378].handle = objc_getClass ("AppKit_NSDatePickerCell__NSDatePickerCellDelegate");
	__xamarin_class_map [2379].handle = objc_getClass ("__NSDocumentDuplicateCallback");
	__xamarin_class_map [2380].handle = objc_getClass ("AppKit_NSDrawer__NSDrawerDelegate");
	__xamarin_class_map [2381].handle = objc_getClass ("AppKit_NSGestureRecognizer__NSGestureRecognizerDelegate");
	__xamarin_class_map [2382].handle = objc_getClass ("__NSGestureRecognizerParameterlessToken");
	__xamarin_class_map [2383].handle = objc_getClass ("__NSGestureRecognizerParametrizedToken");
	__xamarin_class_map [2384].handle = objc_getClass ("AppKit_NSImage__NSImageDelegate");
	__xamarin_class_map [2385].handle = objc_getClass ("__NSMagnificationGestureRecognizer");
	__xamarin_class_map [2386].handle = objc_getClass ("AppKit_NSMatrix__NSMatrixDelegate");
	__xamarin_class_map [2387].handle = objc_getClass ("AppKit_NSPageController__NSPageControllerDelegate");
	__xamarin_class_map [2388].handle = objc_getClass ("__NSPanGestureRecognizer");
	__xamarin_class_map [2389].handle = objc_getClass ("AppKit_NSPathCell__NSPathCellDelegate");
	__xamarin_class_map [2390].handle = objc_getClass ("__NSPressGestureRecognizer");
	__xamarin_class_map [2391].handle = objc_getClass ("__NSRotationGestureRecognizer");
	__xamarin_class_map [2392].handle = objc_getClass ("AppKit_NSRuleEditor__NSRuleEditorDelegate");
	__xamarin_class_map [2393].handle = objc_getClass ("AppKit_NSSavePanel__NSOpenSavePanelDelegate");
	__xamarin_class_map [2394].handle = objc_getClass ("AppKit_NSSearchField__NSSearchFieldDelegate");
	__xamarin_class_map [2395].handle = objc_getClass ("AppKit_NSSharingService__NSSharingServiceDelegate");
	__xamarin_class_map [2396].handle = objc_getClass ("AppKit_NSSharingServicePicker__NSSharingServicePickerDelegate");
	__xamarin_class_map [2397].handle = objc_getClass ("AppKit_NSSound__NSSoundDelegate");
	__xamarin_class_map [2398].handle = objc_getClass ("AppKit_NSTableView__NSTableViewDelegate");
	__xamarin_class_map [2399].handle = objc_getClass ("AppKit_NSTabView__NSTabViewDelegate");
	__xamarin_class_map [2400].handle = objc_getClass ("AppKit_NSText__NSTextDelegate");
	__xamarin_class_map [2401].handle = objc_getClass ("AppKit_NSTextStorage__NSTextStorageDelegate");
	__xamarin_class_map [2402].handle = objc_getClass ("AppKit_NSTextView__NSTextViewDelegate");
	__xamarin_class_map [2403].handle = objc_getClass ("AppKit_NSToolbar__NSToolbarDelegate");
	__xamarin_class_map [2404].handle = objc_getClass ("AppKit_NSTouchBar__NSTouchBarDelegate");
	__xamarin_class_map [2405].handle = objc_getClass ("AppKit_NSWindow__NSWindowDelegate");
	__xamarin_class_map [2406].handle = objc_getClass ("Foundation_NSUrlSessionHandler_WrappedNSInputStream");
	__xamarin_class_map [2407].handle = objc_getClass ("Foundation_NSCache__NSCacheDelegate");
	__xamarin_class_map [2408].handle = objc_getClass ("Foundation_NSKeyedArchiver__NSKeyedArchiverDelegate");
	__xamarin_class_map [2409].handle = objc_getClass ("Foundation_NSKeyedUnarchiver__NSKeyedUnarchiverDelegate");
	__xamarin_class_map [2410].handle = objc_getClass ("Foundation_NSMetadataQuery__NSMetadataQueryDelegate");
	__xamarin_class_map [2411].handle = objc_getClass ("Foundation_NSNetService__NSNetServiceDelegate");
	__xamarin_class_map [2412].handle = objc_getClass ("Foundation_NSNetServiceBrowser__NSNetServiceBrowserDelegate");
	__xamarin_class_map [2413].handle = objc_getClass ("__NSObject_Disposer");
	__xamarin_class_map [2414].handle = objc_getClass ("__XamarinObjectObserver");
	__xamarin_class_map [2415].handle = objc_getClass ("Foundation_NSStream__NSStreamDelegate");
	__xamarin_class_map [2416].handle = objc_getClass ("Foundation_NSThread_ActionThread");
	__xamarin_class_map [2417].handle = objc_getClass ("Foundation_NSUserNotificationCenter__NSUserNotificationCenterDelegate");
	__xamarin_class_map [2418].handle = objc_getClass ("Foundation_NSUrlSessionHandler_NSUrlSessionHandlerDelegate");
	__xamarin_class_map [2419].handle = [AppDelegate class];
	__xamarin_class_map [2420].handle = [ViewController class];
	xamarin_add_registration_map (&__xamarin_registration_map);
}


} /* extern "C" */
